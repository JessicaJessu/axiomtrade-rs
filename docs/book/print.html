<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>axiomtrade-rs Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using the axiomtrade-rs Solana trading SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">axiomtrade-rs Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>axiomtrade-rs</strong> is a high-performance Rust SDK for interacting with the Axiom Trade platform, providing a type-safe, async-first interface for Solana trading operations.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>High Performance</strong>: Built with Rust for zero-cost abstractions and maximum throughput</li>
<li><strong>Type Safety</strong>: Comprehensive type system prevents runtime errors</li>
<li><strong>Async/Await</strong>: Non-blocking operations for concurrent trading</li>
<li><strong>Secure Authentication</strong>: Modern PBKDF2 password hashing with 600,000 iterations</li>
<li><strong>Automatic OTP</strong>: Optional IMAP integration for seamless OTP retrieval</li>
<li><strong>WebSocket Streaming</strong>: Real-time market data and portfolio updates</li>
<li><strong>Portfolio Management</strong>: Comprehensive balance and position tracking</li>
<li><strong>Trading Operations</strong>: Full support for buy, sell, and swap operations</li>
<li><strong>Turnkey Integration</strong>: Hardware wallet support for institutional trading</li>
</ul>
<h2 id="why-choose-axiomtrade-rs"><a class="header" href="#why-choose-axiomtrade-rs">Why Choose axiomtrade-rs?</a></h2>
<h3 id="performance-first"><a class="header" href="#performance-first">Performance First</a></h3>
<p>Built in Rust, axiomtrade-rs delivers exceptional performance with:</p>
<ul>
<li>Sub-50ms API response times</li>
<li>Support for 1000+ concurrent WebSocket connections</li>
<li>Batch operations for 1000+ wallets</li>
<li>Memory usage under 50MB for typical operations</li>
</ul>
<h3 id="developer-experience"><a class="header" href="#developer-experience">Developer Experience</a></h3>
<ul>
<li><strong>Clear Documentation</strong>: Comprehensive guides and examples</li>
<li><strong>Type Safety</strong>: Catch errors at compile time, not runtime</li>
<li><strong>Modern Async</strong>: Built on tokio for excellent concurrency</li>
<li><strong>Rich Examples</strong>: 22+ working examples covering all use cases</li>
</ul>
<h3 id="security--reliability"><a class="header" href="#security--reliability">Security &amp; Reliability</a></h3>
<ul>
<li>Modern password hashing with PBKDF2-SHA256</li>
<li>Secure token management with automatic refresh</li>
<li>Rate limiting and retry logic built-in</li>
<li>Cross-platform compatibility (Windows, Linux, macOS)</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>axiomtrade-rs is organized into several key modules:</p>
<pre><code>axiomtrade-rs/
├── auth/           # Authentication and session management
├── api/            # API endpoints (portfolio, trading, market data)
├── websocket/      # Real-time data streaming
├── models/         # Data structures and types
├── utils/          # Utilities (password hashing, rate limiting)
└── examples/       # Comprehensive examples for all features
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready to start trading with axiomtrade-rs? Jump to our <a href="./quick-start.html">Quick Start Guide</a> to get up and running in minutes.</p>
<p>For detailed setup instructions including automatic OTP configuration, see our <a href="./environment-setup.html">Environment Setup Guide</a>.</p>
<h2 id="community--support"><a class="header" href="#community--support">Community &amp; Support</a></h2>
<ul>
<li><strong>Documentation</strong>: You're reading it!</li>
<li><strong>Issues</strong>: <a href="https://github.com/vibheksoni/axiomtrade-rs/issues">GitHub Issues</a></li>
<li><strong>Discussions</strong>: <a href="https://github.com/vibheksoni/axiomtrade-rs/discussions">GitHub Discussions</a></li>
<li><strong>Support Development</strong>: <a href="https://buymeacoffee.com/vibheksoni">Buy me a coffee</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>axiomtrade-rs is licensed under the <a href="https://github.com/vibheksoni/axiomtrade-rs/blob/master/LICENSE">MIT License</a> with an optional attribution request to help support the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide covers all methods for installing axiomtrade-rs, system requirements, and platform-specific setup instructions.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="rust-version-requirements"><a class="header" href="#rust-version-requirements">Rust Version Requirements</a></h3>
<p>axiomtrade-rs requires <strong>Rust 1.70 or later</strong> with the 2024 edition. Check your Rust version:</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<p>If you need to install or update Rust:</p>
<pre><code class="language-bash"># Install Rust via rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Update existing Rust installation
rustup update
</code></pre>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h3>
<p><strong>Minimum Requirements:</strong></p>
<ul>
<li>RAM: 2GB available memory</li>
<li>Storage: 500MB free disk space</li>
<li>Network: Stable internet connection for API access</li>
</ul>
<p><strong>Recommended:</strong></p>
<ul>
<li>RAM: 4GB+ for optimal performance</li>
<li>Storage: 2GB+ for full development setup</li>
<li>CPU: Multi-core processor for concurrent operations</li>
</ul>
<h3 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h3>
<p>axiomtrade-rs supports all major platforms:</p>
<ul>
<li><strong>Windows</strong> (Windows 10/11, Windows Server 2019+)</li>
<li><strong>Linux</strong> (Ubuntu 18.04+, RHEL 8+, Debian 10+)</li>
<li><strong>macOS</strong> (macOS 10.15+, both Intel and Apple Silicon)</li>
</ul>
<h2 id="installation-methods"><a class="header" href="#installation-methods">Installation Methods</a></h2>
<h3 id="option-1-install-from-cratesio-recommended"><a class="header" href="#option-1-install-from-cratesio-recommended">Option 1: Install from crates.io (Recommended)</a></h3>
<p>The easiest way to use axiomtrade-rs in your project:</p>
<pre><code class="language-toml">[dependencies]
axiomtrade-rs = "0.1.0"
</code></pre>
<p>Then run:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<h3 id="option-2-install-from-source"><a class="header" href="#option-2-install-from-source">Option 2: Install from Source</a></h3>
<p>For the latest development version or contributing:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/vibheksoni/axiomtrade-rs.git
cd axiomtrade-rs

# Build the project
cargo build --release

# Run tests to verify installation
cargo test
</code></pre>
<h3 id="option-3-install-specific-features"><a class="header" href="#option-3-install-specific-features">Option 3: Install Specific Features</a></h3>
<p>axiomtrade-rs uses feature flags for optional functionality:</p>
<pre><code class="language-toml">[dependencies]
axiomtrade-rs = { version = "0.1.0", features = ["websocket", "auto-otp"] }
</code></pre>
<p>Available features:</p>
<ul>
<li><code>websocket</code> - Real-time WebSocket support</li>
<li><code>auto-otp</code> - Automatic OTP fetching via IMAP</li>
<li><code>hyperliquid</code> - Hyperliquid integration</li>
<li><code>notifications</code> - Email and system notifications</li>
</ul>
<h2 id="dependency-overview"><a class="header" href="#dependency-overview">Dependency Overview</a></h2>
<p>axiomtrade-rs uses carefully selected dependencies for optimal performance and security:</p>
<h3 id="core-dependencies"><a class="header" href="#core-dependencies">Core Dependencies</a></h3>
<ul>
<li><strong>tokio</strong> (v1.40) - Async runtime with full features</li>
<li><strong>reqwest</strong> (v0.12) - HTTP client with JSON and cookie support</li>
<li><strong>serde</strong> (v1.0) - Serialization framework</li>
<li><strong>thiserror</strong> (v1.0) - Error handling</li>
</ul>
<h3 id="cryptography--security"><a class="header" href="#cryptography--security">Cryptography &amp; Security</a></h3>
<ul>
<li><strong>pbkdf2</strong> (v0.12) - Password hashing</li>
<li><strong>sha2</strong> (v0.10) - SHA256 hashing</li>
<li><strong>p256</strong> (v0.13) - ECDSA cryptography for Turnkey</li>
<li><strong>hmac</strong> (v0.12) - HMAC signatures</li>
</ul>
<h3 id="websocket-support"><a class="header" href="#websocket-support">WebSocket Support</a></h3>
<ul>
<li><strong>tokio-tungstenite</strong> (v0.24) - WebSocket client</li>
<li><strong>fastwebsockets</strong> (v0.10) - High-performance WebSocket handling</li>
</ul>
<h3 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h3>
<ul>
<li><strong>imap</strong> (v2.4) - Email OTP fetching</li>
<li><strong>native-tls</strong> (v0.2) - TLS support</li>
<li><strong>regex</strong> (v1.10) - Pattern matching</li>
</ul>
<h2 id="platform-specific-setup"><a class="header" href="#platform-specific-setup">Platform-Specific Setup</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p><strong>Prerequisites:</strong></p>
<pre><code class="language-powershell"># Install Visual Studio Build Tools or Visual Studio Community
# Download from: https://visualstudio.microsoft.com/downloads/

# Or install via chocolatey
choco install microsoft-build-tools

# Install Git
winget install Git.Git
</code></pre>
<p><strong>Installation:</strong></p>
<pre><code class="language-powershell"># Open PowerShell as Administrator
git clone https://github.com/vibheksoni/axiomtrade-rs.git
cd axiomtrade-rs
cargo build --release
</code></pre>
<p><strong>Common Windows Issues:</strong></p>
<ul>
<li>If you encounter linker errors, ensure Visual Studio Build Tools are installed</li>
<li>For SSL/TLS issues, you may need to install certificates: <code>cargo install cargo-update</code></li>
</ul>
<h3 id="linux-ubuntudebian"><a class="header" href="#linux-ubuntudebian">Linux (Ubuntu/Debian)</a></h3>
<p><strong>Prerequisites:</strong></p>
<pre><code class="language-bash"># Update package list
sudo apt update

# Install build essentials
sudo apt install build-essential pkg-config libssl-dev

# Install Git
sudo apt install git

# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
</code></pre>
<p><strong>Installation:</strong></p>
<pre><code class="language-bash">git clone https://github.com/vibheksoni/axiomtrade-rs.git
cd axiomtrade-rs
cargo build --release
</code></pre>
<h3 id="linux-rhelcentosfedora"><a class="header" href="#linux-rhelcentosfedora">Linux (RHEL/CentOS/Fedora)</a></h3>
<p><strong>Prerequisites:</strong></p>
<pre><code class="language-bash"># RHEL/CentOS
sudo yum groupinstall "Development Tools"
sudo yum install openssl-devel pkg-config

# Fedora
sudo dnf groupinstall "Development Tools"
sudo dnf install openssl-devel pkg-config
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p><strong>Prerequisites:</strong></p>
<pre><code class="language-bash"># Install Xcode Command Line Tools
xcode-select --install

# Install Homebrew (optional but recommended)
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install Git (if not already available)
brew install git
</code></pre>
<p><strong>Installation:</strong></p>
<pre><code class="language-bash">git clone https://github.com/vibheksoni/axiomtrade-rs.git
cd axiomtrade-rs
cargo build --release
</code></pre>
<p><strong>Apple Silicon (M1/M2) Notes:</strong></p>
<ul>
<li>No special configuration needed</li>
<li>All dependencies are compatible with ARM64</li>
<li>Performance is excellent on Apple Silicon</li>
</ul>
<h2 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h2>
<h3 id="required-environment-variables"><a class="header" href="#required-environment-variables">Required Environment Variables</a></h3>
<p>Create a <code>.env</code> file in your project root:</p>
<pre><code class="language-bash"># Axiom Trade credentials
AXIOM_EMAIL=your_email@example.com
AXIOM_PASSWORD=your_password

# Optional: Automated OTP (requires inbox.lv setup)
INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_imap_password

# Optional: API configuration
AXIOM_API_BASE_URL=https://axiom.trade
AXIOM_TIMEOUT_SECONDS=30
</code></pre>
<h3 id="auto-otp-setup-optional"><a class="header" href="#auto-otp-setup-optional">Auto-OTP Setup (Optional)</a></h3>
<p>For automated OTP fetching:</p>
<ol>
<li><strong>Create inbox.lv account</strong>: Visit https://www.inbox.lv/</li>
<li><strong>Enable IMAP</strong>: Go to Settings → "Outlook, email programs" → Enable</li>
<li><strong>Get IMAP password</strong>: Save the special password provided (not your web login)</li>
<li><strong>Configure forwarding</strong>: Forward Axiom OTP emails to your inbox.lv address</li>
<li><strong>Set environment variables</strong> as shown above</li>
</ol>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<h3 id="basic-verification"><a class="header" href="#basic-verification">Basic Verification</a></h3>
<pre><code class="language-bash"># Verify compilation
cargo check

# Run all tests
cargo test

# Check specific features
cargo test --features websocket
cargo test --features auto-otp
</code></pre>
<h3 id="quick-start-test"><a class="header" href="#quick-start-test">Quick Start Test</a></h3>
<p>Create <code>test_installation.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::AxiomClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Test basic client creation
    let client = AxiomClient::new();
    println!("axiomtrade-rs installed successfully!");
    Ok(())
}</code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run --bin test_installation
</code></pre>
<h3 id="performance-benchmarks"><a class="header" href="#performance-benchmarks">Performance Benchmarks</a></h3>
<p>Run performance tests:</p>
<pre><code class="language-bash"># Basic performance test
cargo test --release performance_tests

# WebSocket performance
cargo run --example basic_websocket --release

# Memory usage test
cargo run --example portfolio_monitoring --release
</code></pre>
<p>Expected performance metrics:</p>
<ul>
<li>API response time: &lt;50ms</li>
<li>WebSocket latency: &lt;10ms</li>
<li>Memory usage: &lt;50MB for typical operations</li>
<li>Concurrent connections: 1000+ supported</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Build Failures:</strong></p>
<pre><code class="language-bash"># Clear cargo cache
cargo clean

# Update dependencies
cargo update

# Rebuild from scratch
rm -rf target/
cargo build
</code></pre>
<p><strong>SSL/TLS Errors:</strong></p>
<pre><code class="language-bash"># Update certificates (Linux)
sudo apt update ca-certificates

# macOS
brew install ca-certificates

# Windows: Update Windows or install latest Visual Studio
</code></pre>
<p><strong>Permission Errors:</strong></p>
<pre><code class="language-bash"># Linux/macOS: Ensure cargo directory permissions
chmod -R 755 ~/.cargo

# Windows: Run PowerShell as Administrator
</code></pre>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<ul>
<li><strong>Documentation</strong>: https://docs.rs/axiomtrade-rs</li>
<li><strong>Examples</strong>: Check the <code>examples/</code> directory</li>
<li><strong>Issues</strong>: https://github.com/vibheksoni/axiomtrade-rs/issues</li>
<li><strong>Discussions</strong>: https://github.com/vibheksoni/axiomtrade-rs/discussions</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>After successful installation:</p>
<ol>
<li><strong>Read the <a href="./quick-start.html">Quick Start Guide</a></strong> for basic usage</li>
<li><strong>Review <a href="./examples/authentication.html">Examples</a></strong> for common patterns</li>
<li><strong>Set up <a href="./environment-setup.html">Environment Configuration</a></strong></li>
<li><strong>Explore <a href="./api/portfolio.html">API Documentation</a></strong> for detailed features</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<p>For contributing or advanced development:</p>
<pre><code class="language-bash"># Install additional development tools
cargo install cargo-watch cargo-tarpaulin cargo-audit

# Set up pre-commit hooks
cargo install pre-commit
pre-commit install

# Run development server with auto-reload
cargo watch -x "run --example portfolio_monitoring"
</code></pre>
<p>The installation is now complete and verified. You can proceed to the Quick Start guide to begin using axiomtrade-rs in your projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with axiomtrade-rs in under 5 minutes.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add axiomtrade-rs to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
axiomtrade-rs = "0.1.0"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="1-authentication"><a class="header" href="#1-authentication">1. Authentication</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    let email = "your-email@example.com";
    let password = "your-password";
    
    // Login and get tokens
    let tokens = auth_client.login(&amp;email, &amp;password, None).await?;
    println!("Login successful! Access token: {}", tokens.access_token);
    
    Ok(())
}</code></pre></pre>
<h3 id="2-portfolio-management"><a class="header" href="#2-portfolio-management">2. Portfolio Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::portfolio::PortfolioClient;

// Get wallet balance
let mut portfolio_client = PortfolioClient::new()?;
let wallet = "your-wallet-address";
let balance = portfolio_client.get_balance(wallet).await?;
println!("SOL Balance: {} SOL", balance.sol_balance);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-trading-operations"><a class="header" href="#3-trading-operations">3. Trading Operations</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::trading::TradingClient;

// Execute a simple trade
let mut trading_client = TradingClient::new()?;
let result = trading_client.buy_token(
    "token-mint-address",
    1.0, // Amount in SOL
    None, // Use default slippage
).await?;
println!("Trade executed: {:?}", result);
<span class="boring">}</span></code></pre></pre>
<h3 id="4-websocket-streaming"><a class="header" href="#4-websocket-streaming">4. WebSocket Streaming</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::websocket::{client::WebSocketClient, handler::MessageHandler};

struct MyHandler;

impl MessageHandler for MyHandler {
    async fn handle_message(&amp;self, message: String) {
        println!("Received: {}", message);
    }
}

// Connect to WebSocket
let mut ws_client = WebSocketClient::new("wss://api.axiom.trade/ws").await?;
ws_client.set_handler(Box::new(MyHandler)).await;
ws_client.connect().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h2>
<p>For automatic OTP and other features, create a <code>.env</code> file:</p>
<pre><code class="language-env"># Axiom Trade credentials
AXIOM_EMAIL=your-email@example.com
AXIOM_PASSWORD=your-password

# Optional: Automatic OTP via inbox.lv
INBOX_LV_EMAIL=your-otp-email@inbox.lv
INBOX_LV_PASSWORD=your-imap-password
</code></pre>
<h2 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h2>
<p>The repository includes 22+ working examples:</p>
<pre><code class="language-bash"># Authentication examples
cargo run --example basic_login
cargo run --example otp_verification

# Portfolio examples
cargo run --example get_portfolio
cargo run --example batch_balances

# Trading examples
cargo run --example simple_trade

# WebSocket examples
cargo run --example basic_websocket
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><strong>Authentication</strong>: Learn about <a href="./auth/sessions.html">session management</a> and <a href="./automatic-otp.html">automatic OTP</a></li>
<li><strong>Trading</strong>: Explore <a href="./api/trading.html">trading operations</a> and <a href="./best-practices/security.html">risk management</a></li>
<li><strong>WebSocket</strong>: Set up <a href="./api/websocket.html">real-time data streaming</a></li>
<li><strong>Examples</strong>: Browse all <a href="./examples/authentication.html">working examples</a></li>
</ul>
<h2 id="need-help"><a class="header" href="#need-help">Need Help?</a></h2>
<ul>
<li>Check the <a href="./troubleshooting/common-issues.html">troubleshooting guide</a></li>
<li>Browse <a href="./troubleshooting/faq.html">frequently asked questions</a></li>
<li>Open an issue on <a href="https://github.com/vibheksoni/axiomtrade-rs/issues">GitHub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup-1"><a class="header" href="#environment-setup-1">Environment Setup</a></h1>
<p>This guide covers all aspects of configuring your environment for axiomtrade-rs, including required credentials, automated setup tools, and security best practices.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>axiomtrade-rs requires specific environment variables to function properly. You can configure these using:</p>
<ul>
<li><strong>Automated setup utility</strong> - Interactive tool for guided configuration</li>
<li><strong>Manual .env file creation</strong> - Direct file editing</li>
<li><strong>Environment variable validation</strong> - Built-in verification tools</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>For immediate setup, run the interactive configuration tool:</p>
<pre><code class="language-bash">cargo run --example environment_setup
</code></pre>
<p>This tool will guide you through the entire configuration process, including credential setup, OTP automation, and validation testing.</p>
<h2 id="required-environment-variables-1"><a class="header" href="#required-environment-variables-1">Required Environment Variables</a></h2>
<h3 id="core-authentication-variables"><a class="header" href="#core-authentication-variables">Core Authentication Variables</a></h3>
<p>These variables are required for basic functionality:</p>
<pre><code class="language-env"># Axiom Trade account credentials
AXIOM_EMAIL=your-axiom-email@domain.com
AXIOM_PASSWORD=your-axiom-password
</code></pre>
<h3 id="optional-otp-automation-variables"><a class="header" href="#optional-otp-automation-variables">Optional OTP Automation Variables</a></h3>
<p>For automatic OTP retrieval (eliminates manual code entry):</p>
<pre><code class="language-env"># inbox.lv IMAP credentials for automatic OTP
INBOX_LV_EMAIL=your-username@inbox.lv
INBOX_LV_PASSWORD=your-special-imap-password
</code></pre>
<p><strong>Note</strong>: The <code>INBOX_LV_PASSWORD</code> is a special IMAP password, not your regular web login password.</p>
<h3 id="additional-configuration-options"><a class="header" href="#additional-configuration-options">Additional Configuration Options</a></h3>
<pre><code class="language-env"># Optional: API endpoints (uses defaults if not specified)
AXIOM_API_BASE_URL=https://api.axiom.trade
AXIOM_WS_URL=wss://api.axiom.trade/ws

# Optional: Logging level
RUST_LOG=debug
</code></pre>
<h2 id="setup-methods"><a class="header" href="#setup-methods">Setup Methods</a></h2>
<h3 id="method-1-automated-setup-tool"><a class="header" href="#method-1-automated-setup-tool">Method 1: Automated Setup Tool</a></h3>
<p>The interactive setup tool provides guided configuration with proper validation:</p>
<pre><code class="language-bash">cargo run --example environment_setup
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Interactive credential collection</li>
<li>Automatic special character escaping</li>
<li>Environment validation</li>
<li>Configuration testing</li>
<li>Backup creation for existing files</li>
</ul>
<p><strong>Sample interaction:</strong></p>
<pre><code>axiomtrade-rs Environment Setup Helper
This tool will help you configure your environment for the library

❌ No .env file found
Let's create one with the required configuration

=== Axiom Trade Credentials ===
Axiom Trade email: user@example.com
Axiom Trade password: [secure input]

=== Optional: Automatic OTP Setup ===
To enable automatic OTP, you need an inbox.lv account
Leave blank to skip automatic OTP (you'll enter codes manually)
Set up automatic OTP? (y/n): y

See examples/setup/auto_otp_setup.md for inbox.lv setup instructions
inbox.lv email (username@inbox.lv): myuser@inbox.lv
inbox.lv IMAP password: [secure input]

✓ Configuration file created successfully
</code></pre>
<h3 id="method-2-legacy-setup-utility"><a class="header" href="#method-2-legacy-setup-utility">Method 2: Legacy Setup Utility</a></h3>
<p>The older setup utility from <code>oldstuff/setup_env.rs</code> provides similar functionality:</p>
<pre><code class="language-bash">cd oldstuff
cargo run --bin setup_env
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Advanced password escaping</li>
<li>Secure file permissions (Unix systems)</li>
<li>Comprehensive validation</li>
<li>Detailed troubleshooting guidance</li>
</ul>
<h3 id="method-3-manual-configuration"><a class="header" href="#method-3-manual-configuration">Method 3: Manual Configuration</a></h3>
<p>Create a <code>.env</code> file in your project root directory:</p>
<pre><code class="language-bash"># Create the file
touch .env

# Set secure permissions (Unix/Linux/macOS)
chmod 600 .env
</code></pre>
<p>Add the required variables:</p>
<pre><code class="language-env"># axiomtrade-rs Environment Configuration

# Axiom Trade Credentials
AXIOM_EMAIL=your-email@domain.com
AXIOM_PASSWORD=your-password

# Optional: Automatic OTP via inbox.lv
INBOX_LV_EMAIL=your-username@inbox.lv
INBOX_LV_PASSWORD=your-imap-password

# Optional: Additional Configuration
# AXIOM_API_BASE_URL=https://api.axiom.trade
# AXIOM_WS_URL=wss://api.axiom.trade/ws
# RUST_LOG=debug
</code></pre>
<h2 id="using-the-setup-environment-utility"><a class="header" href="#using-the-setup-environment-utility">Using the Setup Environment Utility</a></h2>
<p>The environment setup utility provides comprehensive configuration management:</p>
<h3 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h3>
<pre><code class="language-bash">cargo run --example environment_setup
</code></pre>
<p>When no <code>.env</code> file exists, the tool will:</p>
<ol>
<li>Guide you through credential entry</li>
<li>Offer optional OTP automation setup</li>
<li>Create a properly formatted <code>.env</code> file</li>
<li>Provide next steps for testing</li>
</ol>
<h3 id="updating-existing-configuration"><a class="header" href="#updating-existing-configuration">Updating Existing Configuration</a></h3>
<p>If you already have a <code>.env</code> file:</p>
<pre><code class="language-bash">cargo run --example environment_setup
</code></pre>
<p>The tool offers options to:</p>
<ul>
<li><strong>Test current configuration</strong> - Validate all settings</li>
<li><strong>Update configuration</strong> - Modify specific sections</li>
<li><strong>View configuration guide</strong> - Display help information</li>
<li><strong>Reset configuration</strong> - Start fresh</li>
</ul>
<h3 id="configuration-testing"><a class="header" href="#configuration-testing">Configuration Testing</a></h3>
<p>The utility includes built-in testing:</p>
<pre><code class="language-bash"># Test all configuration
cargo run --example environment_setup
# Choose option 1: Test current configuration
</code></pre>
<p>Testing includes:</p>
<ul>
<li>Environment variable validation</li>
<li>IMAP connection testing (if configured)</li>
<li>Basic authentication verification</li>
<li>OTP automation validation</li>
</ul>
<h2 id="automatic-otp-setup"><a class="header" href="#automatic-otp-setup">Automatic OTP Setup</a></h2>
<p>For seamless authentication without manual OTP entry, configure automatic OTP retrieval via inbox.lv:</p>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ol>
<li><strong>inbox.lv account</strong> - Free email service with IMAP support</li>
<li><strong>IMAP access enabled</strong> - Must be activated in inbox.lv settings</li>
<li><strong>Email forwarding configured</strong> - Axiom Trade OTP emails to inbox.lv</li>
</ol>
<h3 id="setup-process"><a class="header" href="#setup-process">Setup Process</a></h3>
<ol>
<li>
<p><strong>Create inbox.lv account</strong>:</p>
<ul>
<li>Visit <a href="https://www.inbox.lv/">https://www.inbox.lv/</a></li>
<li>Register a new account</li>
<li>Note your full email: <code>username@inbox.lv</code></li>
</ul>
</li>
<li>
<p><strong>Enable IMAP access</strong>:</p>
<pre><code>Settings → "Outlook, email programs" → Enable
Direct URL: https://email.inbox.lv/prefs?group=enable_pop3
Wait 15 minutes for activation
</code></pre>
</li>
<li>
<p><strong>Configure email forwarding</strong>:</p>
<ul>
<li>Log into Axiom Trade account</li>
<li>Update notification email to your inbox.lv address</li>
<li>Ensure OTP emails are forwarded</li>
</ul>
</li>
<li>
<p><strong>Get IMAP password</strong>:</p>
<ul>
<li>Return to inbox.lv settings after 15 minutes</li>
<li>Copy the special IMAP/SMTP password</li>
<li>This is different from your web login password</li>
</ul>
</li>
<li>
<p><strong>Configure environment variables</strong>:</p>
<pre><code class="language-env">INBOX_LV_EMAIL=your-username@inbox.lv
INBOX_LV_PASSWORD=your-special-imap-password
</code></pre>
</li>
<li>
<p><strong>Test the setup</strong>:</p>
<pre><code class="language-bash">cargo run --example test_auto_otp
</code></pre>
</li>
</ol>
<p>For detailed setup instructions, see: <code>examples/setup/auto_otp_setup.md</code></p>
<h2 id="manual-env-configuration"><a class="header" href="#manual-env-configuration">Manual .env Configuration</a></h2>
<h3 id="file-creation"><a class="header" href="#file-creation">File Creation</a></h3>
<pre><code class="language-bash"># Create .env file in project root
touch .env

# Set restrictive permissions (recommended)
chmod 600 .env  # Unix/Linux/macOS only
</code></pre>
<h3 id="variable-format"><a class="header" href="#variable-format">Variable Format</a></h3>
<p>Use proper formatting to handle special characters:</p>
<pre><code class="language-env"># Simple values (no spaces or special characters)
AXIOM_EMAIL=user@example.com

# Values with special characters (use quotes)
AXIOM_PASSWORD="my-complex-password!@#$"

# Values with spaces (use quotes)
SOME_VALUE="value with spaces"

# Avoid these characters without quotes: $ ` " ' \ # space
</code></pre>
<h3 id="special-character-handling"><a class="header" href="#special-character-handling">Special Character Handling</a></h3>
<p>The library's <code>EnvLoader</code> properly handles special characters:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Values are automatically parsed correctly
let password = env::var("AXIOM_PASSWORD")?; // Works with special chars
<span class="boring">}</span></code></pre></pre>
<p><strong>Characters requiring quotes</strong>:</p>
<ul>
<li>Spaces: <code>"password with spaces"</code></li>
<li>Dollar signs: <code>"password$with$dollars"</code></li>
<li>Quotes: <code>"password\"with\"quotes"</code></li>
<li>Backslashes: <code>"password\\with\\backslashes"</code></li>
</ul>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<h3 id="credential-management"><a class="header" href="#credential-management">Credential Management</a></h3>
<ol>
<li>
<p><strong>Use strong passwords</strong>:</p>
<ul>
<li>12+ characters with mixed case, numbers, symbols</li>
<li>Unique passwords for each service</li>
<li>Consider using a password manager</li>
</ul>
</li>
<li>
<p><strong>Protect credential files</strong>:</p>
<pre><code class="language-bash"># Set restrictive permissions
chmod 600 .env

# Verify permissions
ls -la .env  # Should show: -rw-------
</code></pre>
</li>
<li>
<p><strong>Never commit credentials</strong>:</p>
<pre><code class="language-bash"># Ensure .env is in .gitignore
echo ".env" &gt;&gt; .gitignore
</code></pre>
</li>
</ol>
<h3 id="network-security"><a class="header" href="#network-security">Network Security</a></h3>
<ol>
<li><strong>Use secure connections</strong> - axiomtrade-rs uses HTTPS/WSS by default</li>
<li><strong>Verify certificates</strong> - Built-in certificate validation</li>
<li><strong>Monitor authentication</strong> - Log successful/failed attempts</li>
<li><strong>Rotate credentials regularly</strong> - Update passwords periodically</li>
</ol>
<h3 id="production-environment"><a class="header" href="#production-environment">Production Environment</a></h3>
<ol>
<li>
<p><strong>Environment isolation</strong>:</p>
<pre><code class="language-bash"># Different .env files for different environments
.env.development
.env.staging  
.env.production
</code></pre>
</li>
<li>
<p><strong>Secret management</strong>:</p>
<ul>
<li>Consider using secret management services</li>
<li>Use environment variables in production</li>
<li>Avoid storing secrets in container images</li>
</ul>
</li>
<li>
<p><strong>Access control</strong>:</p>
<ul>
<li>Limit access to credential files</li>
<li>Use service accounts where appropriate</li>
<li>Implement proper logging and monitoring</li>
</ul>
</li>
</ol>
<h2 id="configuration-validation"><a class="header" href="#configuration-validation">Configuration Validation</a></h2>
<h3 id="built-in-validation"><a class="header" href="#built-in-validation">Built-in Validation</a></h3>
<p>Test your configuration using the provided tools:</p>
<pre><code class="language-bash"># Comprehensive testing
cargo run --example environment_setup
# Choose: Test current configuration

# OTP-specific testing
cargo run --example test_auto_otp

# Basic authentication testing
cargo run --example basic_login
</code></pre>
<h3 id="manual-validation"><a class="header" href="#manual-validation">Manual Validation</a></h3>
<p>Verify variables are loaded correctly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

fn validate_config() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load environment variables
    dotenvy::dotenv().ok();
    
    // Check required variables
    let email = env::var("AXIOM_EMAIL")?;
    let password = env::var("AXIOM_PASSWORD")?;
    
    println!("Email configured: {}", email);
    println!("Password configured: [{}]", "*".repeat(password.len()));
    
    // Check optional OTP variables
    if let (Ok(otp_email), Ok(_otp_pass)) = (
        env::var("INBOX_LV_EMAIL"),
        env::var("INBOX_LV_PASSWORD")
    ) {
        println!("OTP automation configured for: {}", otp_email);
    } else {
        println!("Manual OTP entry will be required");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-variable-priority"><a class="header" href="#environment-variable-priority">Environment Variable Priority</a></h3>
<p>The library loads variables in this order (last wins):</p>
<ol>
<li>Process environment variables</li>
<li><code>.env</code> file in current directory</li>
<li><code>.env</code> file in parent directories (recursive search)</li>
</ol>
<p>Override specific variables for testing:</p>
<pre><code class="language-bash"># Override for single command
AXIOM_EMAIL=test@example.com cargo run --example basic_login

# Export for session
export RUST_LOG=debug
cargo run --example environment_setup
</code></pre>
<h2 id="command-line-instructions"><a class="header" href="#command-line-instructions">Command Line Instructions</a></h2>
<h3 id="setup-commands"><a class="header" href="#setup-commands">Setup Commands</a></h3>
<pre><code class="language-bash"># Initial environment setup
cargo run --example environment_setup

# Legacy setup utility
cd oldstuff &amp;&amp; cargo run --bin setup_env

# Test automatic OTP setup
cargo run --example test_auto_otp

# Test basic authentication
cargo run --example basic_login
</code></pre>
<h3 id="validation-commands"><a class="header" href="#validation-commands">Validation Commands</a></h3>
<pre><code class="language-bash"># Validate environment loading
cargo test utils::env_loader::tests

# Test password handling
cargo run --example test_password

# Check configuration completeness
cargo run --example environment_setup
# Choose option 1: Test current configuration
</code></pre>
<h3 id="development-commands"><a class="header" href="#development-commands">Development Commands</a></h3>
<pre><code class="language-bash"># Enable debug logging
export RUST_LOG=debug
cargo run --example your_example

# Test with different environment
AXIOM_EMAIL=different@email.com cargo run --example basic_login

# Run with production config
cargo run --release --example trading_bot
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<h4 id="environment-variables-not-found"><a class="header" href="#environment-variables-not-found">"Environment variables not found"</a></h4>
<pre><code class="language-bash"># Check if .env file exists
ls -la .env

# Verify file contents (be careful with passwords)
head .env

# Run setup tool
cargo run --example environment_setup
</code></pre>
<h4 id="imap-connection-failed"><a class="header" href="#imap-connection-failed">"IMAP connection failed"</a></h4>
<pre><code class="language-bash"># Test IMAP configuration
cargo run --example test_auto_otp

# Check inbox.lv setup
# 1. Verify IMAP is enabled (wait 15 minutes after enabling)
# 2. Confirm you're using IMAP password, not web password
# 3. Check email address spelling
</code></pre>
<h4 id="authentication-failed"><a class="header" href="#authentication-failed">"Authentication failed"</a></h4>
<pre><code class="language-bash"># Verify credentials by logging into Axiom Trade website
# Update credentials using setup tool
cargo run --example environment_setup
# Choose option 2: Update configuration
</code></pre>
<h4 id="special-characters-in-password"><a class="header" href="#special-characters-in-password">"Special characters in password"</a></h4>
<pre><code class="language-bash"># Use the automated setup tool for proper escaping
cargo run --example environment_setup

# Or manually quote the value in .env:
AXIOM_PASSWORD="password-with-special-chars!@#$"
</code></pre>
<h3 id="debug-steps"><a class="header" href="#debug-steps">Debug Steps</a></h3>
<ol>
<li>
<p><strong>Check environment loading</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;
dotenvy::dotenv().ok();
for (key, value) in env::vars() {
    if key.starts_with("AXIOM_") || key.starts_with("INBOX_") {
        println!("{}: {}", key, if key.contains("PASSWORD") { "[HIDDEN]" } else { &amp;value });
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Test individual components</strong>:</p>
<pre><code class="language-bash"># Test just environment loading
cargo test env_loader

# Test just IMAP (if configured)
cargo run --example test_auto_otp

# Test just authentication
cargo run --example basic_login
</code></pre>
</li>
<li>
<p><strong>Enable verbose logging</strong>:</p>
<pre><code class="language-bash">export RUST_LOG=axiomtrade_rs=debug
cargo run --example your_example
</code></pre>
</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>After completing environment setup:</p>
<ol>
<li>
<p><strong>Test authentication</strong>:</p>
<pre><code class="language-bash">cargo run --example basic_login
</code></pre>
</li>
<li>
<p><strong>Explore examples</strong>:</p>
<pre><code class="language-bash">ls examples/
cargo run --example portfolio_monitoring
</code></pre>
</li>
<li>
<p><strong>Build your application</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::AxiomClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Environment is automatically loaded
    let client = AxiomClient::new().await?;
    // Your application logic here
    Ok(())
}</code></pre></pre>
</li>
<li>
<p><strong>Review additional documentation</strong>:</p>
<ul>
<li><a href="auth/login.html">Authentication Guide</a></li>
<li><a href="automatic-otp.html">Automatic OTP Setup</a></li>
<li><a href="examples/trading.html">Trading Examples</a></li>
<li><a href="best-practices/security.html">Security Best Practices</a></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-otp"><a class="header" href="#automatic-otp">Automatic OTP</a></h1>
<p>The Axiom Trade Rust client provides automatic OTP (One-Time Password) retrieval functionality that eliminates the need to manually check emails for verification codes. This feature uses IMAP protocol to fetch OTP codes directly from your inbox.lv email account.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>When enabled, the automatic OTP system:</p>
<ul>
<li>Monitors your inbox.lv email account for new Axiom security codes</li>
<li>Extracts 6-digit OTP codes from email subjects and bodies</li>
<li>Provides methods for immediate retrieval or waiting for new codes</li>
<li>Automatically marks processed emails as read to avoid duplicates</li>
</ul>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Axiom Trade account with OTP authentication enabled</li>
<li>inbox.lv email account with IMAP access</li>
<li>Environment variables configured for email credentials</li>
</ul>
<h2 id="configuration-setup"><a class="header" href="#configuration-setup">Configuration Setup</a></h2>
<h3 id="1-inboxlv-account-setup"><a class="header" href="#1-inboxlv-account-setup">1. inbox.lv Account Setup</a></h3>
<p>Create a dedicated inbox.lv email account for OTP purposes:</p>
<ol>
<li>
<p><strong>Register Account</strong></p>
<ul>
<li>Navigate to <a href="https://www.inbox.lv/">https://www.inbox.lv/</a></li>
<li>Click "Register" and complete the form</li>
<li>Choose a unique username (becomes <code>username@inbox.lv</code>)</li>
<li>Verify your account through the confirmation email</li>
</ul>
</li>
<li>
<p><strong>Enable IMAP Access</strong></p>
<ul>
<li>Log into inbox.lv web interface</li>
<li>Go to Settings → "Outlook, email programs"</li>
<li>Click "Enable" button for IMAP access</li>
<li>Direct link: <a href="https://email.inbox.lv/prefs?group=enable_pop3">https://email.inbox.lv/prefs?group=enable_pop3</a></li>
<li>Wait 15 minutes for activation to complete</li>
</ul>
</li>
<li>
<p><strong>Retrieve IMAP Credentials</strong></p>
<ul>
<li>After the 15-minute wait, refresh your settings page</li>
<li>Locate the "IMAP/SMTP Password" section</li>
<li>Copy the special IMAP password (different from web login password)</li>
<li>Save these credentials securely</li>
</ul>
</li>
</ol>
<h3 id="2-imap-configuration"><a class="header" href="#2-imap-configuration">2. IMAP Configuration</a></h3>
<p>The client uses these IMAP settings for inbox.lv:</p>
<ul>
<li><strong>Server</strong>: <code>mail.inbox.lv</code></li>
<li><strong>Port</strong>: <code>993</code> (SSL/TLS)</li>
<li><strong>Security</strong>: TLS encryption</li>
<li><strong>Authentication</strong>: Username/password</li>
</ul>
<h3 id="3-email-forwarding-setup"><a class="header" href="#3-email-forwarding-setup">3. Email Forwarding Setup</a></h3>
<p>Configure Axiom Trade to send OTP emails to your inbox.lv account:</p>
<ol>
<li>
<p><strong>Access Axiom Settings</strong></p>
<ul>
<li>Log into your Axiom Trade account</li>
<li>Navigate to Account Settings or Security Settings</li>
<li>Find "Email Preferences" or "Notification Settings"</li>
</ul>
</li>
<li>
<p><strong>Configure Forwarding</strong></p>
<ul>
<li>Add your inbox.lv email as the notification address</li>
<li>Enable "Security Code" or "OTP" notifications</li>
<li>Save the configuration</li>
</ul>
</li>
<li>
<p><strong>Test Email Delivery</strong></p>
<ul>
<li>Trigger an OTP request from Axiom Trade</li>
<li>Verify the email arrives at your inbox.lv account</li>
<li>Confirm subject format: "Your Axiom security code is XXXXXX"</li>
</ul>
</li>
</ol>
<h3 id="4-environment-variables"><a class="header" href="#4-environment-variables">4. Environment Variables</a></h3>
<p>Set the required environment variables in your <code>.env</code> file:</p>
<pre><code class="language-env"># inbox.lv IMAP Configuration
INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_special_imap_password

# Axiom Trade Credentials (if using automatic login)
AXIOM_EMAIL=your_axiom_email@domain.com
AXIOM_PASSWORD=your_axiom_password
</code></pre>
<p><strong>Important Notes:</strong></p>
<ul>
<li>Use the IMAP password, not your web login password</li>
<li>Ensure no spaces around the <code>=</code> signs</li>
<li>Never commit <code>.env</code> files to version control</li>
</ul>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-otp-retrieval"><a class="header" href="#basic-otp-retrieval">Basic OTP Retrieval</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::email::otp_fetcher::{OtpFetcher, from_env};

// Create fetcher from environment variables
let fetcher = from_env()?.expect("OTP environment variables not configured");

// Fetch the latest unread OTP
if let Some(otp) = fetcher.fetchotp()? {
    println!("Retrieved OTP: {}", otp);
} else {
    println!("No unread OTP emails found");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="waiting-for-new-otp"><a class="header" href="#waiting-for-new-otp">Waiting for New OTP</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wait up to 60 seconds for a new OTP email, checking every 5 seconds
let timeout_seconds = 60;
let check_interval = 5;

if let Some(otp) = fetcher.wait_for_otp(timeout_seconds, check_interval)? {
    println!("New OTP received: {}", otp);
} else {
    println!("Timeout: No OTP received within {} seconds", timeout_seconds);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="time-based-otp-retrieval"><a class="header" href="#time-based-otp-retrieval">Time-Based OTP Retrieval</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fetch OTP from emails received in the last 3 minutes
let minutes_ago = 3;

if let Some(otp) = fetcher.fetchotp_recent(minutes_ago)? {
    println!("Recent OTP found: {}", otp);
} else {
    println!("No OTP emails from the last {} minutes", minutes_ago);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-client-authentication"><a class="header" href="#integration-with-client-authentication">Integration with Client Authentication</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::AxiomClient;

let mut client = AxiomClient::new().await?;

// Attempt login
let login_result = client.login(&amp;email, &amp;password).await?;

if login_result.requires_otp {
    // Use automatic OTP retrieval
    if let Some(fetcher) = from_env()? {
        if let Some(otp) = fetcher.wait_for_otp(60, 5)? {
            client.verify_otp(&amp;otp).await?;
            println!("Authentication successful with automatic OTP");
        } else {
            return Err("Failed to retrieve OTP automatically".into());
        }
    } else {
        // Fall back to manual OTP entry
        print!("Enter OTP: ");
        // ... manual input logic
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="otp-extraction-methods"><a class="header" href="#otp-extraction-methods">OTP Extraction Methods</a></h2>
<p>The system uses multiple strategies to extract OTP codes from emails:</p>
<h3 id="subject-line-extraction"><a class="header" href="#subject-line-extraction">Subject Line Extraction</a></h3>
<ul>
<li>Primary pattern: <code>"Your Axiom security code is (\d{6})"</code></li>
<li>Extracts 6-digit codes from email subjects</li>
</ul>
<h3 id="body-content-extraction"><a class="header" href="#body-content-extraction">Body Content Extraction</a></h3>
<p>The system tries multiple patterns in order:</p>
<ol>
<li><code>"Your Axiom security code is[:\s]+(\d{6})"</code></li>
<li><code>"Your security code is[:\s]+(\d{6})"</code></li>
<li><code>"security code[:\s]+(\d{6})"</code></li>
<li>HTML tags: <code>&lt;span&gt;</code>, <code>&lt;b&gt;</code>, <code>&lt;strong&gt;</code> containing 6 digits</li>
<li>Fallback: Any 6-digit number in context containing "security code" or "Your Axiom"</li>
</ol>
<h3 id="example-email-formats"><a class="header" href="#example-email-formats">Example Email Formats</a></h3>
<p><strong>Subject Line Format:</strong></p>
<pre><code>Subject: Your Axiom security code is 123456
</code></pre>
<p><strong>Plain Text Body:</strong></p>
<pre><code>Your Axiom security code is: 123456

This code will expire in 10 minutes.
</code></pre>
<p><strong>HTML Body:</strong></p>
<pre><code class="language-html">&lt;div style="background-color: #f5f5f5; padding: 15px;"&gt;
  &lt;span style="font-size: 24px; font-weight: bold;"&gt;123456&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Your Axiom security code&lt;/p&gt;
</code></pre>
<h2 id="troubleshooting-otp-issues"><a class="header" href="#troubleshooting-otp-issues">Troubleshooting OTP Issues</a></h2>
<h3 id="connection-problems"><a class="header" href="#connection-problems">Connection Problems</a></h3>
<p><strong>Issue</strong>: "IMAP connection failed"</p>
<ul>
<li><strong>Cause</strong>: IMAP not enabled or incorrect credentials</li>
<li><strong>Solutions</strong>:
<ul>
<li>Verify 15-minute IMAP activation wait period completed</li>
<li>Check IMAP password vs web login password</li>
<li>Confirm email address spelling in environment variables</li>
<li>Test connection manually using an IMAP client</li>
</ul>
</li>
</ul>
<p><strong>Issue</strong>: "Authentication failed to inbox.lv"</p>
<ul>
<li><strong>Cause</strong>: Wrong IMAP credentials</li>
<li><strong>Solutions</strong>:
<ul>
<li>Verify IMAP password from inbox.lv settings</li>
<li>Check for typos in email address</li>
<li>Try logging into inbox.lv webmail to verify credentials</li>
<li>Regenerate IMAP password if necessary</li>
</ul>
</li>
</ul>
<h3 id="email-delivery-problems"><a class="header" href="#email-delivery-problems">Email Delivery Problems</a></h3>
<p><strong>Issue</strong>: "No OTP emails found"</p>
<ul>
<li><strong>Cause</strong>: Email forwarding not configured or emails not arriving</li>
<li><strong>Solutions</strong>:
<ul>
<li>Verify Axiom Trade sends OTP emails to inbox.lv address</li>
<li>Check spam/junk folder in inbox.lv</li>
<li>Manually trigger OTP and verify email arrives</li>
<li>Confirm email subject format matches expected pattern</li>
</ul>
</li>
</ul>
<p><strong>Issue</strong>: "OTP extraction failed"</p>
<ul>
<li><strong>Cause</strong>: Email format changed or parsing issue</li>
<li><strong>Solutions</strong>:
<ul>
<li>Check recent OTP email for exact subject format</li>
<li>Verify subject contains "Your Axiom security code is"</li>
<li>Review email body format if subject extraction fails</li>
<li>Report format changes to maintain compatibility</li>
</ul>
</li>
</ul>
<h3 id="debug-and-testing"><a class="header" href="#debug-and-testing">Debug and Testing</a></h3>
<p>Enable debug logging for detailed information:</p>
<pre><code class="language-env">RUST_LOG=debug
</code></pre>
<p>Test individual components:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test IMAP connection
let fetcher = OtpFetcher::new(
    "your_email@inbox.lv".to_string(),
    "your_imap_password".to_string()
);

// Test email parsing
let email_body = "Your Axiom security code is: 123456";
let result = fetcher.extract_otp_from_email(email_body)?;
<span class="boring">}</span></code></pre></pre>
<p>Manual verification steps:</p>
<ol>
<li>Send test email to inbox.lv account</li>
<li>Verify email appears in webmail interface</li>
<li>Request OTP manually from Axiom Trade</li>
<li>Check exact subject line format in received email</li>
</ol>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="email-account-security"><a class="header" href="#email-account-security">Email Account Security</a></h3>
<ul>
<li>Use dedicated inbox.lv account only for OTP purposes</li>
<li>Avoid using this email for other services</li>
<li>Consider the email account semi-public</li>
<li>Use strong, unique password for inbox.lv account</li>
</ul>
<h3 id="credential-management-1"><a class="header" href="#credential-management-1">Credential Management</a></h3>
<ul>
<li>Store IMAP credentials securely in environment variables</li>
<li>Never commit <code>.env</code> files to version control</li>
<li>Use proper file permissions on configuration files</li>
<li>Consider using OS keychain for production deployments</li>
</ul>
<h3 id="access-control"><a class="header" href="#access-control">Access Control</a></h3>
<ul>
<li>The inbox.lv account only needs to receive emails</li>
<li>Enable two-factor authentication on Axiom Trade account</li>
<li>Regularly review account access and settings</li>
<li>Monitor for unauthorized access attempts</li>
</ul>
<h3 id="network-security-1"><a class="header" href="#network-security-1">Network Security</a></h3>
<ul>
<li>All IMAP connections use TLS encryption</li>
<li>Verify SSL certificate validation</li>
<li>Use secure networks for production systems</li>
<li>Consider VPN for additional protection</li>
</ul>
<h2 id="alternative-configurations"><a class="header" href="#alternative-configurations">Alternative Configurations</a></h2>
<h3 id="other-email-providers"><a class="header" href="#other-email-providers">Other Email Providers</a></h3>
<p>The OTP fetcher can be adapted for other IMAP-enabled providers:</p>
<p><strong>Gmail</strong> (requires app-specific passwords):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fetcher = OtpFetcher::new(
    "user@gmail.com".to_string(),
    "app_specific_password".to_string()
);
// Note: Different IMAP server settings required
<span class="boring">}</span></code></pre></pre>
<p><strong>Custom Email Servers</strong>:</p>
<ul>
<li>Modify <code>IMAP_DOMAIN</code> and <code>IMAP_PORT</code> constants</li>
<li>Adjust TLS settings as needed</li>
<li>Update authentication method if required</li>
</ul>
<h3 id="manual-fallback"><a class="header" href="#manual-fallback">Manual Fallback</a></h3>
<p>Always provide manual OTP entry as fallback:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_otp_manual() -&gt; Result&lt;String&gt; {
    print!("Enter OTP code: ");
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&amp;mut input)?;
    
    Ok(input.trim().to_string())
}

// Use in authentication flow
let otp = if let Some(fetcher) = from_env()? {
    fetcher.fetchotp()?.unwrap_or_else(|| get_otp_manual())
} else {
    get_otp_manual()?
};
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-and-limitations"><a class="header" href="#performance-and-limitations">Performance and Limitations</a></h2>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li>IMAP connection establishment: ~1-2 seconds</li>
<li>Email search and retrieval: &lt;1 second</li>
<li>OTP extraction: &lt;100 milliseconds</li>
<li>Total process time: 2-4 seconds typically</li>
</ul>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<ul>
<li>IMAP servers may limit connection frequency</li>
<li>Implement backoff strategies for production use</li>
<li>Consider connection pooling for high-frequency operations</li>
</ul>
<h3 id="email-limitations"><a class="header" href="#email-limitations">Email Limitations</a></h3>
<ul>
<li>Only processes UNREAD emails to avoid duplicates</li>
<li>Requires emails to match specific subject patterns</li>
<li>Dependent on email delivery timing and reliability</li>
<li>Limited to 6-digit numeric OTP codes</li>
</ul>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ul>
<li>Use timeouts to prevent hanging operations</li>
<li>Implement retry logic with exponential backoff</li>
<li>Log operations for debugging and monitoring</li>
<li>Handle network interruptions gracefully</li>
<li>Cache credentials securely to avoid repeated lookups</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="login-and-sessions"><a class="header" href="#login-and-sessions">Login and Sessions</a></h1>
<p>This guide covers the complete authentication and session management system in axiomtrade-rs, including basic login, OTP verification, cookie-based authentication, and comprehensive error handling.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The authentication system in axiomtrade-rs provides a robust, secure login mechanism with automatic OTP fetching, cookie-based session persistence, and comprehensive token management. The system is designed to handle the two-step authentication process required by Axiom Trade's API.</p>
<h2 id="basic-login-flow"><a class="header" href="#basic-login-flow">Basic Login Flow</a></h2>
<p>The standard login process involves two steps:</p>
<ol>
<li><strong>Password Verification</strong>: Submit email and hashed password to get an OTP JWT token</li>
<li><strong>OTP Verification</strong>: Submit the OTP code to complete authentication and receive access tokens</li>
</ol>
<h3 id="simple-login-example"><a class="header" href="#simple-login-example">Simple Login Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;
use std::env;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load environment variables
    dotenvy::dotenv().ok();
    
    let email = env::var("AXIOM_EMAIL")?;
    let password = env::var("AXIOM_PASSWORD")?;

    // Create auth client
    let mut auth_client = AuthClient::new()?;
    
    // Perform login (automatic OTP if configured)
    let tokens = auth_client.login(&amp;email, &amp;password, None).await?;
    
    println!("Login successful!");
    println!("Access token: {}...", &amp;tokens.access_token[..20]);
    
    Ok(())
}</code></pre></pre>
<h3 id="manual-otp-entry"><a class="header" href="#manual-otp-entry">Manual OTP Entry</a></h3>
<p>If automatic OTP fetching is not configured, you can provide the OTP manually:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::io::{self, Write};

fn get_otp_from_user() -&gt; Result&lt;String, io::Error&gt; {
    print!("Enter OTP code: ");
    io::stdout().flush()?;
    
    let mut otp = String::new();
    io::stdin().read_line(&amp;mut otp)?;
    
    Ok(otp.trim().to_string())
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Get OTP from user if auto-fetch not configured
    let otp_code = if env::var("INBOX_LV_EMAIL").is_ok() {
        None  // Auto-fetch enabled
    } else {
        Some(get_otp_from_user()?)
    };
    
    let tokens = auth_client.login(&amp;email, &amp;password, otp_code).await?;
    
    Ok(())
}</code></pre></pre>
<h2 id="login-with-otp"><a class="header" href="#login-with-otp">Login with OTP</a></h2>
<p>The system supports automatic OTP fetching from inbox.lv email accounts when properly configured.</p>
<h3 id="automatic-otp-configuration"><a class="header" href="#automatic-otp-configuration">Automatic OTP Configuration</a></h3>
<p>Set up environment variables for automatic OTP fetching:</p>
<pre><code class="language-env"># Axiom Trade credentials
AXIOM_EMAIL=your.email@example.com
AXIOM_PASSWORD=your_password

# Inbox.lv credentials for OTP auto-fetching
INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_imap_password
</code></pre>
<h3 id="otp-verification-example"><a class="header" href="#otp-verification-example">OTP Verification Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Check if auto-OTP is configured
    let auto_otp_configured = env::var("INBOX_LV_EMAIL").is_ok() 
        &amp;&amp; env::var("INBOX_LV_PASSWORD").is_ok();
    
    if auto_otp_configured {
        println!("Automatic OTP retrieval is configured");
        println!("The system will automatically fetch OTP from inbox.lv");
    } else {
        println!("Manual OTP entry will be required");
    }
    
    // Login with automatic OTP handling
    let tokens = auth_client.login(&amp;email, &amp;password, None).await?;
    
    println!("Login successful with OTP verification!");
    
    Ok(())
}</code></pre></pre>
<h3 id="full-login-result"><a class="header" href="#full-login-result">Full Login Result</a></h3>
<p>Use <code>login_full()</code> to get complete authentication information including Turnkey credentials:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let login_result = auth_client.login_full(&amp;email, &amp;password, None).await?;

// Access tokens
let tokens = login_result.tokens;

// Turnkey credentials for wallet operations
if let Some(turnkey) = login_result.turnkey_credentials {
    println!("Turnkey Organization ID: {}", turnkey.organization_id);
    println!("Turnkey User ID: {}", turnkey.user_id);
    println!("Client Secret: {}...", &amp;turnkey.client_secret[..8]);
}

// User information
if let Some(user) = login_result.user_info {
    println!("User ID: {:?}", user.id);
    println!("Email: {:?}", user.email);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cookie-based-authentication"><a class="header" href="#cookie-based-authentication">Cookie-Based Authentication</a></h2>
<p>The authentication system automatically manages HTTP cookies for session persistence, which is particularly useful for web-based integrations.</p>
<h3 id="cookie-management"><a class="header" href="#cookie-management">Cookie Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::{AuthClient, AuthCookies};
use std::collections::HashMap;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Login and get tokens
    let tokens = auth_client.login(&amp;email, &amp;password, None).await?;
    
    // Cookies are automatically managed by the HTTP client
    // The auth client maintains cookie store with:
    // - auth-access-token (HttpOnly)
    // - auth-refresh-token (HttpOnly) 
    // - g_state (Google OAuth state)
    // - Additional session cookies
    
    println!("Authentication cookies are automatically managed");
    
    Ok(())
}</code></pre></pre>
<h3 id="cookie-security-features"><a class="header" href="#cookie-security-features">Cookie Security Features</a></h3>
<p>The authentication system implements several security best practices for cookies:</p>
<ul>
<li><strong>HttpOnly Flag</strong>: Prevents JavaScript access to authentication cookies</li>
<li><strong>Secure Flag</strong>: Ensures cookies are only transmitted over HTTPS</li>
<li><strong>SameSite Protection</strong>: Provides CSRF protection</li>
<li><strong>Path Restrictions</strong>: Limits cookie scope to appropriate paths</li>
<li><strong>Automatic Expiry</strong>: Manages cookie lifecycle and cleanup</li>
</ul>
<h3 id="making-authenticated-requests"><a class="header" href="#making-authenticated-requests">Making Authenticated Requests</a></h3>
<p>The <code>AuthClient</code> provides methods for making authenticated API requests with automatic cookie handling:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Method;
use serde_json::json;

// Make authenticated request with automatic cookie handling
let response = auth_client.make_authenticated_request(
    Method::GET,
    "https://api.axiom.trade/portfolio/balance",
    None
).await?;

// Make authenticated POST request with JSON body
let body = json!({
    "token_address": "So11111111111111111111111111111111111111112",
    "amount": "1000000"
});

let response = auth_client.make_authenticated_request(
    Method::POST,
    "https://api.axiom.trade/trade/buy",
    Some(body)
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="session-management"><a class="header" href="#session-management">Session Management</a></h2>
<p>The system provides comprehensive session management with automatic token refresh and persistence.</p>
<h3 id="token-persistence"><a class="header" href="#token-persistence">Token Persistence</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::{TokenManager, AuthClient};
use std::path::PathBuf;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create token manager with persistent storage
    let tokens_file = PathBuf::from(".axiom_tokens.json");
    let token_manager = TokenManager::new(Some(tokens_file));
    
    // Check for existing session
    if let Some(existing_tokens) = token_manager.get_tokens().await {
        println!("Found existing session");
        
        if !existing_tokens.is_expired() {
            println!("Session is still valid");
            // Use existing tokens
        } else {
            println!("Session expired, need to refresh");
            // Refresh or re-login
        }
    } else {
        println!("No existing session, performing new login");
        
        let mut auth_client = AuthClient::new()?;
        let tokens = auth_client.login(&amp;email, &amp;password, None).await?;
        
        // Save tokens for future use
        token_manager.set_tokens(tokens).await?;
    }
    
    Ok(())
}</code></pre></pre>
<h3 id="automatic-token-refresh"><a class="header" href="#automatic-token-refresh">Automatic Token Refresh</a></h3>
<p>The authentication client automatically handles token refresh when making API requests:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Tokens are automatically refreshed when needed
let mut auth_client = AuthClient::new()?;

// This will automatically refresh tokens if they're expired
let valid_tokens = auth_client.ensure_valid_authentication().await?;

println!("Guaranteed valid tokens: {}...", &amp;valid_tokens.access_token[..20]);
<span class="boring">}</span></code></pre></pre>
<h3 id="multiple-session-management"><a class="header" href="#multiple-session-management">Multiple Session Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::SessionManager;

// Manage multiple sessions for different accounts
let session_manager = SessionManager::new(
    Some(PathBuf::from(".axiom_sessions.json")), 
    true  // Enable encryption
);

// Example session files for different purposes
let session_files = vec![
    ".axiom_session_trading.json",
    ".axiom_session_portfolio.json",
    ".axiom_session_notifications.json",
];

for session_file in session_files {
    let path = PathBuf::from(session_file);
    if path.exists() {
        println!("Found session: {}", session_file);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The authentication system provides comprehensive error handling for various failure scenarios.</p>
<h3 id="authentication-error-types"><a class="header" href="#authentication-error-types">Authentication Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::error::AuthError;

match auth_client.login(&amp;email, &amp;password, None).await {
    Ok(tokens) =&gt; {
        println!("Login successful");
    }
    Err(AuthError::InvalidCredentials) =&gt; {
        println!("Invalid email or password");
    }
    Err(AuthError::InvalidOtp) =&gt; {
        println!("Invalid OTP code");
    }
    Err(AuthError::OtpRequired) =&gt; {
        println!("OTP required but not provided");
    }
    Err(AuthError::TokenExpired) =&gt; {
        println!("Authentication token has expired");
    }
    Err(AuthError::TokenNotFound) =&gt; {
        println!("No authentication token found");
    }
    Err(AuthError::NetworkError(e)) =&gt; {
        println!("Network error: {}", e);
    }
    Err(AuthError::EmailError(msg)) =&gt; {
        println!("Email fetcher error: {}", msg);
    }
    Err(e) =&gt; {
        println!("Other authentication error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="comprehensive-error-handling-example"><a class="header" href="#comprehensive-error-handling-example">Comprehensive Error Handling Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::{AuthClient, AuthError};

async fn robust_login(email: &amp;str, password: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()
        .map_err(|e| format!("Failed to create auth client: {}", e))?;
    
    let max_retries = 3;
    let mut attempts = 0;
    
    loop {
        attempts += 1;
        
        match auth_client.login(email, password, None).await {
            Ok(tokens) =&gt; {
                println!("Login successful on attempt {}", attempts);
                return Ok(());
            }
            Err(AuthError::NetworkError(e)) if attempts &lt; max_retries =&gt; {
                println!("Network error on attempt {}, retrying: {}", attempts, e);
                tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
                continue;
            }
            Err(AuthError::InvalidCredentials) =&gt; {
                return Err("Invalid credentials - check email and password".into());
            }
            Err(AuthError::OtpRequired) =&gt; {
                return Err("OTP required but auto-fetching not configured".into());
            }
            Err(AuthError::EmailError(msg)) =&gt; {
                return Err(format!("Email OTP fetching failed: {}", msg).into());
            }
            Err(e) =&gt; {
                return Err(format!("Login failed: {}", e).into());
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="recovery-strategies"><a class="header" href="#recovery-strategies">Recovery Strategies</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_authentication_failure(
    auth_client: &amp;mut AuthClient,
    error: AuthError
) -&gt; Result&lt;(), AuthError&gt; {
    match error {
        AuthError::TokenExpired =&gt; {
            // Try to refresh tokens
            match auth_client.refresh_tokens().await {
                Ok(_) =&gt; {
                    println!("Tokens refreshed successfully");
                    Ok(())
                }
                Err(_) =&gt; {
                    println!("Token refresh failed, need to re-login");
                    Err(AuthError::NotAuthenticated)
                }
            }
        }
        AuthError::NetworkError(_) =&gt; {
            // Implement exponential backoff
            tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            Err(error)
        }
        AuthError::OtpRequired =&gt; {
            println!("Configure automatic OTP fetching:");
            println!("1. Create inbox.lv account");
            println!("2. Set INBOX_LV_EMAIL and INBOX_LV_PASSWORD");
            println!("3. Forward Axiom OTP emails to inbox.lv");
            Err(error)
        }
        _ =&gt; Err(error)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-production-login"><a class="header" href="#complete-example-production-login">Complete Example: Production Login</a></h2>
<p>Here's a complete example demonstrating production-ready authentication with all features:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::{AuthClient, TokenManager, AuthError};
use axiomtrade_rs::client::EnhancedClient;
use std::env;
use std::path::PathBuf;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load environment variables
    dotenvy::dotenv().ok();
    
    let email = env::var("AXIOM_EMAIL")?;
    let password = env::var("AXIOM_PASSWORD")?;
    
    // Set up persistent token storage
    let tokens_file = PathBuf::from(".axiom_session.json");
    let token_manager = TokenManager::new(Some(tokens_file));
    
    // Check for existing valid session
    if let Some(tokens) = token_manager.get_tokens().await {
        if !tokens.is_expired() {
            println!("Using existing valid session");
            
            // Test the session with an API call
            let client = EnhancedClient::new()?;
            match client.get_portfolio().await {
                Ok(_) =&gt; {
                    println!("Session validated successfully");
                    return Ok(());
                }
                Err(_) =&gt; {
                    println!("Session invalid, performing fresh login");
                }
            }
        }
    }
    
    // Perform fresh login
    println!("Performing authentication...");
    let mut auth_client = AuthClient::new()?;
    
    // Check OTP configuration
    let auto_otp = env::var("INBOX_LV_EMAIL").is_ok() 
        &amp;&amp; env::var("INBOX_LV_PASSWORD").is_ok();
    
    if auto_otp {
        println!("Automatic OTP fetching enabled");
    } else {
        println!("Manual OTP entry may be required");
    }
    
    // Login with comprehensive error handling
    let login_result = match auth_client.login_full(&amp;email, &amp;password, None).await {
        Ok(result) =&gt; result,
        Err(AuthError::InvalidCredentials) =&gt; {
            return Err("Invalid credentials - check AXIOM_EMAIL and AXIOM_PASSWORD".into());
        }
        Err(AuthError::OtpRequired) if !auto_otp =&gt; {
            return Err("OTP required but auto-fetching not configured. Set up inbox.lv integration.".into());
        }
        Err(AuthError::EmailError(msg)) =&gt; {
            return Err(format!("OTP email fetching failed: {}", msg).into());
        }
        Err(e) =&gt; {
            return Err(format!("Authentication failed: {}", e).into());
        }
    };
    
    println!("Login successful!");
    
    // Save tokens for future sessions
    token_manager.set_tokens(login_result.tokens.clone()).await?;
    println!("Session saved for future use");
    
    // Display authentication details
    if let Some(turnkey) = &amp;login_result.turnkey_credentials {
        println!("Turnkey wallet access enabled:");
        println!("  Organization: {}", turnkey.organization_id);
        println!("  User: {}", turnkey.user_id);
    }
    
    if let Some(user) = &amp;login_result.user_info {
        if let Some(email) = &amp;user.email {
            println!("Authenticated as: {}", email);
        }
    }
    
    // Test authenticated API access
    let client = EnhancedClient::new()?;
    match client.get_portfolio().await {
        Ok(portfolio) =&gt; {
            println!("Portfolio access confirmed");
            println!("Ready for trading operations");
        }
        Err(e) =&gt; {
            println!("Warning: Portfolio access failed: {}", e);
        }
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<ul>
<li>Always use environment variables for credentials</li>
<li>Enable automatic OTP fetching to reduce manual intervention</li>
<li>Store tokens securely with appropriate file permissions</li>
<li>Implement proper session cleanup on logout</li>
<li>Use HTTPS for all API communications</li>
</ul>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ul>
<li>Reuse existing valid sessions when possible</li>
<li>Implement automatic token refresh to avoid re-authentication</li>
<li>Cache authentication state appropriately</li>
<li>Handle network failures with exponential backoff</li>
</ul>
<h3 id="reliability"><a class="header" href="#reliability">Reliability</a></h3>
<ul>
<li>Implement comprehensive error handling for all scenarios</li>
<li>Use multiple API endpoints for redundancy</li>
<li>Implement proper retry logic for transient failures</li>
<li>Monitor authentication success rates and failures</li>
</ul>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<ul>
<li>Use separate credentials for development and production</li>
<li>Log authentication events for debugging</li>
<li>Test authentication flows thoroughly</li>
<li>Document credential setup procedures for team members</li>
</ul>
<p>This comprehensive authentication system provides a robust foundation for all Axiom Trade API operations, with automatic session management, secure credential handling, and production-ready error handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-management"><a class="header" href="#token-management">Token Management</a></h1>
<p>The Axiom Trade Rust client provides a comprehensive token management system that handles authentication tokens, automatic refresh, persistent storage, and validation. This system ensures secure and reliable API access while maintaining session integrity.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The token management system consists of two main components:</p>
<ul>
<li><strong>AuthTokens</strong>: Core JWT token structure containing access and refresh tokens</li>
<li><strong>TokenManager</strong>: Thread-safe manager for storing, validating, and persisting tokens</li>
</ul>
<h2 id="token-types"><a class="header" href="#token-types">Token Types</a></h2>
<h3 id="access-tokens"><a class="header" href="#access-tokens">Access Tokens</a></h3>
<p>Access tokens are JWT tokens used to authenticate API requests. They have a limited lifespan and are included in the <code>Authorization</code> header of HTTP requests.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access token is automatically included in API requests
let balance = client.get_portfolio().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="refresh-tokens"><a class="header" href="#refresh-tokens">Refresh Tokens</a></h3>
<p>Refresh tokens are long-lived tokens used to obtain new access tokens when they expire. They provide a secure way to maintain authentication without requiring the user to log in repeatedly.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Refresh happens automatically when needed
let new_tokens = auth_client.refresh_tokens().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="token-structure"><a class="header" href="#token-structure">Token Structure</a></h2>
<p>The <code>AuthTokens</code> struct contains all necessary token information:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthTokens {
    pub access_token: String,      // JWT access token
    pub refresh_token: String,     // JWT refresh token  
    pub expires_at: Option&lt;DateTime&lt;Utc&gt;&gt;, // Token expiration time
}
<span class="boring">}</span></code></pre></pre>
<h2 id="tokenmanager"><a class="header" href="#tokenmanager">TokenManager</a></h2>
<p>The <code>TokenManager</code> provides thread-safe token operations with optional persistent storage.</p>
<h3 id="creating-a-tokenmanager"><a class="header" href="#creating-a-tokenmanager">Creating a TokenManager</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::TokenManager;
use std::path::PathBuf;

// In-memory token storage
let token_manager = TokenManager::new(None);

// Persistent token storage
let storage_path = PathBuf::from("tokens.json");
let token_manager = TokenManager::new(Some(storage_path));

// Create from environment variables
let token_manager = TokenManager::from_env()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-variable-setup"><a class="header" href="#environment-variable-setup">Environment Variable Setup</a></h3>
<p>The TokenManager can automatically load tokens from environment variables:</p>
<pre><code class="language-bash">export AXIOM_ACCESS_TOKEN="your_access_token_here"
export AXIOM_REFRESH_TOKEN="your_refresh_token_here"
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatically loads tokens from environment
if let Some(manager) = TokenManager::from_env()? {
    println!("Tokens loaded from environment");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h2>
<h3 id="setting-tokens"><a class="header" href="#setting-tokens">Setting Tokens</a></h3>
<p>Store new authentication tokens in the manager:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::types::AuthTokens;
use chrono::{Utc, Duration};

let tokens = AuthTokens {
    access_token: "eyJhbGciOiJIUzI1NiIs...".to_string(),
    refresh_token: "refresh_token_value".to_string(),
    expires_at: Some(Utc::now() + Duration::hours(1)),
};

token_manager.set_tokens(tokens).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="retrieving-tokens"><a class="header" href="#retrieving-tokens">Retrieving Tokens</a></h3>
<p>Get stored tokens for API requests:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get complete token structure
if let Some(tokens) = token_manager.get_tokens().await {
    println!("Access token: {}", tokens.access_token);
}

// Get individual tokens
let access_token = token_manager.get_access_token().await?;
let refresh_token = token_manager.get_refresh_token().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="token-validation"><a class="header" href="#token-validation">Token Validation</a></h3>
<p>Check token status before making API calls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if tokens are expired (with 5-minute buffer)
if token_manager.is_expired().await {
    println!("Tokens have expired");
}

// Check if tokens need refresh (with 15-minute buffer)
if token_manager.needs_refresh().await {
    println!("Tokens should be refreshed soon");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="clearing-tokens"><a class="header" href="#clearing-tokens">Clearing Tokens</a></h3>
<p>Remove stored tokens and delete persistent storage:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clear tokens from memory and delete storage file
token_manager.clear().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="token-storage-and-persistence"><a class="header" href="#token-storage-and-persistence">Token Storage and Persistence</a></h2>
<h3 id="file-based-storage"><a class="header" href="#file-based-storage">File-Based Storage</a></h3>
<p>When a storage path is provided, tokens are automatically saved to disk as JSON:</p>
<pre><code class="language-json">{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "refresh_token_value",
  "expires_at": "2024-01-15T10:30:00Z"
}
</code></pre>
<h3 id="storage-benefits"><a class="header" href="#storage-benefits">Storage Benefits</a></h3>
<ul>
<li><strong>Persistence</strong>: Tokens survive application restarts</li>
<li><strong>Security</strong>: Only stored locally on the filesystem</li>
<li><strong>Convenience</strong>: Automatic loading on TokenManager creation</li>
</ul>
<h3 id="storage-location"><a class="header" href="#storage-location">Storage Location</a></h3>
<p>Choose an appropriate storage location based on your application:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User-specific storage
let storage_path = dirs::config_dir()
    .unwrap()
    .join("axiomtrade")
    .join("tokens.json");

// Application-specific storage  
let storage_path = PathBuf::from("./config/tokens.json");

// Temporary storage
let storage_path = std::env::temp_dir().join("axiom_tokens.json");
<span class="boring">}</span></code></pre></pre>
<h2 id="automatic-token-refresh-1"><a class="header" href="#automatic-token-refresh-1">Automatic Token Refresh</a></h2>
<p>The token management system provides intelligent refresh logic:</p>
<h3 id="refresh-timing"><a class="header" href="#refresh-timing">Refresh Timing</a></h3>
<ul>
<li><strong>Expiration Buffer</strong>: Tokens are considered expired 5 minutes before actual expiration</li>
<li><strong>Refresh Buffer</strong>: Tokens should be refreshed 15 minutes before expiration</li>
<li><strong>Automatic Refresh</strong>: The client automatically refreshes tokens when needed</li>
</ul>
<h3 id="refresh-implementation"><a class="header" href="#refresh-implementation">Refresh Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual refresh check and execution
if token_manager.needs_refresh().await {
    // Refresh logic would be implemented in the auth client
    let new_tokens = auth_client.refresh_tokens().await?;
    token_manager.set_tokens(new_tokens).await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="token-protection"><a class="header" href="#token-protection">Token Protection</a></h3>
<ul>
<li><strong>Local Storage Only</strong>: Tokens are never transmitted except for authentication</li>
<li><strong>File Permissions</strong>: Ensure token files have appropriate read/write permissions</li>
<li><strong>Environment Variables</strong>: Use secure environment variable management</li>
</ul>
<h3 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h3>
<ol>
<li><strong>Regular Rotation</strong>: Implement token refresh before expiration</li>
<li><strong>Secure Storage</strong>: Use appropriate file permissions for token storage</li>
<li><strong>Error Handling</strong>: Always handle token-related errors gracefully</li>
<li><strong>Cleanup</strong>: Clear tokens on logout or application termination</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Secure token file permissions (Unix-like systems)
#[cfg(unix)]
fn set_token_file_permissions(path: &amp;Path) -&gt; Result&lt;(), std::io::Error&gt; {
    use std::fs;
    use std::os::unix::fs::PermissionsExt;
    
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o600); // Read/write for owner only
    fs::set_permissions(path, perms)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The token management system uses structured error handling:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::error::AuthError;

match token_manager.get_access_token().await {
    Ok(token) =&gt; {
        // Use token for API request
    }
    Err(AuthError::TokenNotFound) =&gt; {
        // Handle missing tokens - may need to log in
    }
    Err(AuthError::TokenExpired) =&gt; {
        // Handle expired tokens - refresh or re-authenticate
    }
    Err(e) =&gt; {
        // Handle other errors
        eprintln!("Token error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>The TokenManager is designed for concurrent access:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

// Share TokenManager across threads
let manager = Arc::new(TokenManager::new(None));
let manager_clone = Arc::clone(&amp;manager);

tokio::spawn(async move {
    // Safe concurrent access
    let tokens = manager_clone.get_tokens().await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-example"><a class="header" href="#integration-example">Integration Example</a></h2>
<p>Complete example showing token management integration:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::{TokenManager, AuthClient};
use std::path::PathBuf;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create token manager with persistent storage
    let storage_path = PathBuf::from("tokens.json");
    let token_manager = TokenManager::new(Some(storage_path));
    
    // Check if we have valid tokens
    if token_manager.is_expired().await {
        // Need to authenticate
        let auth_client = AuthClient::new();
        let login_result = auth_client.login("user@example.com", "password").await?;
        token_manager.set_tokens(login_result.tokens).await?;
    } else if token_manager.needs_refresh().await {
        // Refresh tokens proactively
        let auth_client = AuthClient::new();
        let new_tokens = auth_client.refresh_tokens().await?;
        token_manager.set_tokens(new_tokens).await?;
    }
    
    // Use tokens for API requests
    let access_token = token_manager.get_access_token().await?;
    println!("Ready to make authenticated requests");
    
    Ok(())
}</code></pre></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="token-lifecycle-management"><a class="header" href="#token-lifecycle-management">Token Lifecycle Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Complete token lifecycle management
pub struct TokenLifecycleManager {
    token_manager: TokenManager,
    auth_client: AuthClient,
}

impl TokenLifecycleManager {
    pub async fn ensure_valid_tokens(&amp;self) -&gt; Result&lt;(), AuthError&gt; {
        if self.token_manager.is_expired().await {
            // Re-authenticate required
            return Err(AuthError::TokenExpired);
        }
        
        if self.token_manager.needs_refresh().await {
            // Proactive refresh
            let new_tokens = self.auth_client.refresh_tokens().await?;
            self.token_manager.set_tokens(new_tokens).await?;
        }
        
        Ok(())
    }
    
    pub async fn get_valid_access_token(&amp;self) -&gt; Result&lt;String, AuthError&gt; {
        self.ensure_valid_tokens().await?;
        self.token_manager.get_access_token().await
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-and-backup"><a class="header" href="#migration-and-backup">Migration and Backup</a></h2>
<h3 id="token-migration"><a class="header" href="#token-migration">Token Migration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Migrate tokens between storage locations
async fn migrate_tokens(
    old_path: &amp;Path, 
    new_path: &amp;Path
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let old_manager = TokenManager::new(Some(old_path.to_path_buf()));
    
    if let Some(tokens) = old_manager.get_tokens().await {
        let new_manager = TokenManager::new(Some(new_path.to_path_buf()));
        new_manager.set_tokens(tokens).await?;
        old_manager.clear().await?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="token-backup"><a class="header" href="#token-backup">Token Backup</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create token backup
async fn backup_tokens(
    manager: &amp;TokenManager,
    backup_path: &amp;Path
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    if let Some(tokens) = manager.get_tokens().await {
        let backup_manager = TokenManager::new(Some(backup_path.to_path_buf()));
        backup_manager.set_tokens(tokens).await?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>The token management system provides a robust foundation for maintaining authenticated sessions with the Axiom Trade API while ensuring security, reliability, and ease of use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-management-1"><a class="header" href="#session-management-1">Session Management</a></h1>
<p>This document covers the comprehensive session management system in axiomtrade-rs, which handles authentication state, persistence, and multi-session support.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The <code>SessionManager</code> provides a centralized system for managing authentication sessions that include:</p>
<ul>
<li>JWT tokens (access and refresh)</li>
<li>HTTP cookies for browser-like authentication</li>
<li>Turnkey wallet integration sessions</li>
<li>Session metadata and tracking</li>
<li>Persistent storage capabilities</li>
</ul>
<h2 id="session-lifecycle"><a class="header" href="#session-lifecycle">Session Lifecycle</a></h2>
<h3 id="1-session-creation"><a class="header" href="#1-session-creation">1. Session Creation</a></h3>
<p>Sessions are created after successful authentication through multiple pathways:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::{SessionManager, AuthTokens, UserInfo};
use std::path::PathBuf;

// Create session manager with persistent storage
let storage_path = Some(PathBuf::from(".axiom_session.json"));
let session_manager = SessionManager::new(storage_path, true);

// Method 1: Basic session creation
let tokens = AuthTokens {
    access_token: "jwt_access_token".to_string(),
    refresh_token: "jwt_refresh_token".to_string(),
    expires_at: Some(chrono::Utc::now() + chrono::Duration::hours(1)),
};

session_manager.create_session(tokens, user_info, cookies).await?;

// Method 2: Session from complete login result
let login_result = auth_client.login_with_otp(&amp;credentials, &amp;otp_code).await?;
session_manager.create_session_from_login_result(login_result, cookies).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-session-validation"><a class="header" href="#2-session-validation">2. Session Validation</a></h3>
<p>The session manager provides multiple validation levels:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if session exists and is valid
if session_manager.is_session_valid().await {
    println!("Session is active and valid");
}

// Check if session needs token refresh
if session_manager.needs_refresh().await {
    println!("Session needs token refresh");
    // Trigger token refresh process
}

// Get detailed session summary
let summary = session_manager.get_session_summary().await;
println!("Session status: {}", summary);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-session-updates"><a class="header" href="#3-session-updates">3. Session Updates</a></h3>
<p>Sessions are automatically updated during API operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update tokens after refresh
let new_tokens = auth_client.refresh_tokens().await?;
session_manager.update_tokens(new_tokens).await?;

// Update cookies from API responses
let new_cookies = AuthCookies::parse_from_headers(&amp;response.headers());
session_manager.update_cookies(new_cookies).await?;

// Track API calls
session_manager.mark_api_call(Some("api.axiom.trade")).await;
<span class="boring">}</span></code></pre></pre>
<h3 id="4-session-termination"><a class="header" href="#4-session-termination">4. Session Termination</a></h3>
<p>Sessions can be cleared manually or automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual session cleanup
session_manager.clear_session().await;

// Automatic cleanup on token expiration
// Sessions become invalid when tokens expire beyond refresh window
<span class="boring">}</span></code></pre></pre>
<h2 id="session-persistence"><a class="header" href="#session-persistence">Session Persistence</a></h2>
<h3 id="automatic-persistence"><a class="header" href="#automatic-persistence">Automatic Persistence</a></h3>
<p>When <code>auto_save</code> is enabled, sessions are automatically saved after modifications:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable auto-save during manager creation
let session_manager = SessionManager::new(
    Some(PathBuf::from(".axiom_session.json")),
    true  // auto_save enabled
);

// All session updates are automatically persisted
session_manager.update_tokens(new_tokens).await?;  // Auto-saved
session_manager.update_cookies(new_cookies).await?;  // Auto-saved
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-persistence"><a class="header" href="#manual-persistence">Manual Persistence</a></h3>
<p>For fine-grained control over when sessions are saved:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Disable auto-save for manual control
let session_manager = SessionManager::new(storage_path, false);

// Make multiple changes
session_manager.update_tokens(new_tokens).await?;
session_manager.update_cookies(new_cookies).await?;

// Save manually when ready
session_manager.save_session().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="session-loading"><a class="header" href="#session-loading">Session Loading</a></h3>
<p>Sessions are automatically loaded from storage on manager creation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sessions are loaded automatically if storage file exists
let session_manager = SessionManager::new(
    Some(PathBuf::from(".axiom_session.json")),
    true
);

// Manual loading (if needed)
session_manager.load_session().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-session-support"><a class="header" href="#multi-session-support">Multi-Session Support</a></h2>
<h3 id="session-isolation"><a class="header" href="#session-isolation">Session Isolation</a></h3>
<p>Each <code>SessionManager</code> instance manages one authentication session:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Multiple isolated sessions
let trading_session = SessionManager::new(
    Some(PathBuf::from(".axiom_trading_session.json")),
    true
);

let monitoring_session = SessionManager::new(
    Some(PathBuf::from(".axiom_monitoring_session.json")),
    true
);

// Each session maintains independent state
trading_session.create_session(trading_tokens, None, None).await?;
monitoring_session.create_session(monitoring_tokens, None, None).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="session-switching"><a class="header" href="#session-switching">Session Switching</a></h3>
<p>For applications needing multiple concurrent sessions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

struct MultiSessionManager {
    sessions: HashMap&lt;String, SessionManager&gt;,
    active_session: Option&lt;String&gt;,
}

impl MultiSessionManager {
    pub async fn switch_session(&amp;mut self, session_id: &amp;str) -&gt; Result&lt;(), AuthError&gt; {
        if self.sessions.contains_key(session_id) {
            self.active_session = Some(session_id.to_string());
            Ok(())
        } else {
            Err(AuthError::NotAuthenticated)
        }
    }
    
    pub async fn get_active_session(&amp;self) -&gt; Option&lt;&amp;SessionManager&gt; {
        self.active_session
            .as_ref()
            .and_then(|id| self.sessions.get(id))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="session-validation"><a class="header" href="#session-validation">Session Validation</a></h2>
<h3 id="token-validation-1"><a class="header" href="#token-validation-1">Token Validation</a></h3>
<p>The session manager implements intelligent token validation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AuthTokens {
    // Checks if token is expired with 5-minute buffer
    pub fn is_expired(&amp;self) -&gt; bool {
        match self.expires_at {
            Some(expires_at) =&gt; {
                let buffer = chrono::Duration::minutes(5);
                chrono::Utc::now() &gt;= (expires_at - buffer)
            }
            None =&gt; false,
        }
    }
    
    // Checks if token needs refresh with 15-minute buffer
    pub fn needs_refresh(&amp;self) -&gt; bool {
        match self.expires_at {
            Some(expires_at) =&gt; {
                let buffer = chrono::Duration::minutes(15);
                chrono::Utc::now() &gt;= (expires_at - buffer)
            }
            None =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cookie-validation"><a class="header" href="#cookie-validation">Cookie Validation</a></h3>
<p>HTTP cookies are validated for completeness:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AuthSession {
    pub fn has_valid_cookies(&amp;self) -&gt; bool {
        self.cookies.auth_access_token.is_some() 
            &amp;&amp; self.cookies.auth_refresh_token.is_some()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="turnkey-session-validation"><a class="header" href="#turnkey-session-validation">Turnkey Session Validation</a></h3>
<p>Turnkey integration sessions have separate validation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AuthSession {
    pub fn turnkey_needs_refresh(&amp;self) -&gt; bool {
        if let Some(turnkey) = &amp;self.turnkey_session {
            if let Some(expires_at) = turnkey.expires_at {
                let buffer = chrono::Duration::hours(1);
                chrono::Utc::now() &gt;= (expires_at - buffer)
            } else {
                false
            }
        } else {
            false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="logout-and-cleanup"><a class="header" href="#logout-and-cleanup">Logout and Cleanup</a></h2>
<h3 id="immediate-cleanup"><a class="header" href="#immediate-cleanup">Immediate Cleanup</a></h3>
<p>Clear session data immediately:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clear session from memory and optionally delete storage file
session_manager.clear_session().await;

// Session is now invalid
assert!(!session_manager.is_session_valid().await);
<span class="boring">}</span></code></pre></pre>
<h3 id="secure-cleanup"><a class="header" href="#secure-cleanup">Secure Cleanup</a></h3>
<p>For security-sensitive applications:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Revoke tokens on server (if supported)
if let Some(refresh_token) = session_manager.get_refresh_token().await {
    auth_client.revoke_token(&amp;refresh_token).await?;
}

// 2. Clear local session
session_manager.clear_session().await;

// 3. Clear any cached credentials
// (Application-specific cleanup)
<span class="boring">}</span></code></pre></pre>
<h3 id="automatic-cleanup"><a class="header" href="#automatic-cleanup">Automatic Cleanup</a></h3>
<p>Sessions automatically become invalid when tokens expire:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sessions with expired tokens return false
let is_valid = session_manager.is_session_valid().await;

// Cleanup expired sessions periodically
async fn cleanup_expired_sessions(managers: &amp;[SessionManager]) {
    for manager in managers {
        if !manager.is_session_valid().await {
            manager.clear_session().await;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="session-metadata"><a class="header" href="#session-metadata">Session Metadata</a></h2>
<h3 id="tracking-information"><a class="header" href="#tracking-information">Tracking Information</a></h3>
<p>Sessions include comprehensive metadata:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionMetadata {
    pub created_at: chrono::DateTime&lt;chrono::Utc&gt;,
    pub last_refreshed_at: Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;,
    pub last_api_call_at: Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;,
    pub current_api_server: Option&lt;String&gt;,
    pub user_agent: String,
    pub ip_address: Option&lt;String&gt;,
    pub client_fingerprint: Option&lt;String&gt;,
}

// Usage examples
let session = session_manager.get_session().await.unwrap();
let age_minutes = session.session_metadata.session_age_minutes();
let last_api_call = session.session_metadata.minutes_since_last_api_call();
<span class="boring">}</span></code></pre></pre>
<h3 id="usage-analytics"><a class="header" href="#usage-analytics">Usage Analytics</a></h3>
<p>Track session usage patterns:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mark API calls for analytics
session_manager.mark_api_call(Some("api.axiom.trade")).await;

// Get session summary with timing information
let summary = session_manager.get_session_summary().await;
// Output: "Session: VALID | Tokens: VALID | Cookies: PRESENT | Turnkey: ACTIVE | Age: 45m | Last API: 2m ago"
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="http-client-integration"><a class="header" href="#http-client-integration">HTTP Client Integration</a></h3>
<p>Use sessions with HTTP requests:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Client;

async fn make_authenticated_request(
    session_manager: &amp;SessionManager,
    client: &amp;Client,
    url: &amp;str,
) -&gt; Result&lt;reqwest::Response, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut request = client.get(url);
    
    // Add authorization header
    if let Some(token) = session_manager.get_access_token().await {
        request = request.header("Authorization", format!("Bearer {}", token));
    }
    
    // Add cookie header
    if let Some(cookies) = session_manager.get_cookie_header().await {
        request = request.header("Cookie", cookies);
    }
    
    // Add user agent from session
    if let Some(session) = session_manager.get_session().await {
        request = request.header("User-Agent", session.get_user_agent());
    }
    
    let response = request.send().await?;
    
    // Track API call
    session_manager.mark_api_call(Some("api.axiom.trade")).await;
    
    Ok(response)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-integration"><a class="header" href="#websocket-integration">WebSocket Integration</a></h3>
<p>Use sessions for WebSocket authentication:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio_tungstenite::{connect_async, tungstenite::Message};

async fn connect_websocket(
    session_manager: &amp;SessionManager,
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    if !session_manager.is_session_valid().await {
        return Err("Invalid session for WebSocket connection".into());
    }
    
    let access_token = session_manager.get_access_token().await
        .ok_or("No access token available")?;
    
    let ws_url = format!("wss://ws.axiom.trade?token={}", access_token);
    let (ws_stream, _) = connect_async(&amp;ws_url).await?;
    
    // WebSocket connection established with session authentication
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h3>
<p>Handle session-related errors gracefully:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::auth::error::AuthError;

async fn handle_session_error(
    result: Result&lt;(), AuthError&gt;,
    session_manager: &amp;SessionManager,
) -&gt; Result&lt;(), AuthError&gt; {
    match result {
        Err(AuthError::NotAuthenticated) =&gt; {
            // Session invalid, clear and require re-authentication
            session_manager.clear_session().await;
            Err(AuthError::NotAuthenticated)
        }
        Err(AuthError::TokenExpired) =&gt; {
            // Try to refresh tokens
            if session_manager.needs_refresh().await {
                // Implement token refresh logic
                Ok(())
            } else {
                session_manager.clear_session().await;
                Err(AuthError::TokenExpired)
            }
        }
        other =&gt; other,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ol>
<li><strong>Use HTTPS only</strong> - Never transmit session data over unencrypted connections</li>
<li><strong>Secure storage</strong> - Store session files with appropriate file permissions</li>
<li><strong>Token rotation</strong> - Refresh tokens before expiration</li>
<li><strong>Cleanup on exit</strong> - Clear sessions when application terminates</li>
</ol>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<ol>
<li><strong>Auto-save carefully</strong> - Consider performance impact of frequent saves</li>
<li><strong>Session reuse</strong> - Reuse sessions across requests instead of recreating</li>
<li><strong>Batch updates</strong> - Disable auto-save for bulk operations, save manually</li>
<li><strong>Memory management</strong> - Clear unused sessions promptly</li>
</ol>
<h3 id="reliability-1"><a class="header" href="#reliability-1">Reliability</a></h3>
<ol>
<li><strong>Handle network failures</strong> - Implement retry logic for session operations</li>
<li><strong>Validate before use</strong> - Always check session validity before API calls</li>
<li><strong>Graceful degradation</strong> - Handle missing or corrupted session files</li>
<li><strong>Monitor session health</strong> - Track session age and usage patterns</li>
</ol>
<p>This comprehensive session management system provides robust, secure, and efficient handling of authentication state for the axiomtrade-rs client library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otp-verification"><a class="header" href="#otp-verification">OTP Verification</a></h1>
<p>The OTP (One-Time Password) verification system in axiomtrade-rs provides both manual and automatic OTP handling for secure authentication with Axiom Trade. This system supports automatic OTP retrieval from email via IMAP, eliminating the need for manual intervention in automated trading systems.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The OTP verification flow consists of two main approaches:</p>
<ol>
<li><strong>Manual OTP Entry</strong> - User manually enters the OTP code when prompted</li>
<li><strong>Automatic OTP Fetching</strong> - System automatically retrieves OTP from email via IMAP</li>
</ol>
<p>Both approaches integrate seamlessly with the authentication system and handle retries, timeouts, and error recovery.</p>
<h2 id="manual-otp-entry-1"><a class="header" href="#manual-otp-entry-1">Manual OTP Entry</a></h2>
<p>Manual OTP entry is the simplest approach and requires no additional setup beyond basic authentication credentials.</p>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // The None parameter triggers manual OTP entry
    let tokens = auth_client.login(
        "your-email@domain.com",
        "your-password",
        None  // Will prompt for manual OTP entry
    ).await?;
    
    println!("Authentication successful!");
    Ok(())
}</code></pre></pre>
<h3 id="manual-otp-helper-function"><a class="header" href="#manual-otp-helper-function">Manual OTP Helper Function</a></h3>
<p>You can also provide the OTP code directly if you have it from another source:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::io::{self, Write};

fn get_otp_from_user() -&gt; Result&lt;String, io::Error&gt; {
    print!("Enter OTP code: ");
    io::stdout().flush()?;
    
    let mut otp = String::new();
    io::stdin().read_line(&amp;mut otp)?;
    
    Ok(otp.trim().to_string())
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Get OTP from user input
    let otp_code = get_otp_from_user()?;
    
    let tokens = auth_client.login(
        "your-email@domain.com",
        "your-password",
        Some(otp_code)
    ).await?;
    
    println!("Authentication successful!");
    Ok(())
}</code></pre></pre>
<h2 id="automatic-otp-fetching"><a class="header" href="#automatic-otp-fetching">Automatic OTP Fetching</a></h2>
<p>Automatic OTP fetching eliminates manual intervention by retrieving OTP codes directly from your email via IMAP. This feature is essential for automated trading systems and production applications.</p>
<h3 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h3>
<p>Before enabling automatic OTP fetching, you need:</p>
<ol>
<li>An inbox.lv email account with IMAP enabled</li>
<li>Axiom Trade configured to send OTP emails to your inbox.lv address</li>
<li>Environment variables configured with IMAP credentials</li>
</ol>
<h3 id="environment-configuration-1"><a class="header" href="#environment-configuration-1">Environment Configuration</a></h3>
<p>Add these variables to your <code>.env</code> file:</p>
<pre><code class="language-env"># Axiom Trade Credentials
AXIOM_EMAIL=your_axiom_email@domain.com
AXIOM_PASSWORD=your_axiom_password

# inbox.lv IMAP Configuration
INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_imap_password
</code></pre>
<h3 id="automatic-otp-usage"><a class="header" href="#automatic-otp-usage">Automatic OTP Usage</a></h3>
<p>When environment variables are configured, the system automatically fetches OTP codes:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load environment variables
    dotenvy::dotenv().ok();
    
    let mut auth_client = AuthClient::new()?;
    
    // Automatic OTP fetching when None is passed
    let tokens = auth_client.login(
        &amp;std::env::var("AXIOM_EMAIL")?,
        &amp;std::env::var("AXIOM_PASSWORD")?,
        None  // System will automatically fetch OTP from email
    ).await?;
    
    println!("Authentication successful with automatic OTP!");
    Ok(())
}</code></pre></pre>
<h3 id="advanced-otp-fetching"><a class="header" href="#advanced-otp-fetching">Advanced OTP Fetching</a></h3>
<p>For more control over the OTP fetching process:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::email::otp_fetcher::{OtpFetcher, from_env};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create OTP fetcher from environment variables
    let otp_fetcher = from_env()?
        .ok_or("OTP fetcher not configured")?;
    
    // Wait for OTP with custom timeout and check interval
    if let Some(otp) = otp_fetcher.wait_for_otp(120, 5)? {
        println!("Retrieved OTP: {}", otp);
        
        // Use the OTP for authentication
        let mut auth_client = AuthClient::new()?;
        let tokens = auth_client.login(
            "your-email@domain.com",
            "your-password",
            Some(otp)
        ).await?;
        
        println!("Authentication successful!");
    } else {
        println!("OTP not received within timeout");
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="otp-validation-flow"><a class="header" href="#otp-validation-flow">OTP Validation Flow</a></h2>
<p>The OTP validation process follows this sequence:</p>
<ol>
<li><strong>Initial Login Request</strong> - Send credentials to <code>/login-password-v2</code></li>
<li><strong>OTP JWT Token</strong> - Receive temporary JWT token for OTP verification</li>
<li><strong>OTP Retrieval</strong> - Get OTP code (manual entry or automatic fetch)</li>
<li><strong>OTP Verification</strong> - Send OTP code to <code>/login-otp</code> with JWT token</li>
<li><strong>Token Receipt</strong> - Receive access and refresh tokens on success</li>
</ol>
<h3 id="flow-diagram"><a class="header" href="#flow-diagram">Flow Diagram</a></h3>
<pre><code>[Credentials] → [login-password-v2] → [OTP JWT Token]
                                            ↓
[OTP Code] ← [Manual/Auto Fetch] ← [OTP Required]
     ↓
[login-otp] → [Access/Refresh Tokens]
</code></pre>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h3>
<p>The authentication client handles the complete flow automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal flow (handled automatically by AuthClient)
async fn login_flow_example() -&gt; Result&lt;(), AuthError&gt; {
    let mut client = AuthClient::new()?;
    
    // Step 1: Initial login - gets OTP JWT token
    let otp_jwt_token = client.login_step1(email, hashed_password).await?;
    
    // Step 2: Fetch OTP (automatic or manual)
    let otp_code = client.fetch_otp().await?;
    
    // Step 3: Verify OTP and get tokens
    let tokens = client.login_step2(&amp;otp_jwt_token, &amp;otp_code, email, hashed_password).await?;
    
    // Tokens are automatically saved by TokenManager
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="retry-logic"><a class="header" href="#retry-logic">Retry Logic</a></h2>
<p>The OTP system includes comprehensive retry logic for robust operation:</p>
<h3 id="email-fetching-retries"><a class="header" href="#email-fetching-retries">Email Fetching Retries</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic retry with exponential backoff
pub fn wait_for_otp(&amp;self, timeout_seconds: u64, check_interval_seconds: u64) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn Error&gt;&gt; {
    let start_time = std::time::Instant::now();
    let timeout_duration = std::time::Duration::from_secs(timeout_seconds);
    let check_interval = std::time::Duration::from_secs(check_interval_seconds);
    
    while start_time.elapsed() &lt; timeout_duration {
        // Check for new OTP emails
        if let Some(otp) = self.fetchotp_recent(3)? {
            return Ok(Some(otp));
        }
        
        // Wait before next check
        std::thread::sleep(check_interval);
    }
    
    Ok(None) // Timeout reached
}
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-retries"><a class="header" href="#authentication-retries">Authentication Retries</a></h3>
<p>The authentication client automatically retries failed requests:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Built-in retry logic for authentication requests
impl AuthClient {
    async fn login_with_retry(&amp;mut self, email: &amp;str, password: &amp;str, max_retries: u32) -&gt; Result&lt;AuthTokens, AuthError&gt; {
        let mut retries = 0;
        
        loop {
            match self.login(email, password, None).await {
                Ok(tokens) =&gt; return Ok(tokens),
                Err(AuthError::NetworkError(_)) if retries &lt; max_retries =&gt; {
                    retries += 1;
                    println!("Login attempt {} failed, retrying...", retries);
                    tokio::time::sleep(tokio::time::Duration::from_secs(retries as u64)).await;
                }
                Err(e) =&gt; return Err(e),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multiple-endpoint-fallback"><a class="header" href="#multiple-endpoint-fallback">Multiple Endpoint Fallback</a></h3>
<p>The system automatically tries different API endpoints on failure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic endpoint rotation on failure
let endpoints = [
    "https://api2.axiom.trade",
    "https://api3.axiom.trade", 
    "https://api6.axiom.trade",
    // ... more endpoints
];

// Client automatically selects different endpoint on retry
<span class="boring">}</span></code></pre></pre>
<h2 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h2>
<h3 id="imap-connection-issues"><a class="header" href="#imap-connection-issues">IMAP Connection Issues</a></h3>
<p><strong>Problem</strong>: Connection to inbox.lv IMAP server fails</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"IMAP connection failed" errors</li>
<li>"Authentication failed" messages</li>
<li>Timeout errors connecting to mail.inbox.lv</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Verify IMAP is enabled</strong>: Wait 15 minutes after enabling IMAP in inbox.lv settings</li>
<li><strong>Check credentials</strong>: Use IMAP password, not web login password</li>
<li><strong>Test connection</strong>: Try logging into inbox.lv webmail to verify credentials</li>
<li><strong>Firewall check</strong>: Ensure port 993 (IMAPS) is not blocked</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test IMAP connection manually
use imap::ClientBuilder;

async fn test_imap_connection() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let tls = native_tls::TlsConnector::builder().build()?;
    let client = imap::connect(("mail.inbox.lv", 993), "mail.inbox.lv", &amp;tls)?;
    
    let _session = client.login("your_email@inbox.lv", "your_imap_password")
        .map_err(|e| format!("IMAP login failed: {:?}", e))?;
    
    println!("IMAP connection successful!");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="otp-email-not-found"><a class="header" href="#otp-email-not-found">OTP Email Not Found</a></h3>
<p><strong>Problem</strong>: System cannot find OTP emails in inbox</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"No OTP emails found" errors</li>
<li>"OTP not received within timeout" messages</li>
<li>Empty email search results</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Check email forwarding</strong>: Verify Axiom Trade sends OTP to inbox.lv address</li>
<li><strong>Check spam folder</strong>: OTP emails might be filtered as spam</li>
<li><strong>Verify email format</strong>: Ensure subject contains "Your Axiom security code is XXXXXX"</li>
<li><strong>Test email delivery</strong>: Send test email to inbox.lv to verify delivery</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual email search for debugging
use axiomtrade_rs::email::otp_fetcher::OtpFetcher;

async fn debug_email_search() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fetcher = OtpFetcher::new(
        "your_email@inbox.lv".to_string(),
        "your_imap_password".to_string()
    );
    
    // Check for any recent emails (not just OTP)
    println!("Searching for recent emails...");
    
    // This would require additional methods in the OtpFetcher implementation
    // to help debug email reception issues
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="otp-extraction-failures"><a class="header" href="#otp-extraction-failures">OTP Extraction Failures</a></h3>
<p><strong>Problem</strong>: OTP found in email but extraction fails</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"OTP extraction failed" errors</li>
<li>Retrieved empty or invalid OTP codes</li>
<li>Regex pattern matching failures</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Check email format</strong>: Verify actual email subject and body format</li>
<li><strong>Update patterns</strong>: Add new regex patterns if email format changed</li>
<li><strong>Manual verification</strong>: Check raw email content for OTP code location</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug OTP extraction
fn debug_otp_extraction(email_content: &amp;str) {
    let patterns = vec![
        r"Your Axiom security code is[:\s]+(\d{6})",
        r"Your security code is[:\s]+(\d{6})",
        r"security code[:\s]+(\d{6})",
        r"&lt;span[^&gt;]*&gt;(\d{6})&lt;/span&gt;",
        r"&lt;b&gt;(\d{6})&lt;/b&gt;",
        r"&lt;strong&gt;(\d{6})&lt;/strong&gt;",
    ];
    
    for pattern in patterns {
        if let Ok(re) = regex::Regex::new(pattern) {
            if let Some(captures) = re.captures(email_content) {
                if let Some(otp) = captures.get(1) {
                    println!("Found OTP '{}' using pattern: {}", otp.as_str(), pattern);
                    return;
                }
            }
        }
    }
    
    println!("No OTP found in email content");
    println!("Email content preview: {}", &amp;email_content[..std::cmp::min(200, email_content.len())]);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-timeout-issues"><a class="header" href="#authentication-timeout-issues">Authentication Timeout Issues</a></h3>
<p><strong>Problem</strong>: OTP verification takes too long or times out</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"Authentication timeout" errors</li>
<li>Slow OTP retrieval (&gt;2 minutes)</li>
<li>Connection timeouts during verification</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Increase timeout</strong>: Extend OTP wait time for slow email delivery</li>
<li><strong>Reduce check interval</strong>: Check for emails more frequently</li>
<li><strong>Network check</strong>: Verify stable internet connection</li>
<li><strong>Server selection</strong>: Try different API endpoints</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom timeout configuration
async fn login_with_custom_timeout() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Configure longer timeout for OTP fetching
    if let Some(otp_fetcher) = auth_client.get_otp_fetcher() {
        // Wait up to 5 minutes, check every 10 seconds
        if let Some(otp) = otp_fetcher.wait_for_otp(300, 10)? {
            let tokens = auth_client.login(
                "email@domain.com",
                "password", 
                Some(otp)
            ).await?;
            println!("Authentication successful with extended timeout!");
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="token-management-issues"><a class="header" href="#token-management-issues">Token Management Issues</a></h3>
<p><strong>Problem</strong>: Token storage or refresh failures</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"Token not found" errors</li>
<li>"Token expired" messages</li>
<li>Authentication succeeds but tokens not saved</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Check file permissions</strong>: Ensure write access to token file location</li>
<li><strong>Verify token format</strong>: Check saved token file structure</li>
<li><strong>Manual token refresh</strong>: Implement custom token refresh logic</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual token management
use axiomtrade_rs::auth::{TokenManager, AuthTokens};

async fn manage_tokens_manually() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let token_manager = TokenManager::new(Some(std::path::PathBuf::from(".axiom_tokens.json")));
    
    // Check for existing tokens
    if let Ok(Some(tokens)) = token_manager.get_tokens().await {
        if tokens.is_expired() {
            println!("Tokens expired, refreshing...");
            
            let mut auth_client = AuthClient::new()?;
            let new_access_token = auth_client.refresh_token(&amp;tokens.refresh_token).await?;
            
            let updated_tokens = AuthTokens {
                access_token: new_access_token,
                refresh_token: tokens.refresh_token,
                expires_at: Some(chrono::Utc::now() + chrono::Duration::hours(1)),
            };
            
            token_manager.set_tokens(updated_tokens).await?;
            println!("Tokens refreshed successfully!");
        } else {
            println!("Tokens are still valid");
        }
    } else {
        println!("No existing tokens found, need to login");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h3>
<ol>
<li><strong>Dedicated Email</strong>: Use inbox.lv account only for OTP purposes</li>
<li><strong>Environment Variables</strong>: Store credentials in <code>.env</code> file, never in code</li>
<li><strong>File Permissions</strong>: Secure token storage files with appropriate permissions</li>
<li><strong>Credential Rotation</strong>: Regularly update IMAP passwords</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ol>
<li><strong>Connection Pooling</strong>: Reuse IMAP connections when possible</li>
<li><strong>Caching</strong>: Cache successful configurations to reduce setup time</li>
<li><strong>Async Operations</strong>: Use async/await for all network operations</li>
<li><strong>Timeout Tuning</strong>: Optimize timeout values based on email delivery speed</li>
</ol>
<h3 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h3>
<ol>
<li><strong>Graceful Degradation</strong>: Fall back to manual OTP when automatic fails</li>
<li><strong>Detailed Logging</strong>: Log OTP retrieval steps for debugging</li>
<li><strong>User Feedback</strong>: Provide clear status messages during OTP process</li>
<li><strong>Retry Strategies</strong>: Implement exponential backoff for failed requests</li>
</ol>
<h3 id="production-deployment"><a class="header" href="#production-deployment">Production Deployment</a></h3>
<ol>
<li><strong>Health Checks</strong>: Monitor OTP system health and email delivery</li>
<li><strong>Alerting</strong>: Set up alerts for OTP failures or slow delivery</li>
<li><strong>Backup Methods</strong>: Have manual OTP fallback for system maintenance</li>
<li><strong>Documentation</strong>: Maintain setup documentation for team members</li>
</ol>
<h2 id="testing-your-setup"><a class="header" href="#testing-your-setup">Testing Your Setup</a></h2>
<p>Use the provided test example to verify your OTP configuration:</p>
<pre><code class="language-bash">cargo run --example test_auto_otp
</code></pre>
<p>This test will:</p>
<ol>
<li>Verify environment variable configuration</li>
<li>Test IMAP connection to inbox.lv</li>
<li>Attempt full authentication flow with automatic OTP</li>
<li>Provide detailed diagnostic information on failures</li>
</ol>
<p>The test output will guide you through any configuration issues and provide specific troubleshooting steps for your setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portfolio-management"><a class="header" href="#portfolio-management">Portfolio Management</a></h1>
<p>The portfolio management system in axiomtrade-rs provides comprehensive access to wallet balances, token holdings, and portfolio analytics. This module allows you to query single wallets, perform batch operations across multiple addresses, and retrieve detailed portfolio summaries.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>The <code>PortfolioClient</code> handles all portfolio-related operations including:</p>
<ul>
<li><strong>Single wallet balance queries</strong> - Get detailed balance information for individual wallets</li>
<li><strong>Batch balance operations</strong> - Query multiple wallets simultaneously for efficiency</li>
<li><strong>Portfolio summaries</strong> - Comprehensive portfolio analytics with performance metrics</li>
<li><strong>Token account analysis</strong> - Detailed token holdings and distribution analysis</li>
</ul>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::portfolio::PortfolioClient;

// Create portfolio client
let mut portfolio_client = PortfolioClient::new()?;

// Get single wallet balance
let balance = portfolio_client.get_balance("DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK").await?;
println!("SOL Balance: {:.6}", balance.sol_balance);
println!("Total Value: ${:.2}", balance.total_value_usd);
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-wallet-balances"><a class="header" href="#getting-wallet-balances">Getting Wallet Balances</a></h2>
<h3 id="single-wallet-balance"><a class="header" href="#single-wallet-balance">Single Wallet Balance</a></h3>
<p>Retrieve the complete balance information for a single Solana wallet address.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wallet_address = "DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK";
let balance = portfolio_client.get_balance(wallet_address).await?;

println!("SOL Balance: {:.6} SOL", balance.sol_balance);
println!("Total USD Value: ${:.2}", balance.total_value_usd);
println!("Token Count: {}", balance.token_balances.len());

// Access individual token balances
for (mint_address, token) in &amp;balance.token_balances {
    println!("{} ({}): {} tokens (${:.2})", 
        token.symbol, 
        token.name,
        token.ui_amount, 
        token.value_usd
    );
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Response Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WalletBalance {
    sol_balance: f64,                              // SOL amount in native units
    token_balances: HashMap&lt;String, TokenBalance&gt;, // Token holdings by mint address
    total_value_usd: f64,                         // Total portfolio value in USD
}

TokenBalance {
    mint_address: String,     // Token mint address
    symbol: String,           // Token symbol (e.g., "USDC")
    name: String,             // Full token name
    amount: f64,              // Raw token amount
    decimals: u8,             // Token decimal places
    ui_amount: f64,           // Human-readable amount
    value_usd: f64,           // USD value of holding
    price_per_token: f64,     // Current token price
}
<span class="boring">}</span></code></pre></pre>
<h2 id="batch-balance-queries"><a class="header" href="#batch-balance-queries">Batch Balance Queries</a></h2>
<p>For applications managing multiple wallets, batch queries provide significant performance improvements by fetching all balances in a single API call.</p>
<h3 id="basic-batch-query"><a class="header" href="#basic-batch-query">Basic Batch Query</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wallet_addresses = vec![
    "DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK".to_string(),
    "5FHwkrdxntdK24hgQU8qgBjn35Y1zwhz1GZwCkP2UJnM".to_string(),
    "7xLk17EQQ5KLDLDe44wCmupJKJjTGd8hs3eSVVhCx932".to_string(),
];

let batch_response = portfolio_client.get_batch_balance(&amp;wallet_addresses).await?;

println!("Retrieved {} wallet balances", batch_response.balances.len());

let mut total_value = 0.0;
for (address, balance) in &amp;batch_response.balances {
    println!("Wallet {}: {:.6} SOL (${:.2})", 
        &amp;address[..8], 
        balance.sol_balance, 
        balance.total_value_usd
    );
    total_value += balance.total_value_usd;
}

println!("Combined portfolio value: ${:.2}", total_value);
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-batch-analysis"><a class="header" href="#advanced-batch-analysis">Advanced Batch Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let batch_response = portfolio_client.get_batch_balance(&amp;wallet_addresses).await?;

// Analyze token distribution across wallets
let mut token_counts = HashMap::new();
let mut token_values = HashMap::new();

for (address, balance) in &amp;batch_response.balances {
    for token in balance.token_balances.values() {
        *token_counts.entry(token.symbol.clone()).or_insert(0) += 1;
        *token_values.entry(token.symbol.clone()).or_insert(0.0) += token.value_usd;
    }
}

// Find most common tokens
let mut sorted_tokens: Vec&lt;_&gt; = token_counts.iter().collect();
sorted_tokens.sort_by(|a, b| b.1.cmp(a.1));

for (token, count) in sorted_tokens.iter().take(5) {
    let total_value = token_values.get(*token).unwrap_or(&amp;0.0);
    println!("{} - held by {} wallets, total value: ${:.2}", 
        token, count, total_value);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Batch Response Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>BatchBalanceResponse {
    balances: HashMap&lt;String, WalletBalance&gt;, // Wallet address -&gt; balance data
    timestamp: i64,                          // Query timestamp
}
<span class="boring">}</span></code></pre></pre>
<h2 id="portfolio-summary"><a class="header" href="#portfolio-summary">Portfolio Summary</a></h2>
<p>The portfolio summary provides comprehensive analytics including performance metrics, top positions, and transaction history.</p>
<h3 id="getting-portfolio-summary"><a class="header" href="#getting-portfolio-summary">Getting Portfolio Summary</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wallet_addresses = vec![
    "DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK".to_string(),
    "5FHwkrdxntdK24hgQU8qgBjn35Y1zwhz1GZwCkP2UJnM".to_string(),
];

let portfolio = portfolio_client.get_portfolio_summary(&amp;wallet_addresses).await?;

// Overall balance statistics
println!("Total Value: {:.4} SOL", portfolio.balance_stats.total_value_sol);
println!("Available Balance: {:.4} SOL", portfolio.balance_stats.available_balance_sol);
println!("Unrealized PnL: {:.4} SOL", portfolio.balance_stats.unrealized_pnl_sol);

// Performance metrics
println!("1 Day PnL: {:.4} SOL", portfolio.performance_metrics.one_day.total_pnl);
println!("7 Day PnL: {:.4} SOL", portfolio.performance_metrics.seven_day.total_pnl);
println!("30 Day PnL: {:.4} SOL", portfolio.performance_metrics.thirty_day.total_pnl);
println!("All Time PnL: {:.4} SOL", portfolio.performance_metrics.all_time.total_pnl);
<span class="boring">}</span></code></pre></pre>
<h3 id="analyzing-top-positions"><a class="header" href="#analyzing-top-positions">Analyzing Top Positions</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Display top holdings
for (i, position) in portfolio.top_positions.iter().take(10).enumerate() {
    println!("{}. {} ({})", 
        i + 1, 
        position.symbol.as_deref().unwrap_or("Unknown"), 
        position.name.as_deref().unwrap_or("Unknown")
    );
    
    if let Some(amount) = position.amount {
        println!("   Amount: {:.4}", amount);
    }
    if let Some(value_usd) = position.value_usd {
        println!("   Value: ${:.2}", value_usd);
    }
    if let Some(pnl_percent) = position.pnl_percent {
        println!("   PnL: {}{:.2}%", 
            if pnl_percent &gt;= 0.0 { "+" } else { "" },
            pnl_percent
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-history"><a class="header" href="#transaction-history">Transaction History</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Recent transactions
for tx in portfolio.transactions.iter().take(10) {
    if let (Some(symbol), Some(tx_type), Some(amount), Some(value_usd)) = 
        (&amp;tx.symbol, &amp;tx.transaction_type, tx.amount, tx.value_usd) {
        println!("{} {} {} for ${:.2}", tx_type, amount, symbol, value_usd);
        
        if let Some(timestamp) = tx.timestamp {
            let datetime = chrono::DateTime::from_timestamp(timestamp / 1000, 0)
                .unwrap_or_default();
            println!("   Time: {}", datetime.format("%Y-%m-%d %H:%M:%S UTC"));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="portfolio-monitoring"><a class="header" href="#portfolio-monitoring">Portfolio Monitoring</a></h2>
<p>For real-time portfolio tracking, you can implement continuous monitoring with change detection.</p>
<h3 id="basic-monitoring-loop"><a class="header" href="#basic-monitoring-loop">Basic Monitoring Loop</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use tokio::time::sleep;

let mut last_portfolio = portfolio_client.get_portfolio_summary(&amp;wallet_addresses).await?;
let initial_value = last_portfolio.balance_stats.total_value_sol;

loop {
    sleep(Duration::from_secs(30)).await;
    
    match portfolio_client.get_portfolio_summary(&amp;wallet_addresses).await {
        Ok(current_portfolio) =&gt; {
            // Detect changes
            let value_change = current_portfolio.balance_stats.total_value_sol - 
                              last_portfolio.balance_stats.total_value_sol;
            
            if value_change.abs() &gt; 0.001 {
                let change_pct = (value_change / last_portfolio.balance_stats.total_value_sol) * 100.0;
                println!("Portfolio value changed: {:+.6} SOL ({:+.2}%)", 
                    value_change, change_pct);
            }
            
            // Check for new positions
            if current_portfolio.active_positions.len() != last_portfolio.active_positions.len() {
                let pos_diff = current_portfolio.active_positions.len() as i32 - 
                              last_portfolio.active_positions.len() as i32;
                println!("Position count changed: {:+} positions", pos_diff);
            }
            
            last_portfolio = current_portfolio;
        }
        Err(e) =&gt; println!("Error fetching portfolio: {}", e),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-tracking"><a class="header" href="#performance-tracking">Performance Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut value_history = Vec::new();

// Track performance over time
value_history.push((Instant::now(), portfolio.balance_stats.total_value_sol));

// Calculate volatility (after collecting sufficient data points)
if value_history.len() &gt;= 10 {
    let recent_values: Vec&lt;f64&gt; = value_history.iter()
        .rev()
        .take(10)
        .map(|(_, value)| *value)
        .collect();
    
    let mean = recent_values.iter().sum::&lt;f64&gt;() / recent_values.len() as f64;
    let variance = recent_values.iter()
        .map(|value| (value - mean).powi(2))
        .sum::&lt;f64&gt;() / recent_values.len() as f64;
    
    let volatility = (variance.sqrt() / mean) * 100.0;
    println!("Portfolio volatility: {:.2}%", volatility);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="token-account-analysis"><a class="header" href="#token-account-analysis">Token Account Analysis</a></h2>
<p>Analyze token distribution and concentration across your portfolio.</p>
<h3 id="position-size-analysis"><a class="header" href="#position-size-analysis">Position Size Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let batch_response = portfolio_client.get_batch_balance(&amp;wallet_addresses).await?;

// Aggregate all token positions
let mut token_summary = HashMap::new();

for (wallet_address, balance) in &amp;batch_response.balances {
    for (mint, token) in &amp;balance.token_balances {
        let entry = token_summary.entry(token.symbol.clone()).or_insert_with(|| {
            (0.0, 0.0, 0) // (total_balance, total_usd_value, wallet_count)
        });
        
        entry.0 += token.ui_amount;
        entry.1 += token.value_usd;
        entry.2 += 1;
    }
}

// Sort by total USD value
let mut sorted_tokens: Vec&lt;_&gt; = token_summary.iter().collect();
sorted_tokens.sort_by(|a, b| b.1.1.partial_cmp(&amp;a.1.1).unwrap());

// Display top holdings
println!("{:&lt;15} {:&gt;15} {:&gt;15} {:&gt;10}", "Symbol", "Total Balance", "USD Value", "Wallets");
println!("{}", "-".repeat(65));

for (symbol, (balance, usd_value, wallet_count)) in sorted_tokens.iter().take(10) {
    println!("{:&lt;15} {:&gt;15.6} {:&gt;15.2} {:&gt;10}", 
        symbol, balance, usd_value, wallet_count);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="risk-analysis"><a class="header" href="#risk-analysis">Risk Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Calculate concentration risk
let total_value: f64 = sorted_tokens.iter().map(|(_, (_, usd_value, _))| usd_value).sum();
let top_5_value: f64 = sorted_tokens.iter()
    .take(5)
    .map(|(_, (_, usd_value, _))| usd_value)
    .sum();

let concentration_ratio = (top_5_value / total_value) * 100.0;
println!("Top 5 token concentration: {:.1}%", concentration_ratio);

if concentration_ratio &gt; 70.0 {
    println!("WARNING: High concentration risk detected");
}

// Identify small positions
let small_positions = sorted_tokens.iter()
    .filter(|(_, (_, usd_value, _))| **usd_value &lt; 5.0)
    .count();

println!("Positions under $5: {} ({:.1}%)", 
    small_positions, 
    (small_positions as f64 / sorted_tokens.len() as f64) * 100.0
);
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-api-reference"><a class="header" href="#complete-api-reference">Complete API Reference</a></h2>
<h3 id="portfolioclient-methods"><a class="header" href="#portfolioclient-methods">PortfolioClient Methods</a></h3>
<h4 id="new---resultself-portfolioerror"><a class="header" href="#new---resultself-portfolioerror"><code>new() -&gt; Result&lt;Self, PortfolioError&gt;</code></a></h4>
<p>Creates a new portfolio client instance.</p>
<p><strong>Returns:</strong> <code>Result&lt;PortfolioClient, PortfolioError&gt;</code></p>
<h4 id="get_balancewallet_address-str---resultwalletbalance-portfolioerror"><a class="header" href="#get_balancewallet_address-str---resultwalletbalance-portfolioerror"><code>get_balance(wallet_address: &amp;str) -&gt; Result&lt;WalletBalance, PortfolioError&gt;</code></a></h4>
<p>Gets the balance for a single wallet address.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>wallet_address: &amp;str</code> - The Solana wallet address to query</li>
</ul>
<p><strong>Returns:</strong> <code>Result&lt;WalletBalance, PortfolioError&gt;</code></p>
<h4 id="get_batch_balancewallet_addresses-string---resultbatchbalanceresponse-portfolioerror"><a class="header" href="#get_batch_balancewallet_addresses-string---resultbatchbalanceresponse-portfolioerror"><code>get_batch_balance(wallet_addresses: &amp;[String]) -&gt; Result&lt;BatchBalanceResponse, PortfolioError&gt;</code></a></h4>
<p>Gets balances for multiple wallet addresses in a single request.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>wallet_addresses: &amp;[String]</code> - Array of Solana wallet addresses</li>
</ul>
<p><strong>Returns:</strong> <code>Result&lt;BatchBalanceResponse, PortfolioError&gt;</code></p>
<h4 id="get_portfolio_summarywallet_addresses-string---resultportfoliov5response-portfolioerror"><a class="header" href="#get_portfolio_summarywallet_addresses-string---resultportfoliov5response-portfolioerror"><code>get_portfolio_summary(wallet_addresses: &amp;[String]) -&gt; Result&lt;PortfolioV5Response, PortfolioError&gt;</code></a></h4>
<p>Gets comprehensive portfolio summary with performance metrics.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>wallet_addresses: &amp;[String]</code> - Array of wallet addresses to include in portfolio</li>
</ul>
<p><strong>Returns:</strong> <code>Result&lt;PortfolioV5Response, PortfolioError&gt;</code></p>
<h3 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h3>
<p>All portfolio operations return <code>Result&lt;T, PortfolioError&gt;</code>. Handle errors appropriately:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match portfolio_client.get_balance(wallet_address).await {
    Ok(balance) =&gt; {
        // Process successful response
        println!("Balance: {:.6} SOL", balance.sol_balance);
    }
    Err(PortfolioError::InvalidWalletAddress(addr)) =&gt; {
        println!("Invalid wallet address: {}", addr);
    }
    Err(PortfolioError::AuthError(auth_err)) =&gt; {
        println!("Authentication error: {}", auth_err);
        // May need to re-authenticate
    }
    Err(PortfolioError::NetworkError(net_err)) =&gt; {
        println!("Network error: {}", net_err);
        // Retry with backoff
    }
    Err(PortfolioError::ApiError(api_err)) =&gt; {
        println!("API error: {}", api_err);
    }
    Err(e) =&gt; {
        println!("Unexpected error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="data-models"><a class="header" href="#data-models">Data Models</a></h3>
<h4 id="walletbalance"><a class="header" href="#walletbalance">WalletBalance</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WalletBalance {
    pub sol_balance: f64,                              // SOL balance in native units
    pub token_balances: HashMap&lt;String, TokenBalance&gt;, // Token holdings by mint
    pub total_value_usd: f64,                          // Total USD value
}
<span class="boring">}</span></code></pre></pre>
<h4 id="tokenbalance"><a class="header" href="#tokenbalance">TokenBalance</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TokenBalance {
    pub mint_address: String,     // Token mint address  
    pub symbol: String,           // Token symbol (e.g., "USDC")
    pub name: String,             // Full token name
    pub amount: f64,              // Raw token amount
    pub decimals: u8,             // Token decimal places
    pub ui_amount: f64,           // Human-readable amount
    pub value_usd: f64,           // USD value of holding
    pub price_per_token: f64,     // Current token price
}
<span class="boring">}</span></code></pre></pre>
<h4 id="portfoliov5response"><a class="header" href="#portfoliov5response">PortfolioV5Response</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PortfolioV5Response {
    pub active_positions: Vec&lt;Position&gt;,          // Current holdings
    pub history_positions: Vec&lt;Position&gt;,         // Historical positions
    pub top_positions: Vec&lt;Position&gt;,             // Top holdings by value
    pub transactions: Vec&lt;Transaction&gt;,           // Recent transactions
    pub balance_stats: BalanceStats,              // Balance summary
    pub performance_metrics: PerformanceMetrics, // Performance data
    pub chart_data: Vec&lt;ChartDataPoint&gt;,          // Chart data points
    pub calendar_data: Vec&lt;CalendarDataPoint&gt;,    // Calendar view data
}
<span class="boring">}</span></code></pre></pre>
<h4 id="balancestats"><a class="header" href="#balancestats">BalanceStats</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BalanceStats {
    pub total_value_sol: f64,       // Total portfolio value in SOL
    pub available_balance_sol: f64, // Available (liquid) balance
    pub unrealized_pnl_sol: f64,    // Unrealized profit/loss
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="efficient-batch-operations"><a class="header" href="#efficient-batch-operations">Efficient Batch Operations</a></h3>
<ul>
<li>Use batch queries for multiple wallets to reduce API calls</li>
<li>Limit batch size to reasonable numbers (typically 50-100 wallets)</li>
<li>Implement proper error handling for partial failures</li>
</ul>
<h3 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h3>
<ul>
<li>Cache balance data when possible to reduce API load</li>
<li>Use appropriate update intervals for monitoring (30-60 seconds minimum)</li>
<li>Implement exponential backoff for failed requests</li>
</ul>
<h3 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h3>
<ul>
<li>Handle authentication errors by refreshing tokens</li>
<li>Implement retry logic for transient network errors</li>
<li>Validate wallet addresses before making API calls</li>
</ul>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<ul>
<li>Clean up historical data periodically in monitoring applications</li>
<li>Avoid storing excessive amounts of portfolio history in memory</li>
<li>Use streaming or pagination for large datasets</li>
</ul>
<p>This portfolio management system provides comprehensive tools for tracking and analyzing Solana wallet portfolios, from simple balance queries to advanced risk analysis and real-time monitoring capabilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trading-operations"><a class="header" href="#trading-operations">Trading Operations</a></h1>
<p>The Axiom Trade trading API provides comprehensive trading functionality for Solana tokens with built-in risk management, slippage protection, and MEV (Maximum Extractable Value) safeguards. This guide covers all trading operations, order types, and best practices for safe and efficient trading.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="api/trading.html#quick-start">Quick Start</a></li>
<li><a href="api/trading.html#buy-operations">Buy Operations</a></li>
<li><a href="api/trading.html#sell-operations">Sell Operations</a></li>
<li><a href="api/trading.html#swap-operations">Swap Operations</a></li>
<li><a href="api/trading.html#price-quotes">Price Quotes</a></li>
<li><a href="api/trading.html#slippage-and-mev-protection">Slippage and MEV Protection</a></li>
<li><a href="api/trading.html#order-types-and-parameters">Order Types and Parameters</a></li>
<li><a href="api/trading.html#trading-limits">Trading Limits</a></li>
<li><a href="api/trading.html#transaction-simulation">Transaction Simulation</a></li>
<li><a href="api/trading.html#error-handling">Error Handling</a></li>
<li><a href="api/trading.html#best-practices">Best Practices</a></li>
<li><a href="api/trading.html#security-considerations">Security Considerations</a></li>
</ul>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::api::trading::TradingClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize trading client
    let mut trading_client = TradingClient::new()?;
    
    // Example: Buy USDC with SOL
    let usdc_mint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
    let amount_sol = 0.1;
    
    let order = trading_client
        .buy_token(usdc_mint, amount_sol, Some(1.0))
        .await?;
    
    println!("Buy order executed: {}", order.signature);
    Ok(())
}</code></pre></pre>
<h2 id="buy-operations"><a class="header" href="#buy-operations">Buy Operations</a></h2>
<p>Buy operations allow you to purchase tokens using SOL as the base currency. The API handles routing through the best available liquidity sources.</p>
<h3 id="basic-buy"><a class="header" href="#basic-buy">Basic Buy</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Buy tokens with SOL
let order_response = trading_client
    .buy_token(
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC mint
        0.1,                                              // 0.1 SOL
        Some(1.0)                                         // 1% slippage
    )
    .await?;

println!("Transaction signature: {}", order_response.signature);
println!("Tokens received: {}", order_response.amount_out);
println!("Price per token: ${}", order_response.price_per_token);
<span class="boring">}</span></code></pre></pre>
<h3 id="buy-with-custom-parameters"><a class="header" href="#buy-with-custom-parameters">Buy with Custom Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::models::trading::BuyOrderRequest;

// Get a quote first to check the expected output
let quote = trading_client
    .get_quote(
        "So11111111111111111111111111111111111111112", // Native SOL
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
        0.1,
        Some(0.5)  // 0.5% slippage for quote
    )
    .await?;

println!("Expected USDC output: {}", quote.out_amount);
println!("Price impact: {:.2}%", quote.price_impact);

// Execute buy if satisfied with quote
if quote.price_impact &lt; 2.0 {  // Only if price impact is less than 2%
    let order = trading_client
        .buy_token(
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            0.1,
            Some(0.5)  // Conservative slippage
        )
        .await?;
    
    println!("Buy executed successfully!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="buy-order-parameters"><a class="header" href="#buy-order-parameters">Buy Order Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>token_mint</code></td><td><code>&amp;str</code></td><td>Token mint address to buy</td><td>Required</td></tr>
<tr><td><code>amount_sol</code></td><td><code>f64</code></td><td>Amount of SOL to spend</td><td>Required</td></tr>
<tr><td><code>slippage_percent</code></td><td><code>Option&lt;f64&gt;</code></td><td>Maximum slippage tolerance</td><td>5.0%</td></tr>
<tr><td><code>priority_fee</code></td><td><code>Option&lt;f64&gt;</code></td><td>Priority fee in SOL</td><td>Auto-calculated</td></tr>
</tbody></table>
</div>
<h2 id="sell-operations"><a class="header" href="#sell-operations">Sell Operations</a></h2>
<p>Sell operations convert your token holdings back to SOL through optimal routing.</p>
<h3 id="basic-sell"><a class="header" href="#basic-sell">Basic Sell</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sell tokens for SOL
let order_response = trading_client
    .sell_token(
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC mint
        10.0,                                             // 10 USDC
        Some(1.0)                                         // 1% slippage
    )
    .await?;

println!("SOL received: {}", order_response.amount_out);
println!("Transaction fee: {}", order_response.fee);
<span class="boring">}</span></code></pre></pre>
<h3 id="sell-with-price-checking"><a class="header" href="#sell-with-price-checking">Sell with Price Checking</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check current price before selling
let quote = trading_client
    .get_quote(
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
        "So11111111111111111111111111111111111111112",   // Native SOL
        10.0,
        Some(1.0)
    )
    .await?;

println!("Expected SOL output: {}", quote.out_amount);
println!("Current SOL/USDC rate: {:.6}", quote.out_amount / 10.0);

// Proceed with sell if price is acceptable
let min_sol_expected = 0.08; // Minimum SOL we want to receive
if quote.out_amount &gt;= min_sol_expected {
    let order = trading_client
        .sell_token(
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            10.0,
            Some(1.0)
        )
        .await?;
    
    println!("Sell executed: {} SOL received", order.amount_out);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sell-order-parameters"><a class="header" href="#sell-order-parameters">Sell Order Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>token_mint</code></td><td><code>&amp;str</code></td><td>Token mint address to sell</td><td>Required</td></tr>
<tr><td><code>amount_tokens</code></td><td><code>f64</code></td><td>Amount of tokens to sell</td><td>Required</td></tr>
<tr><td><code>slippage_percent</code></td><td><code>Option&lt;f64&gt;</code></td><td>Maximum slippage tolerance</td><td>5.0%</td></tr>
<tr><td><code>priority_fee</code></td><td><code>Option&lt;f64&gt;</code></td><td>Priority fee in SOL</td><td>Auto-calculated</td></tr>
</tbody></table>
</div>
<h2 id="swap-operations"><a class="header" href="#swap-operations">Swap Operations</a></h2>
<p>Swap operations allow direct token-to-token exchanges without using SOL as an intermediary.</p>
<h3 id="basic-token-swap"><a class="header" href="#basic-token-swap">Basic Token Swap</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Swap USDC to BONK
let order_response = trading_client
    .swap_tokens(
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
        "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // BONK
        5.0,                                              // 5 USDC
        Some(2.0)                                         // 2% slippage
    )
    .await?;

println!("BONK tokens received: {}", order_response.amount_out);
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-route-swap-analysis"><a class="header" href="#multi-route-swap-analysis">Multi-Route Swap Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get detailed routing information
let quote = trading_client
    .get_quote(
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
        "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // BONK
        100.0,
        Some(1.0)
    )
    .await?;

println!("Swap route analysis:");
println!("Input: {} USDC", quote.in_amount);
println!("Output: {} BONK", quote.out_amount);
println!("Price impact: {:.2}%", quote.price_impact);
println!("Total fees: {} USDC", quote.fee);

// Analyze routing steps
for (i, step) in quote.route.iter().enumerate() {
    println!("Route step {}: {} -&gt; {} via {}", 
        i + 1, 
        step.input_mint[..8].to_string() + "...",
        step.output_mint[..8].to_string() + "...",
        step.amm
    );
    println!("  Fee: {}", step.fee_amount);
}

// Execute swap if acceptable
if quote.price_impact &lt; 3.0 {
    let order = trading_client
        .swap_tokens(
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
            100.0,
            Some(1.0)
        )
        .await?;
    
    println!("Swap completed successfully!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="swap-order-parameters"><a class="header" href="#swap-order-parameters">Swap Order Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>from_mint</code></td><td><code>&amp;str</code></td><td>Source token mint address</td><td>Required</td></tr>
<tr><td><code>to_mint</code></td><td><code>&amp;str</code></td><td>Destination token mint address</td><td>Required</td></tr>
<tr><td><code>amount</code></td><td><code>f64</code></td><td>Amount of source tokens</td><td>Required</td></tr>
<tr><td><code>slippage_percent</code></td><td><code>Option&lt;f64&gt;</code></td><td>Maximum slippage tolerance</td><td>5.0%</td></tr>
<tr><td><code>priority_fee</code></td><td><code>Option&lt;f64&gt;</code></td><td>Priority fee in SOL</td><td>Auto-calculated</td></tr>
</tbody></table>
</div>
<h2 id="price-quotes"><a class="header" href="#price-quotes">Price Quotes</a></h2>
<p>Always get a quote before executing trades to understand pricing, fees, and market impact.</p>
<h3 id="getting-accurate-quotes"><a class="header" href="#getting-accurate-quotes">Getting Accurate Quotes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get a comprehensive quote
let quote = trading_client
    .get_quote(
        "So11111111111111111111111111111111111111112",   // SOL
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
        1.0,        // 1 SOL
        Some(0.5)   // 0.5% slippage
    )
    .await?;

println!("Quote Analysis:");
println!("  Input: {} SOL", quote.in_amount);
println!("  Output: {} USDC", quote.out_amount);
println!("  Exchange rate: {} USDC per SOL", quote.out_amount / quote.in_amount);
println!("  Price impact: {:.3}%", quote.price_impact);
println!("  Platform fee: {} SOL", quote.fee);
<span class="boring">}</span></code></pre></pre>
<h3 id="quote-response-structure"><a class="header" href="#quote-response-structure">Quote Response Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QuoteResponse {
    pub input_mint: String,     // Source token mint
    pub output_mint: String,    // Destination token mint
    pub in_amount: f64,         // Input amount
    pub out_amount: f64,        // Expected output amount
    pub price_impact: f64,      // Price impact percentage
    pub fee: f64,               // Total fees
    pub route: Vec&lt;RouteStep&gt;,  // Routing information
}

pub struct RouteStep {
    pub amm: String,            // AMM/DEX name (e.g., "Raydium", "Orca")
    pub input_mint: String,     // Input token for this step
    pub output_mint: String,    // Output token for this step
    pub in_amount: f64,         // Input amount for this step
    pub out_amount: f64,        // Output amount for this step
    pub fee_amount: f64,        // Fee for this step
}
<span class="boring">}</span></code></pre></pre>
<h2 id="slippage-and-mev-protection"><a class="header" href="#slippage-and-mev-protection">Slippage and MEV Protection</a></h2>
<p>Axiom Trade includes built-in protection against slippage and MEV attacks.</p>
<h3 id="understanding-slippage"><a class="header" href="#understanding-slippage">Understanding Slippage</a></h3>
<p>Slippage occurs when the actual execution price differs from the expected price due to market movement or liquidity constraints.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conservative slippage for large trades
let large_trade_slippage = 0.1; // 0.1% for liquid tokens

// Standard slippage for normal trades
let normal_slippage = 0.5; // 0.5%

// Higher slippage for small/illiquid tokens
let high_slippage = 2.0; // 2.0%

// Example with different slippage scenarios
async fn execute_trade_with_slippage_analysis(
    client: &amp;mut TradingClient,
    token_mint: &amp;str,
    amount: f64
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    
    // Test different slippage levels
    let slippage_levels = vec![0.1, 0.5, 1.0, 2.0];
    
    for slippage in slippage_levels {
        match client.get_quote(
            "So11111111111111111111111111111111111111112",
            token_mint,
            amount,
            Some(slippage)
        ).await {
            Ok(quote) =&gt; {
                println!("Slippage {:.1}%: Output {} tokens, Impact {:.3}%", 
                    slippage, quote.out_amount, quote.price_impact);
            }
            Err(e) =&gt; {
                println!("Slippage {:.1}%: Failed - {}", slippage, e);
            }
        }
    }
    
    // Execute with conservative slippage
    let order = client.buy_token(token_mint, amount, Some(0.5)).await?;
    println!("Trade executed with 0.5% slippage tolerance");
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mev-protection"><a class="header" href="#mev-protection">MEV Protection</a></h3>
<p>Axiom Trade automatically implements MEV protection strategies:</p>
<ol>
<li><strong>Private Mempool</strong>: Transactions are routed through private mempools</li>
<li><strong>Bundle Protection</strong>: Orders are bundled to prevent front-running</li>
<li><strong>Optimal Timing</strong>: Executes at optimal times to minimize MEV exposure</li>
<li><strong>Route Optimization</strong>: Uses routes that minimize MEV vulnerability</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MEV protection is automatically enabled
// No additional configuration required

let order = trading_client
    .buy_token(
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        1.0,
        Some(0.5)
    )
    .await?;

// The system automatically:
// - Routes through protected channels
// - Uses optimal AMM combinations
// - Implements timing strategies
// - Protects against sandwich attacks
<span class="boring">}</span></code></pre></pre>
<h2 id="order-types-and-parameters"><a class="header" href="#order-types-and-parameters">Order Types and Parameters</a></h2>
<h3 id="order-status-types"><a class="header" href="#order-status-types">Order Status Types</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum OrderStatus {
    Success,    // Order completed successfully
    Failed,     // Order failed to execute
    Pending,    // Order is being processed
    Cancelled,  // Order was cancelled
}
<span class="boring">}</span></code></pre></pre>
<h3 id="order-response-structure"><a class="header" href="#order-response-structure">Order Response Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OrderResponse {
    pub signature: String,          // Transaction signature
    pub status: OrderStatus,        // Order status
    pub transaction_type: OrderType, // Buy, Sell, or Swap
    pub token_mint: String,         // Token mint address
    pub amount_in: f64,             // Input amount
    pub amount_out: f64,            // Output amount received
    pub price_per_token: f64,       // Effective price per token
    pub total_sol: f64,             // Total SOL involved
    pub fee: f64,                   // Transaction fee
    pub timestamp: i64,             // Execution timestamp
}
<span class="boring">}</span></code></pre></pre>
<h3 id="priority-fees"><a class="header" href="#priority-fees">Priority Fees</a></h3>
<p>Priority fees help ensure faster transaction processing during network congestion.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Auto-calculated priority fee (recommended)
let order = trading_client
    .buy_token(token_mint, amount, Some(1.0))
    .await?;

// Priority fees are automatically adjusted based on:
// - Current network congestion
// - Transaction urgency
// - Historical gas patterns
// - Market volatility
<span class="boring">}</span></code></pre></pre>
<h2 id="trading-limits"><a class="header" href="#trading-limits">Trading Limits</a></h2>
<p>Understanding and respecting trading limits ensures consistent API access.</p>
<h3 id="getting-current-limits"><a class="header" href="#getting-current-limits">Getting Current Limits</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let limits = trading_client.get_trading_limits().await?;

println!("Trading Limits:");
println!("  Minimum SOL per trade: {}", limits.min_sol_amount);
println!("  Maximum SOL per trade: {}", limits.max_sol_amount);
println!("  Maximum slippage: {}%", limits.max_slippage_percent);
println!("  Default slippage: {}%", limits.default_slippage_percent);
println!("  Priority fee: {} lamports", limits.priority_fee_lamports);
<span class="boring">}</span></code></pre></pre>
<h3 id="limit-structure"><a class="header" href="#limit-structure">Limit Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TradingLimits {
    pub min_sol_amount: f64,           // Minimum SOL per trade (0.01)
    pub max_sol_amount: f64,           // Maximum SOL per trade (100.0)
    pub max_slippage_percent: f64,     // Maximum allowed slippage (50.0%)
    pub default_slippage_percent: f64, // Default slippage (5.0%)
    pub priority_fee_lamports: u64,    // Default priority fee (5000)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="respecting-limits"><a class="header" href="#respecting-limits">Respecting Limits</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn safe_trade_execution(
    client: &amp;mut TradingClient,
    token_mint: &amp;str,
    amount: f64,
    slippage: f64
) -&gt; Result&lt;OrderResponse, Box&lt;dyn std::error::Error&gt;&gt; {
    
    // Check limits before trading
    let limits = client.get_trading_limits().await?;
    
    // Validate amount
    if amount &lt; limits.min_sol_amount {
        return Err(format!("Amount {} below minimum {}", 
            amount, limits.min_sol_amount).into());
    }
    
    if amount &gt; limits.max_sol_amount {
        return Err(format!("Amount {} exceeds maximum {}", 
            amount, limits.max_sol_amount).into());
    }
    
    // Validate slippage
    let safe_slippage = if slippage &gt; limits.max_slippage_percent {
        limits.default_slippage_percent
    } else {
        slippage
    };
    
    // Execute trade
    let order = client.buy_token(token_mint, amount, Some(safe_slippage)).await?;
    Ok(order)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="transaction-simulation"><a class="header" href="#transaction-simulation">Transaction Simulation</a></h2>
<p>Simulate transactions before execution to verify expected outcomes.</p>
<h3 id="basic-simulation"><a class="header" href="#basic-simulation">Basic Simulation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: You would typically get the transaction data from a quote or prepare step
let transaction_base64 = "base64_encoded_transaction_data";

let simulation = trading_client
    .simulate_transaction(&amp;transaction_base64)
    .await?;

if simulation.success {
    println!("Simulation successful!");
    println!("Compute units consumed: {}", simulation.units_consumed);
    
    // Analyze logs for detailed information
    for log in &amp;simulation.logs {
        if log.contains("Program log:") {
            println!("  {}", log);
        }
    }
} else {
    println!("Simulation failed: {}", 
        simulation.error.unwrap_or_else(|| "Unknown error".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="simulation-response-structure"><a class="header" href="#simulation-response-structure">Simulation Response Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TransactionSimulation {
    pub success: bool,              // Whether simulation succeeded
    pub error: Option&lt;String&gt;,      // Error message if failed
    pub logs: Vec&lt;String&gt;,          // Transaction logs
    pub units_consumed: u64,        // Compute units used
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<p>Comprehensive error handling for robust trading applications.</p>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TradingError {
    AuthError(AuthError),           // Authentication issues
    NetworkError(reqwest::Error),   // Network connectivity problems
    InvalidTokenMint(String),       // Invalid token address
    InsufficientBalance(String),    // Not enough tokens/SOL
    SlippageExceeded(String),       // Slippage tolerance exceeded
    TransactionFailed(String),      // Transaction execution failed
    ApiError(String),               // General API errors
    ParsingError(String),           // Data parsing issues
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-examples"><a class="header" href="#error-handling-examples">Error Handling Examples</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::trading::TradingError;

async fn handle_trading_errors(
    client: &amp;mut TradingClient
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    
    match client.buy_token("invalid_mint", 0.1, Some(1.0)).await {
        Ok(order) =&gt; {
            println!("Trade successful: {}", order.signature);
        }
        Err(TradingError::InvalidTokenMint(msg)) =&gt; {
            println!("Invalid token address: {}", msg);
        }
        Err(TradingError::InsufficientBalance(msg)) =&gt; {
            println!("Insufficient balance: {}", msg);
        }
        Err(TradingError::SlippageExceeded(msg)) =&gt; {
            println!("Slippage exceeded: {}", msg);
            // Retry with higher slippage tolerance
        }
        Err(TradingError::NetworkError(e)) =&gt; {
            println!("Network error: {}", e);
            // Implement retry logic
        }
        Err(e) =&gt; {
            println!("Other error: {}", e);
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="retry-logic-1"><a class="header" href="#retry-logic-1">Retry Logic</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn execute_with_retry(
    client: &amp;mut TradingClient,
    token_mint: &amp;str,
    amount: f64,
    max_retries: u32
) -&gt; Result&lt;OrderResponse, TradingError&gt; {
    
    let mut attempts = 0;
    
    loop {
        match client.buy_token(token_mint, amount, Some(1.0)).await {
            Ok(order) =&gt; return Ok(order),
            Err(TradingError::NetworkError(_)) if attempts &lt; max_retries =&gt; {
                attempts += 1;
                println!("Network error, retrying ({}/{})", attempts, max_retries);
                sleep(Duration::from_millis(1000 * attempts as u64)).await;
            }
            Err(TradingError::SlippageExceeded(_)) if attempts &lt; max_retries =&gt; {
                attempts += 1;
                let higher_slippage = 1.0 + (0.5 * attempts as f64);
                println!("Retrying with {}% slippage", higher_slippage);
                
                match client.buy_token(token_mint, amount, Some(higher_slippage)).await {
                    Ok(order) =&gt; return Ok(order),
                    Err(e) =&gt; {
                        if attempts &gt;= max_retries {
                            return Err(e);
                        }
                    }
                }
            }
            Err(e) =&gt; return Err(e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="1-always-get-quotes-first"><a class="header" href="#1-always-get-quotes-first">1. Always Get Quotes First</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good practice: Check quote before trading
let quote = trading_client.get_quote(from_mint, to_mint, amount, Some(1.0)).await?;

if quote.price_impact &lt; 2.0 {  // Acceptable price impact
    let order = trading_client.swap_tokens(from_mint, to_mint, amount, Some(1.0)).await?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-use-appropriate-slippage"><a class="header" href="#2-use-appropriate-slippage">2. Use Appropriate Slippage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slippage guidelines by token type
let slippage = match token_type {
    "major" =&gt; 0.1,    // BTC, ETH, SOL, USDC - very liquid
    "popular" =&gt; 0.5,  // Popular tokens with good liquidity
    "standard" =&gt; 1.0, // Standard tokens
    "small" =&gt; 2.0,    // Smaller tokens with less liquidity
    _ =&gt; 5.0,          // Very small or new tokens
};
<span class="boring">}</span></code></pre></pre>
<h3 id="3-implement-proper-error-handling"><a class="header" href="#3-implement-proper-error-handling">3. Implement Proper Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn robust_trading_function(
    client: &amp;mut TradingClient,
    token_mint: &amp;str,
    amount: f64
) -&gt; Result&lt;String, String&gt; {
    
    // Validate inputs
    if amount &lt;= 0.0 {
        return Err("Amount must be positive".to_string());
    }
    
    // Check trading limits
    let limits = client.get_trading_limits().await
        .map_err(|e| format!("Failed to get limits: {}", e))?;
    
    if amount &lt; limits.min_sol_amount || amount &gt; limits.max_sol_amount {
        return Err(format!("Amount {} outside limits [{}, {}]", 
            amount, limits.min_sol_amount, limits.max_sol_amount));
    }
    
    // Get quote first
    let quote = client.get_quote(
        "So11111111111111111111111111111111111111112",
        token_mint,
        amount,
        Some(1.0)
    ).await.map_err(|e| format!("Failed to get quote: {}", e))?;
    
    // Check price impact
    if quote.price_impact &gt; 5.0 {
        return Err(format!("Price impact too high: {:.2}%", quote.price_impact));
    }
    
    // Execute trade
    let order = client.buy_token(token_mint, amount, Some(1.0)).await
        .map_err(|e| format!("Trade failed: {}", e))?;
    
    Ok(order.signature)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-monitor-transaction-status"><a class="header" href="#4-monitor-transaction-status">4. Monitor Transaction Status</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute_and_monitor(
    client: &amp;mut TradingClient,
    token_mint: &amp;str,
    amount: f64
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    
    let order = client.buy_token(token_mint, amount, Some(1.0)).await?;
    
    match order.status {
        OrderStatus::Success =&gt; {
            println!("✅ Trade completed successfully");
            println!("   Signature: {}", order.signature);
            println!("   Tokens received: {}", order.amount_out);
            println!("   Fee paid: {}", order.fee);
        }
        OrderStatus::Pending =&gt; {
            println!("⏳ Trade is pending confirmation");
            println!("   Monitor signature: {}", order.signature);
        }
        OrderStatus::Failed =&gt; {
            println!("❌ Trade failed");
            return Err("Trade execution failed".into());
        }
        OrderStatus::Cancelled =&gt; {
            println!("🚫 Trade was cancelled");
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-implement-rate-limiting"><a class="header" href="#5-implement-rate-limiting">5. Implement Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration, Instant};

struct RateLimiter {
    last_request: Instant,
    min_interval: Duration,
}

impl RateLimiter {
    fn new(requests_per_second: f64) -&gt; Self {
        Self {
            last_request: Instant::now(),
            min_interval: Duration::from_secs_f64(1.0 / requests_per_second),
        }
    }
    
    async fn wait_if_needed(&amp;mut self) {
        let elapsed = self.last_request.elapsed();
        if elapsed &lt; self.min_interval {
            sleep(self.min_interval - elapsed).await;
        }
        self.last_request = Instant::now();
    }
}

// Usage
let mut rate_limiter = RateLimiter::new(2.0); // 2 requests per second

for trade in trades {
    rate_limiter.wait_if_needed().await;
    let result = trading_client.buy_token(&amp;trade.mint, trade.amount, Some(1.0)).await;
    // Handle result...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<h3 id="1-token-validation"><a class="header" href="#1-token-validation">1. Token Validation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_token_mint(mint: &amp;str) -&gt; Result&lt;(), String&gt; {
    // Check length
    if mint.len() &lt; 32 || mint.len() &gt; 44 {
        return Err("Invalid mint address length".to_string());
    }
    
    // Check characters
    if !mint.chars().all(|c| c.is_ascii_alphanumeric()) {
        return Err("Invalid characters in mint address".to_string());
    }
    
    // Add known token validation
    let known_scam_tokens = vec![
        // Add known scam token addresses
    ];
    
    if known_scam_tokens.contains(&amp;mint) {
        return Err("Token flagged as potential scam".to_string());
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-amount-validation"><a class="header" href="#2-amount-validation">2. Amount Validation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_trade_amount(amount: f64, balance: f64) -&gt; Result&lt;(), String&gt; {
    if amount &lt;= 0.0 {
        return Err("Amount must be positive".to_string());
    }
    
    if amount.is_nan() || amount.is_infinite() {
        return Err("Invalid amount value".to_string());
    }
    
    if amount &gt; balance * 0.95 {  // Keep 5% buffer
        return Err("Amount too close to total balance".to_string());
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-slippage-protection"><a class="header" href="#3-slippage-protection">3. Slippage Protection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_safe_slippage(
    amount: f64,
    token_liquidity: f64,
    market_volatility: f64
) -&gt; f64 {
    let base_slippage = 0.5; // 0.5% base
    
    // Adjust for trade size relative to liquidity
    let size_impact = (amount / token_liquidity) * 100.0;
    let size_adjustment = if size_impact &gt; 1.0 { size_impact } else { 0.0 };
    
    // Adjust for market volatility
    let volatility_adjustment = market_volatility * 0.5;
    
    // Cap at reasonable maximum
    let total_slippage = base_slippage + size_adjustment + volatility_adjustment;
    total_slippage.min(5.0) // Never exceed 5%
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive guide covers all aspects of trading operations with the Axiom Trade API. Always test with small amounts first and implement proper error handling and security measures in production applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="market-data"><a class="header" href="#market-data">Market Data</a></h1>
<p>The Market Data API provides comprehensive access to real-time and historical market information for Solana tokens. This includes trending tokens, price feeds, token analysis, market statistics, and search functionality.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>The <code>MarketDataClient</code> offers a complete suite of market data operations:</p>
<ul>
<li><strong>Trending Tokens</strong>: Get tokens trending across different timeframes</li>
<li><strong>Token Information</strong>: Detailed token metadata and analysis</li>
<li><strong>Price Feeds</strong>: Real-time and historical price data</li>
<li><strong>Market Statistics</strong>: Overall market metrics and trends</li>
<li><strong>Token Search</strong>: Find tokens by name, symbol, or address</li>
<li><strong>Chart Data</strong>: OHLCV candle data for technical analysis</li>
</ul>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::api::market_data::MarketDataClient;
use axiomtrade_rs::models::market::TimePeriod;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut client = MarketDataClient::new()?;
    
    // Get trending tokens
    let trending = client.get_trending_tokens(TimePeriod::TwentyFourHours).await?;
    
    println!("Top trending token: {} - {}", 
        trending[0].symbol, 
        trending[0].name
    );
    
    Ok(())
}</code></pre></pre>
<h2 id="trending-tokens"><a class="header" href="#trending-tokens">Trending Tokens</a></h2>
<p>Get tokens that are currently trending based on volume, price movement, and trading activity.</p>
<h3 id="get-trending-tokens"><a class="header" href="#get-trending-tokens">Get Trending Tokens</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::models::market::TimePeriod;

// Get 24-hour trending tokens
let trending = client.get_trending_tokens(TimePeriod::TwentyFourHours).await?;

for (i, token) in trending.iter().take(10).enumerate() {
    println!("{}. {} ({}) - ${:.8}", 
        i + 1,
        token.symbol,
        token.name,
        token.price_usd
    );
    println!("   Change: {:.2}% | Volume: ${:.2}", 
        token.price_change_24h,
        token.volume_24h
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="time-periods"><a class="header" href="#time-periods">Time Periods</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Available time periods
TimePeriod::OneHour        // 1h trending
TimePeriod::TwentyFourHours // 24h trending  
TimePeriod::SevenDays      // 7d trending
TimePeriod::ThirtyDays     // 30d trending
<span class="boring">}</span></code></pre></pre>
<h3 id="trending-token-data-structure"><a class="header" href="#trending-token-data-structure">Trending Token Data Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TrendingToken {
    pub mint_address: String,      // Token mint address
    pub symbol: String,            // Token symbol (e.g., "BONK")
    pub name: String,              // Full token name
    pub price_usd: f64,           // Current price in USD
    pub price_change_24h: f64,    // 24h price change percentage
    pub price_change_7d: f64,     // 7d price change percentage  
    pub volume_24h: f64,          // 24h trading volume
    pub market_cap: f64,          // Market capitalization
    pub holders: u64,             // Number of token holders
    pub rank: u32,                // Trending rank
    pub logo_uri: Option&lt;String&gt;, // Token logo URL
}
<span class="boring">}</span></code></pre></pre>
<h2 id="token-information"><a class="header" href="#token-information">Token Information</a></h2>
<p>Get detailed information about specific tokens including metadata, liquidity, and protocol details.</p>
<h3 id="get-token-info-by-symbol"><a class="header" href="#get-token-info-by-symbol">Get Token Info by Symbol</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get detailed token information
let token_info = client.get_token_info("BONK").await?;

println!("Token: {} ({})", token_info.name, token_info.symbol);
println!("Decimals: {}", token_info.decimals);
println!("Supply: {:.2}", token_info.supply);
println!("Liquidity SOL: {:.2}", token_info.liquidity_sol);
println!("Protocol: {}", token_info.protocol);
<span class="boring">}</span></code></pre></pre>
<h3 id="get-token-info-by-address"><a class="header" href="#get-token-info-by-address">Get Token Info by Address</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get token info using mint or pair address
let address = "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"; // Example BONK mint
let token_info = client.get_token_info_by_address(address).await?;

println!("Found token: {} at address {}", 
    token_info.symbol, 
    token_info.mint_address
);
<span class="boring">}</span></code></pre></pre>
<h3 id="token-information-data-structure"><a class="header" href="#token-information-data-structure">Token Information Data Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TokenInfo {
    pub mint_address: String,         // Token mint address
    pub symbol: String,               // Token symbol
    pub name: String,                 // Token name
    pub decimals: u8,                // Token decimals
    pub supply: f64,                 // Total supply
    pub liquidity_sol: f64,          // SOL liquidity
    pub liquidity_token: f64,        // Token liquidity
    pub pair_address: String,        // Pair contract address
    pub protocol: String,            // DEX protocol (Raydium, etc.)
    pub protocol_details: Option&lt;Value&gt;, // Additional protocol data
    pub created_at: String,          // Creation timestamp
    pub logo_uri: Option&lt;String&gt;,    // Token logo URL
    pub mint_authority: Option&lt;String&gt;, // Mint authority
    pub freeze_authority: Option&lt;String&gt;, // Freeze authority
    pub lp_burned: f64,              // LP tokens burned percentage
}
<span class="boring">}</span></code></pre></pre>
<h2 id="token-analysis"><a class="header" href="#token-analysis">Token Analysis</a></h2>
<p>Get creator analysis and risk assessment for tokens.</p>
<h3 id="get-token-analysis"><a class="header" href="#get-token-analysis">Get Token Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get creator analysis and related tokens
let analysis = client.get_token_analysis("BONK").await?;

println!("Creator Risk Level: {}", analysis.creator_risk_level);
println!("Creator Rug Count: {}", analysis.creator_rug_count);
println!("Creator Token Count: {}", analysis.creator_token_count);

// Show related tokens from same creator
println!("Related high market cap tokens:");
for token in &amp;analysis.top_market_cap_coins {
    println!("  {} - ${:.2} market cap", 
        token.symbol, 
        token.market_cap
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="token-analysis-data-structure"><a class="header" href="#token-analysis-data-structure">Token Analysis Data Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TokenAnalysis {
    pub creator_risk_level: String,           // Risk assessment
    pub creator_rug_count: u32,              // Number of rugs by creator
    pub creator_token_count: u32,            // Total tokens by creator
    pub top_market_cap_coins: Vec&lt;RelatedToken&gt;, // High cap related tokens
    pub top_og_coins: Vec&lt;RelatedToken&gt;,     // Original related tokens
}

pub struct RelatedToken {
    pub mint_address: String,        // Token mint address
    pub symbol: String,              // Token symbol
    pub name: String,                // Token name
    pub pair_address: String,        // Pair address
    pub market_cap: f64,            // Market capitalization
    pub created_at: String,         // Creation date
    pub last_trade_time: String,    // Last trade timestamp
    pub image: Option&lt;String&gt;,      // Token image URL
    pub migrated: bool,             // Migration status
    pub bonding_curve_percent: f64, // Bonding curve completion
}
<span class="boring">}</span></code></pre></pre>
<h2 id="price-feeds"><a class="header" href="#price-feeds">Price Feeds</a></h2>
<p>Get current and historical price data for tokens.</p>
<h3 id="current-price"><a class="header" href="#current-price">Current Price</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current price for a token
let mint = "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263";
let price = client.get_token_price(mint).await?;

println!("Current price: ${:.8} USD", price.price_usd);
println!("Price in SOL: {:.6}", price.price_sol);
println!("Last updated: {}", price.timestamp);
<span class="boring">}</span></code></pre></pre>
<h3 id="historical-price-feed"><a class="header" href="#historical-price-feed">Historical Price Feed</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get historical price data
let price_feed = client.get_price_feed(mint, TimePeriod::TwentyFourHours).await?;

println!("Price history for {}:", price_feed.mint_address);
for point in price_feed.prices.iter().take(10) {
    println!("  ${:.8} at {} (Volume: ${:.2})", 
        point.price_usd,
        point.timestamp,
        point.volume
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-prices"><a class="header" href="#batch-prices">Batch Prices</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get prices for multiple tokens at once
let mints = vec![
    "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263".to_string(), // BONK
    "So11111111111111111111111111111111111111112".to_string(),      // SOL
];

let prices = client.get_batch_prices(&amp;mints).await?;

for price in prices {
    println!("{}: ${:.6}", price.mint_address, price.price_usd);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="price-data-structures"><a class="header" href="#price-data-structures">Price Data Structures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PriceData {
    pub mint_address: String,    // Token mint address
    pub price_usd: f64,         // Price in USD
    pub price_sol: f64,         // Price in SOL
    pub timestamp: i64,         // Unix timestamp
}

pub struct PriceFeed {
    pub mint_address: String,       // Token mint address
    pub prices: Vec&lt;PricePoint&gt;,   // Historical price points
}

pub struct PricePoint {
    pub timestamp: i64,    // Unix timestamp
    pub price_usd: f64,   // Price in USD
    pub price_sol: f64,   // Price in SOL
    pub volume: f64,      // Trading volume
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chart-data"><a class="header" href="#chart-data">Chart Data</a></h2>
<p>Get OHLCV candle data for technical analysis and charting.</p>
<h3 id="get-token-chart"><a class="header" href="#get-token-chart">Get Token Chart</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::models::market::ChartTimeframe;

// Get 1-hour candles for a token
let chart = client.get_token_chart(
    mint,
    ChartTimeframe::OneHour,
    Some(100) // Limit to 100 candles
).await?;

println!("Chart data for {} ({})", chart.mint_address, chart.timeframe);

for candle in chart.candles.iter().take(10) {
    println!("  O: {:.6} H: {:.6} L: {:.6} C: {:.6} V: {:.2}",
        candle.open,
        candle.high,
        candle.low,
        candle.close,
        candle.volume
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chart-timeframes"><a class="header" href="#chart-timeframes">Chart Timeframes</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ChartTimeframe::OneMinute      // 1m candles
ChartTimeframe::FiveMinutes    // 5m candles
ChartTimeframe::FifteenMinutes // 15m candles
ChartTimeframe::OneHour        // 1h candles
ChartTimeframe::FourHours      // 4h candles
ChartTimeframe::OneDay         // 1d candles
ChartTimeframe::OneWeek        // 1w candles
<span class="boring">}</span></code></pre></pre>
<h3 id="chart-data-structures"><a class="header" href="#chart-data-structures">Chart Data Structures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TokenChart {
    pub mint_address: String,         // Token mint address
    pub timeframe: ChartTimeframe,    // Chart timeframe
    pub candles: Vec&lt;Candle&gt;,        // OHLCV candles
}

pub struct Candle {
    pub timestamp: i64,    // Candle timestamp
    pub open: f64,        // Opening price
    pub high: f64,        // Highest price
    pub low: f64,         // Lowest price
    pub close: f64,       // Closing price
    pub volume: f64,      // Trading volume
}
<span class="boring">}</span></code></pre></pre>
<h2 id="market-statistics"><a class="header" href="#market-statistics">Market Statistics</a></h2>
<p>Get overall market metrics and trends.</p>
<h3 id="get-market-stats"><a class="header" href="#get-market-stats">Get Market Stats</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get overall market statistics
let stats = client.get_market_stats().await?;

println!("Market Statistics:");
println!("  Total 24h Volume: ${:.2}", stats.total_volume_24h);
println!("  Total Market Cap: ${:.2}", stats.total_market_cap);
println!("  Active Traders: {}", stats.active_traders_24h);
println!("  Total Transactions: {}", stats.total_transactions_24h);
println!("  Trending Tokens: {}", stats.trending_tokens_count);
println!("  New Tokens (24h): {}", stats.new_tokens_24h);
<span class="boring">}</span></code></pre></pre>
<h3 id="market-statistics-data-structure"><a class="header" href="#market-statistics-data-structure">Market Statistics Data Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MarketStats {
    pub total_volume_24h: f64,         // Total 24h trading volume
    pub total_market_cap: f64,         // Total market capitalization
    pub active_traders_24h: u64,       // Active traders in 24h
    pub total_transactions_24h: u64,   // Total transactions in 24h
    pub trending_tokens_count: u32,    // Number of trending tokens
    pub new_tokens_24h: u32,          // New tokens launched in 24h
}
<span class="boring">}</span></code></pre></pre>
<h2 id="token-search"><a class="header" href="#token-search">Token Search</a></h2>
<p>Search for tokens by name, symbol, or partial matches.</p>
<h3 id="search-tokens"><a class="header" href="#search-tokens">Search Tokens</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Search for tokens
let results = client.search_tokens("bonk", Some(10)).await?;

println!("Search results for 'bonk':");
for (i, token) in results.results.iter().enumerate() {
    println!("{}. {} ({}) - ${:.8}", 
        i + 1,
        token.symbol,
        token.name,
        token.market_cap
    );
    
    if let Some(website) = &amp;token.website {
        println!("   Website: {}", website);
    }
    
    if let Some(twitter) = &amp;token.twitter {
        println!("   Twitter: {}", twitter);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="search-data-structures"><a class="header" href="#search-data-structures">Search Data Structures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TokenSearch {
    pub query: String,                      // Original search query
    pub results: Vec&lt;TokenSearchResult&gt;,   // Search results
}

pub struct TokenSearchResult {
    pub mint_address: String,        // Token mint address
    pub symbol: String,              // Token symbol
    pub name: String,                // Token name
    pub logo_uri: Option&lt;String&gt;,    // Token logo URL
    pub decimals: u8,               // Token decimals
    pub supply: f64,                // Total supply
    pub liquidity_sol: f64,         // SOL liquidity
    pub market_cap: f64,            // Market capitalization
    pub volume_sol: f64,            // SOL volume
    pub created_at: String,         // Creation timestamp
    pub pair_address: String,       // Pair address
    pub protocol: String,           // DEX protocol
    pub website: Option&lt;String&gt;,    // Project website
    pub twitter: Option&lt;String&gt;,    // Twitter handle
    pub telegram: Option&lt;String&gt;,   // Telegram channel
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<p>The Market Data API uses comprehensive error handling for robust applications.</p>
<h3 id="error-types-1"><a class="header" href="#error-types-1">Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::market_data::MarketDataError;

match client.get_trending_tokens(TimePeriod::TwentyFourHours).await {
    Ok(tokens) =&gt; {
        println!("Found {} trending tokens", tokens.len());
    }
    Err(MarketDataError::AuthError(_)) =&gt; {
        println!("Authentication failed - check credentials");
    }
    Err(MarketDataError::TokenNotFound(symbol)) =&gt; {
        println!("Token not found: {}", symbol);
    }
    Err(MarketDataError::InvalidTokenMint(mint)) =&gt; {
        println!("Invalid mint address: {}", mint);
    }
    Err(MarketDataError::NetworkError(_)) =&gt; {
        println!("Network error - check connection");
    }
    Err(MarketDataError::ApiError(msg)) =&gt; {
        println!("API error: {}", msg);
    }
    Err(e) =&gt; {
        println!("Unexpected error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here's a comprehensive example showing various market data operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::api::market_data::MarketDataClient;
use axiomtrade_rs::models::market::{TimePeriod, ChartTimeframe};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize client
    let mut client = MarketDataClient::new()?;
    
    // Get trending tokens
    println!("=== TRENDING TOKENS ===");
    let trending = client.get_trending_tokens(TimePeriod::TwentyFourHours).await?;
    
    for (i, token) in trending.iter().take(5).enumerate() {
        println!("{}. {} - ${:.8} ({:.2}%)", 
            i + 1,
            token.symbol,
            token.price_usd,
            token.price_change_24h
        );
    }
    
    // Get detailed info for top token
    if let Some(top_token) = trending.first() {
        println!("\n=== TOKEN DETAILS ===");
        let token_info = client.get_token_info(&amp;top_token.symbol).await?;
        
        println!("Name: {}", token_info.name);
        println!("Symbol: {}", token_info.symbol);
        println!("Supply: {:.2}", token_info.supply);
        println!("Liquidity: {:.2} SOL", token_info.liquidity_sol);
        
        // Get price history
        println!("\n=== PRICE HISTORY ===");
        let price_feed = client.get_price_feed(
            &amp;token_info.mint_address, 
            TimePeriod::TwentyFourHours
        ).await?;
        
        println!("Last 5 price points:");
        for point in price_feed.prices.iter().rev().take(5) {
            println!("  ${:.8} (Volume: {:.2})", 
                point.price_usd, 
                point.volume
            );
        }
        
        // Get chart data
        println!("\n=== CHART DATA ===");
        let chart = client.get_token_chart(
            &amp;token_info.mint_address,
            ChartTimeframe::OneHour,
            Some(5)
        ).await?;
        
        println!("Recent candles:");
        for candle in &amp;chart.candles {
            println!("  OHLC: {:.6}/{:.6}/{:.6}/{:.6}", 
                candle.open, 
                candle.high, 
                candle.low, 
                candle.close
            );
        }
    }
    
    // Get market statistics
    println!("\n=== MARKET STATS ===");
    let stats = client.get_market_stats().await?;
    println!("Total Volume: ${:.2}", stats.total_volume_24h);
    println!("Active Traders: {}", stats.active_traders_24h);
    
    // Search for tokens
    println!("\n=== TOKEN SEARCH ===");
    let search_results = client.search_tokens("sol", Some(3)).await?;
    
    for result in &amp;search_results.results {
        println!("{} ({}) - ${:.2} market cap", 
            result.symbol,
            result.name,
            result.market_cap
        );
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="rate-limiting-1"><a class="header" href="#rate-limiting-1">Rate Limiting</a></h3>
<p>The API includes built-in rate limiting. For high-frequency applications:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

// Add delays between requests for bulk operations
for symbol in token_symbols {
    let info = client.get_token_info(&amp;symbol).await?;
    // Process info...
    
    sleep(Duration::from_millis(100)).await; // Prevent rate limiting
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-recovery-1"><a class="header" href="#error-recovery-1">Error Recovery</a></h3>
<p>Implement retry logic for network failures:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn get_trending_with_retry(
    client: &amp;mut MarketDataClient,
    period: TimePeriod,
    max_retries: u32
) -&gt; Result&lt;Vec&lt;TrendingToken&gt;, MarketDataError&gt; {
    for attempt in 0..max_retries {
        match client.get_trending_tokens(period.clone()).await {
            Ok(tokens) =&gt; return Ok(tokens),
            Err(MarketDataError::NetworkError(_)) if attempt &lt; max_retries - 1 =&gt; {
                sleep(Duration::from_millis(1000 * (attempt + 1) as u64)).await;
                continue;
            }
            Err(e) =&gt; return Err(e),
        }
    }
    
    unreachable!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p>Use batch endpoints when possible for better performance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of multiple individual calls
// let price1 = client.get_token_price(mint1).await?;
// let price2 = client.get_token_price(mint2).await?;

// Use batch endpoint
let mints = vec![mint1.to_string(), mint2.to_string()];
let prices = client.get_batch_prices(&amp;mints).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="data-validation"><a class="header" href="#data-validation">Data Validation</a></h3>
<p>Always validate mint addresses before API calls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_valid_mint_address(address: &amp;str) -&gt; bool {
    address.len() &gt;= 32 &amp;&amp; 
    address.len() &lt;= 44 &amp;&amp; 
    address.chars().all(|c| c.is_ascii_alphanumeric())
}

if is_valid_mint_address(&amp;mint_address) {
    let price = client.get_token_price(&amp;mint_address).await?;
} else {
    println!("Invalid mint address format");
}
<span class="boring">}</span></code></pre></pre>
<p>The Market Data API provides comprehensive access to Solana token market information, enabling developers to build sophisticated trading applications, market analysis tools, and portfolio management systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-streaming"><a class="header" href="#websocket-streaming">WebSocket Streaming</a></h1>
<p>The Axiom Trade Rust client provides comprehensive WebSocket support for real-time data streaming. The WebSocket module handles authentication, connection management, automatic reconnection, and provides a flexible message handling system.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>The WebSocket implementation consists of three main components:</p>
<ul>
<li><strong>WebSocketClient</strong>: Core client for managing connections and subscriptions</li>
<li><strong>MessageHandler</strong>: Trait for processing incoming messages</li>
<li><strong>Message Types</strong>: Structured data types for different streaming data</li>
</ul>
<h2 id="basic-websocket-connection"><a class="header" href="#basic-websocket-connection">Basic WebSocket Connection</a></h2>
<h3 id="setting-up-a-connection"><a class="header" href="#setting-up-a-connection">Setting Up a Connection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::websocket::{WebSocketClient, MessageHandler, WebSocketMessage};
use async_trait::async_trait;
use std::sync::Arc;

// Create a message handler
struct MyMessageHandler;

#[async_trait]
impl MessageHandler for MyMessageHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                println!("Market Update: {} - ${:.6}", update.symbol, update.price_usd);
            }
            _ =&gt; {}
        }
    }

    async fn on_connected(&amp;self, session_id: String) {
        println!("Connected with session: {}", session_id);
    }

    async fn on_disconnected(&amp;self, reason: String) {
        println!("Disconnected: {}", reason);
    }

    async fn on_error(&amp;self, error: String) {
        println!("Error: {}", error);
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create WebSocket client
    let handler = Arc::new(MyMessageHandler);
    let mut ws_client = WebSocketClient::new(handler)?;
    
    // Connect to WebSocket
    ws_client.connect().await?;
    
    // Subscribe to data feeds
    ws_client.subscribe_new_tokens().await?;
    
    // Keep connection alive
    tokio::time::sleep(std::time::Duration::from_secs(30)).await;
    
    // Disconnect gracefully
    ws_client.disconnect().await;
    
    Ok(())
}</code></pre></pre>
<h2 id="regional-connection-options"><a class="header" href="#regional-connection-options">Regional Connection Options</a></h2>
<p>The WebSocket client supports multiple regional endpoints for optimal latency:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::websocket::{WebSocketClient, Region};

// Create client with specific region
let handler = Arc::new(MyMessageHandler);
let mut ws_client = WebSocketClient::with_region(handler, Region::USWest)?;

// Available regions:
// - Region::USWest
// - Region::USCentral  
// - Region::USEast
// - Region::EUWest
// - Region::EUCentral
// - Region::EUEast
// - Region::Asia
// - Region::Australia
// - Region::Global (default)
<span class="boring">}</span></code></pre></pre>
<h2 id="messagehandler-trait-implementation"><a class="header" href="#messagehandler-trait-implementation">MessageHandler Trait Implementation</a></h2>
<p>The <code>MessageHandler</code> trait defines how your application processes incoming WebSocket messages:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait MessageHandler: Send + Sync {
    /// Handles incoming WebSocket messages
    async fn handle_message(&amp;self, message: WebSocketMessage);
    
    /// Called when connection is established
    async fn on_connected(&amp;self, session_id: String);
    
    /// Called when connection is lost
    async fn on_disconnected(&amp;self, reason: String);
    
    /// Called when an error occurs
    async fn on_error(&amp;self, error: String);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-message-handler-example"><a class="header" href="#advanced-message-handler-example">Advanced Message Handler Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::RwLock;
use std::collections::HashMap;

struct AdvancedMessageHandler {
    price_data: Arc&lt;RwLock&lt;HashMap&lt;String, f64&gt;&gt;&gt;,
    order_book: Arc&lt;RwLock&lt;HashMap&lt;String, OrderBookData&gt;&gt;&gt;,
}

impl AdvancedMessageHandler {
    fn new() -&gt; Self {
        Self {
            price_data: Arc::new(RwLock::new(HashMap::new())),
            order_book: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    async fn get_latest_price(&amp;self, token: &amp;str) -&gt; Option&lt;f64&gt; {
        self.price_data.read().await.get(token).copied()
    }
}

#[async_trait]
impl MessageHandler for AdvancedMessageHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                // Store price data
                let mut prices = self.price_data.write().await;
                prices.insert(update.symbol.clone(), update.price_usd);
                
                // Process price alerts
                if update.price_change_24h &gt; 10.0 {
                    println!("🚀 {} is up {:.2}% in 24h!", 
                        update.symbol, update.price_change_24h);
                }
            }
            
            WebSocketMessage::OrderUpdate(order) =&gt; {
                println!("Order {} status: {:?}", order.order_id, order.status);
                
                if let Some(tx_hash) = &amp;order.transaction_hash {
                    println!("Transaction: {}", tx_hash);
                }
            }
            
            WebSocketMessage::TradeUpdate(trade) =&gt; {
                println!("Trade executed: {} {} at ${:.6}",
                    trade.amount, trade.token_mint, trade.price);
            }
            
            WebSocketMessage::BalanceUpdate(balance) =&gt; {
                println!("Portfolio value: ${:.2}", balance.total_value_usd);
                for token in &amp;balance.token_balances {
                    println!("  {}: {} (${:.2})", 
                        token.symbol, token.amount, token.value_usd);
                }
            }
            
            WebSocketMessage::Error { code, message } =&gt; {
                eprintln!("WebSocket error {}: {}", code, message);
            }
            
            _ =&gt; {}
        }
    }
    
    async fn on_connected(&amp;self, session_id: String) {
        println!("✅ WebSocket connected! Session: {}", session_id);
    }
    
    async fn on_disconnected(&amp;self, reason: String) {
        println!("❌ WebSocket disconnected: {}", reason);
        // Implement custom reconnection logic here if needed
    }
    
    async fn on_error(&amp;self, error: String) {
        eprintln!("⚠️ WebSocket error: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="subscription-types"><a class="header" href="#subscription-types">Subscription Types</a></h2>
<p>The WebSocket client supports various data feed subscriptions:</p>
<h3 id="new-token-listings"><a class="header" href="#new-token-listings">New Token Listings</a></h3>
<p>Subscribe to newly launched tokens on the platform:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to all new token pairs
ws_client.subscribe_new_tokens().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="token-price-updates"><a class="header" href="#token-price-updates">Token Price Updates</a></h3>
<p>Monitor real-time price changes for specific tokens:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to price updates for a specific token
let bonk_address = "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263";
ws_client.subscribe_token_price(bonk_address).await?;

// Subscribe to multiple tokens
let tokens = vec![
    "So11111111111111111111111111111111111111112", // SOL
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
    "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // BONK
];

for token in tokens {
    ws_client.subscribe_token_price(token).await?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wallet-transaction-monitoring"><a class="header" href="#wallet-transaction-monitoring">Wallet Transaction Monitoring</a></h3>
<p>Track transactions for specific wallet addresses:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Monitor transactions for a wallet
let wallet_address = "YourWalletAddressHere";
ws_client.subscribe_wallet_transactions(wallet_address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="real-time-data-handling"><a class="header" href="#real-time-data-handling">Real-Time Data Handling</a></h2>
<h3 id="market-update-structure"><a class="header" href="#market-update-structure">Market Update Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MarketUpdate {
    pub token_mint: String,      // Token contract address
    pub symbol: String,          // Token symbol (e.g., "BONK")
    pub price_usd: f64,         // Current price in USD
    pub price_sol: f64,         // Current price in SOL
    pub price_change_24h: f64,  // 24-hour price change percentage
    pub volume_24h: f64,        // 24-hour trading volume
    pub market_cap: f64,        // Market capitalization
    pub timestamp: i64,         // Unix timestamp
}
<span class="boring">}</span></code></pre></pre>
<h3 id="order-update-structure"><a class="header" href="#order-update-structure">Order Update Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OrderUpdate {
    pub order_id: String,           // Unique order identifier
    pub status: OrderStatus,        // Order status (Pending, Filled, etc.)
    pub transaction_hash: Option&lt;String&gt;, // Blockchain transaction hash
    pub token_mint: String,         // Token being traded
    pub side: OrderSide,           // Buy or Sell
    pub amount: f64,               // Order amount
    pub price: f64,                // Order price
    pub filled_amount: f64,        // Amount filled so far
    pub timestamp: i64,            // Order timestamp
    pub error_message: Option&lt;String&gt;, // Error message if failed
}

pub enum OrderStatus {
    Pending,
    Processing,
    PartiallyFilled,
    Filled,
    Cancelled,
    Failed,
}

pub enum OrderSide {
    Buy,
    Sell,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="price-tracking-example"><a class="header" href="#price-tracking-example">Price Tracking Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use tokio::sync::RwLock;

struct PriceTracker {
    prices: HashMap&lt;String, PriceData&gt;,
    alerts: Vec&lt;PriceAlert&gt;,
}

struct PriceData {
    current_price: f64,
    high_24h: f64,
    low_24h: f64,
    volume_24h: f64,
    last_updated: std::time::Instant,
}

struct PriceAlert {
    token: String,
    target_price: f64,
    condition: AlertCondition, // Above, Below
}

impl PriceTracker {
    async fn update_price(&amp;mut self, symbol: &amp;str, price: f64) {
        // Update price data
        let price_data = self.prices.entry(symbol.to_string())
            .or_insert(PriceData {
                current_price: price,
                high_24h: price,
                low_24h: price,
                volume_24h: 0.0,
                last_updated: std::time::Instant::now(),
            });
        
        price_data.current_price = price;
        price_data.high_24h = price_data.high_24h.max(price);
        price_data.low_24h = price_data.low_24h.min(price);
        price_data.last_updated = std::time::Instant::now();
        
        // Check price alerts
        for alert in &amp;self.alerts {
            if alert.token == symbol {
                match alert.condition {
                    AlertCondition::Above if price &gt; alert.target_price =&gt; {
                        println!("🔔 ALERT: {} is above ${:.6}!", symbol, alert.target_price);
                    }
                    AlertCondition::Below if price &lt; alert.target_price =&gt; {
                        println!("🔔 ALERT: {} is below ${:.6}!", symbol, alert.target_price);
                    }
                    _ =&gt; {}
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-management-and-reconnection-logic"><a class="header" href="#connection-management-and-reconnection-logic">Connection Management and Reconnection Logic</a></h2>
<h3 id="automatic-reconnection"><a class="header" href="#automatic-reconnection">Automatic Reconnection</a></h3>
<p>The WebSocket client includes built-in reconnection logic:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable automatic reconnection (enabled by default)
ws_client.set_auto_reconnect(true);

// The client will automatically:
// 1. Refresh authentication tokens every 10 minutes
// 2. Reconnect if the connection is lost
// 3. Re-subscribe to all previous subscriptions
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-reconnection"><a class="header" href="#manual-reconnection">Manual Reconnection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check connection status
if !ws_client.is_connected().await {
    println!("Connection lost, reconnecting...");
    
    match ws_client.reconnect().await {
        Ok(()) =&gt; {
            println!("Reconnected successfully");
            
            // Re-subscribe to feeds if needed
            ws_client.subscribe_new_tokens().await?;
        }
        Err(e) =&gt; {
            eprintln!("Reconnection failed: {}", e);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-health-monitoring"><a class="header" href="#connection-health-monitoring">Connection Health Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{interval, Duration};

async fn monitor_connection(ws_client: &amp;mut WebSocketClient) {
    let mut health_check = interval(Duration::from_secs(30));
    
    loop {
        health_check.tick().await;
        
        if !ws_client.is_connected().await {
            println!("⚠️ Connection lost, attempting reconnection...");
            
            match ws_client.reconnect().await {
                Ok(()) =&gt; {
                    println!("✅ Reconnection successful");
                }
                Err(e) =&gt; {
                    eprintln!("❌ Reconnection failed: {}", e);
                    // Implement exponential backoff or other retry logic
                }
            }
        }
        
        // Display current subscriptions
        let subs = ws_client.get_subscriptions().await;
        println!("Active subscriptions: {:?}", subs);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="token-price-websocket"><a class="header" href="#token-price-websocket">Token Price WebSocket</a></h2>
<p>For dedicated price monitoring, use the token price WebSocket:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect to the specialized token price stream
let mut price_ws = WebSocketClient::new(handler)?;
price_ws.connect_token_price().await?;

// This uses socket8.axiom.trade specifically for price data
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="websocket-error-types"><a class="header" href="#websocket-error-types">WebSocket Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum WebSocketError {
    AuthError(AuthError),           // Authentication failure
    ConnectionError(String),        // Connection issues
    NotConnected,                  // Not connected when operation attempted
    SendError(String),             // Failed to send message
    ReceiveError(String),          // Failed to receive message
    SerializationError(String),    // JSON parsing errors
    WebSocketError(tokio_tungstenite::tungstenite::Error), // Low-level WebSocket errors
    HttpError(http::Error),        // HTTP upgrade errors
}
<span class="boring">}</span></code></pre></pre>
<h3 id="robust-error-handling-example"><a class="header" href="#robust-error-handling-example">Robust Error Handling Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn robust_websocket_connection() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let handler = Arc::new(MyMessageHandler::new());
    let mut ws_client = WebSocketClient::new(handler)?;
    
    let mut retry_count = 0;
    const MAX_RETRIES: u32 = 5;
    
    loop {
        match ws_client.connect().await {
            Ok(()) =&gt; {
                println!("✅ Connected successfully");
                break;
            }
            Err(e) =&gt; {
                retry_count += 1;
                eprintln!("❌ Connection failed (attempt {}): {}", retry_count, e);
                
                if retry_count &gt;= MAX_RETRIES {
                    return Err(format!("Failed to connect after {} attempts", MAX_RETRIES).into());
                }
                
                // Exponential backoff
                let delay = Duration::from_secs(2_u64.pow(retry_count));
                println!("⏳ Retrying in {:?}...", delay);
                tokio::time::sleep(delay).await;
            }
        }
    }
    
    // Subscribe with error handling
    if let Err(e) = ws_client.subscribe_new_tokens().await {
        eprintln!("⚠️ Failed to subscribe to new tokens: {}", e);
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="1-use-arc-for-shared-message-handlers"><a class="header" href="#1-use-arc-for-shared-message-handlers">1. Use Arc for Shared Message Handlers</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Use Arc for shared ownership
let handler = Arc::new(MyMessageHandler::new());
let mut ws_client = WebSocketClient::new(handler.clone())?;

// The handler can be safely shared across async tasks
let handler_clone = handler.clone();
tokio::spawn(async move {
    // Use handler_clone in another task
});
<span class="boring">}</span></code></pre></pre>
<h3 id="2-implement-connection-pooling-for-multiple-streams"><a class="header" href="#2-implement-connection-pooling-for-multiple-streams">2. Implement Connection Pooling for Multiple Streams</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WebSocketManager {
    connections: HashMap&lt;String, WebSocketClient&gt;,
    handler: Arc&lt;dyn MessageHandler&gt;,
}

impl WebSocketManager {
    async fn create_connection(&amp;mut self, name: &amp;str, region: Region) -&gt; Result&lt;(), WebSocketError&gt; {
        let mut client = WebSocketClient::with_region(self.handler.clone(), region)?;
        client.connect().await?;
        self.connections.insert(name.to_string(), client);
        Ok(())
    }
    
    async fn subscribe_to_token(&amp;mut self, connection_name: &amp;str, token: &amp;str) -&gt; Result&lt;(), WebSocketError&gt; {
        if let Some(client) = self.connections.get_mut(connection_name) {
            client.subscribe_token_price(token).await
        } else {
            Err(WebSocketError::NotConnected)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-rate-limiting-subscriptions"><a class="header" href="#3-rate-limiting-subscriptions">3. Rate Limiting Subscriptions</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{interval, Duration};

async fn subscribe_with_rate_limit(
    ws_client: &amp;mut WebSocketClient,
    tokens: Vec&lt;&amp;str&gt;
) -&gt; Result&lt;(), WebSocketError&gt; {
    let mut rate_limiter = interval(Duration::from_millis(100));
    
    for token in tokens {
        rate_limiter.tick().await;
        
        match ws_client.subscribe_token_price(token).await {
            Ok(()) =&gt; {
                println!("✅ Subscribed to {}", token);
            }
            Err(e) =&gt; {
                eprintln!("❌ Failed to subscribe to {}: {}", token, e);
            }
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-graceful-shutdown"><a class="header" href="#4-graceful-shutdown">4. Graceful Shutdown</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use tokio::signal;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let handler = Arc::new(MyMessageHandler::new());
    let mut ws_client = WebSocketClient::new(handler)?;
    
    ws_client.connect().await?;
    ws_client.subscribe_new_tokens().await?;
    
    // Set up graceful shutdown
    tokio::select! {
        _ = signal::ctrl_c() =&gt; {
            println!("🛑 Shutdown signal received");
        }
        _ = monitor_websocket(&amp;mut ws_client) =&gt; {
            println!("WebSocket monitoring ended");
        }
    }
    
    // Graceful disconnect
    println!("Disconnecting...");
    ws_client.disconnect().await;
    println!("✅ Disconnected gracefully");
    
    Ok(())
}

async fn monitor_websocket(ws_client: &amp;mut WebSocketClient) {
    loop {
        if !ws_client.is_connected().await {
            if let Err(e) = ws_client.reconnect().await {
                eprintln!("Failed to reconnect: {}", e);
                break;
            }
        }
        
        tokio::time::sleep(Duration::from_secs(5)).await;
    }
}</code></pre></pre>
<h2 id="complete-example-multi-token-price-monitor"><a class="header" href="#complete-example-multi-token-price-monitor">Complete Example: Multi-Token Price Monitor</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::websocket::{WebSocketClient, MessageHandler, WebSocketMessage};
use async_trait::async_trait;
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use tokio::time::{interval, Duration};

struct PriceMonitorHandler {
    prices: Arc&lt;RwLock&lt;HashMap&lt;String, f64&gt;&gt;&gt;,
    alerts: Arc&lt;RwLock&lt;Vec&lt;PriceAlert&gt;&gt;&gt;,
}

struct PriceAlert {
    symbol: String,
    target_price: f64,
    triggered: bool,
}

#[async_trait]
impl MessageHandler for PriceMonitorHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        if let WebSocketMessage::MarketUpdate(update) = message {
            // Update price
            {
                let mut prices = self.prices.write().await;
                prices.insert(update.symbol.clone(), update.price_usd);
            }
            
            // Check alerts
            {
                let mut alerts = self.alerts.write().await;
                for alert in alerts.iter_mut() {
                    if alert.symbol == update.symbol &amp;&amp; !alert.triggered {
                        if update.price_usd &gt;= alert.target_price {
                            println!("🚨 PRICE ALERT: {} reached ${:.6}!", 
                                update.symbol, update.price_usd);
                            alert.triggered = true;
                        }
                    }
                }
            }
            
            println!("💰 {} ${:.6} ({:+.2}%)", 
                update.symbol, update.price_usd, update.price_change_24h);
        }
    }
    
    async fn on_connected(&amp;self, session_id: String) {
        println!("🔗 Connected: {}", session_id);
    }
    
    async fn on_disconnected(&amp;self, reason: String) {
        println!("🔌 Disconnected: {}", reason);
    }
    
    async fn on_error(&amp;self, error: String) {
        eprintln!("❌ Error: {}", error);
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    dotenvy::dotenv().ok();
    
    let handler = Arc::new(PriceMonitorHandler {
        prices: Arc::new(RwLock::new(HashMap::new())),
        alerts: Arc::new(RwLock::new(vec![
            PriceAlert {
                symbol: "BONK".to_string(),
                target_price: 0.00003,
                triggered: false,
            }
        ])),
    });
    
    let mut ws_client = WebSocketClient::new(handler.clone())?;
    
    // Connect and subscribe
    ws_client.connect().await?;
    ws_client.subscribe_new_tokens().await?;
    
    // Subscribe to specific tokens
    let popular_tokens = vec![
        "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // BONK
        "EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm", // WIF
    ];
    
    for token in popular_tokens {
        ws_client.subscribe_token_price(token).await?;
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    // Monitor for 5 minutes
    println!("🚀 Monitoring prices for 5 minutes...");
    tokio::time::sleep(Duration::from_secs(300)).await;
    
    // Show final summary
    let prices = handler.prices.read().await;
    println!("\n📊 Final Price Summary:");
    for (symbol, price) in prices.iter() {
        println!("  {}: ${:.6}", symbol, price);
    }
    
    ws_client.disconnect().await;
    Ok(())
}</code></pre></pre>
<p>This comprehensive WebSocket documentation covers all aspects of the streaming functionality, from basic connections to advanced real-time data processing and error handling patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notifications-api"><a class="header" href="#notifications-api">Notifications API</a></h1>
<p>The Axiom Trade notifications system provides comprehensive alert and messaging capabilities for monitoring trading activities, portfolio changes, and system events. This module supports multiple notification types, delivery methods, and configuration options to keep users informed of important events.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>The notifications API allows users to:</p>
<ul>
<li>Create and manage price alerts for specific tokens</li>
<li>Monitor wallet activity with customizable filters</li>
<li>Receive system notifications and announcements</li>
<li>Configure email notifications with custom templates</li>
<li>Set up notification preferences and delivery methods</li>
<li>Track notification history and engagement metrics</li>
</ul>
<h2 id="notificationsclient"><a class="header" href="#notificationsclient">NotificationsClient</a></h2>
<p>The <code>NotificationsClient</code> provides access to all notification functionality:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::notifications::NotificationsClient;

let mut client = NotificationsClient::new()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="price-alerts"><a class="header" href="#price-alerts">Price Alerts</a></h2>
<p>Price alerts notify users when token prices reach specified thresholds or meet certain conditions.</p>
<h3 id="creating-price-alerts"><a class="header" href="#creating-price-alerts">Creating Price Alerts</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::models::notifications::*;

let alert_request = PriceAlertRequest {
    token_address: "So11111111111111111111111111111111111111112".to_string(),
    alert_type: PriceAlertType::AbsolutePrice,
    target_price: 150.0,
    comparison: PriceComparison::Above,
    notification_methods: vec![
        NotificationMethod::Email,
        NotificationMethod::InApp,
    ],
    is_one_time: true,
    expires_at: Some(chrono::Utc::now() + chrono::Duration::days(30)),
};

let alert_id = client.create_price_alert(alert_request).await?;
println!("Created price alert: {}", alert_id);
<span class="boring">}</span></code></pre></pre>
<h3 id="price-alert-types"><a class="header" href="#price-alert-types">Price Alert Types</a></h3>
<ul>
<li><strong>AbsolutePrice</strong>: Alert when token reaches a specific price</li>
<li><strong>PercentageChange</strong>: Alert on percentage price movement</li>
<li><strong>VolumeThreshold</strong>: Alert when trading volume exceeds threshold</li>
<li><strong>MarketCapThreshold</strong>: Alert based on market capitalization changes</li>
</ul>
<h3 id="price-comparison-options"><a class="header" href="#price-comparison-options">Price Comparison Options</a></h3>
<ul>
<li><strong>Above</strong>: Trigger when price goes above target</li>
<li><strong>Below</strong>: Trigger when price goes below target</li>
<li><strong>Equal</strong>: Trigger when price equals target (within tolerance)</li>
<li><strong>PercentageIncrease</strong>: Trigger on percentage increase</li>
<li><strong>PercentageDecrease</strong>: Trigger on percentage decrease</li>
</ul>
<h3 id="managing-price-alerts"><a class="header" href="#managing-price-alerts">Managing Price Alerts</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Delete a price alert
let success = client.delete_price_alert("alert_id").await?;

// List all price alerts (via get_notifications)
let notifications = client.get_notifications().await?;
let price_alerts: Vec&lt;_&gt; = notifications
    .into_iter()
    .filter(|n| n.notification_type == NotificationType::PriceAlert)
    .collect();
<span class="boring">}</span></code></pre></pre>
<h2 id="wallet-activity-alerts"><a class="header" href="#wallet-activity-alerts">Wallet Activity Alerts</a></h2>
<p>Monitor specific wallet addresses for trading activity and transactions.</p>
<h3 id="creating-wallet-alerts"><a class="header" href="#creating-wallet-alerts">Creating Wallet Alerts</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wallet_alert = WalletAlertRequest {
    wallet_address: "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1".to_string(),
    activity_types: vec![
        WalletActivityType::Buy,
        WalletActivityType::Sell,
        WalletActivityType::LargeTransaction,
    ],
    min_transaction_value: Some(1000.0), // Minimum $1000 transactions
    token_filters: vec![
        "So11111111111111111111111111111111111111112".to_string(), // SOL
    ],
    notification_methods: vec![
        NotificationMethod::Email,
        NotificationMethod::InApp,
    ],
    is_active: true,
};

let alert_id = client.create_wallet_alert(wallet_alert).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="wallet-activity-types"><a class="header" href="#wallet-activity-types">Wallet Activity Types</a></h3>
<ul>
<li><strong>Buy</strong>: Token purchase transactions</li>
<li><strong>Sell</strong>: Token sale transactions</li>
<li><strong>Swap</strong>: Token swap operations</li>
<li><strong>Transfer</strong>: Token transfer events</li>
<li><strong>LargeTransaction</strong>: Transactions above specified value</li>
<li><strong>NewToken</strong>: First interaction with new tokens</li>
<li><strong>AllActivity</strong>: Monitor all wallet activity</li>
</ul>
<h2 id="system-notifications"><a class="header" href="#system-notifications">System Notifications</a></h2>
<p>System notifications provide information about platform status, maintenance, and important updates.</p>
<h3 id="retrieving-notifications"><a class="header" href="#retrieving-notifications">Retrieving Notifications</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get user notifications
let notifications = client.get_notifications().await?;
for notification in notifications {
    println!("{}: {}", notification.title, notification.message);
    if !notification.is_read {
        println!("  Priority: {:?}", notification.priority);
        println!("  Created: {}", notification.created_at);
    }
}

// Get system announcements
let announcements = client.get_announcements().await?;
for announcement in announcements {
    println!("Announcement: {}", announcement.title);
    println!("Type: {:?}", announcement.announcement_type);
    println!("Target: {:?}", announcement.target_audience);
    
    if announcement.action_required {
        println!("Action required: {}", announcement.action_url.unwrap_or_default());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="notification-types"><a class="header" href="#notification-types">Notification Types</a></h3>
<ul>
<li><strong>PriceAlert</strong>: Price-based alerts</li>
<li><strong>WalletActivity</strong>: Wallet monitoring alerts</li>
<li><strong>TradeExecution</strong>: Trade confirmation notifications</li>
<li><strong>SystemUpdate</strong>: Platform updates and changes</li>
<li><strong>SecurityAlert</strong>: Security-related notifications</li>
<li><strong>MarketNews</strong>: Market information and news</li>
<li><strong>SocialMention</strong>: Social media mentions and sentiment</li>
</ul>
<h3 id="notification-priorities"><a class="header" href="#notification-priorities">Notification Priorities</a></h3>
<ul>
<li><strong>Low</strong>: Informational messages</li>
<li><strong>Medium</strong>: Standard notifications</li>
<li><strong>High</strong>: Important alerts requiring attention</li>
<li><strong>Critical</strong>: Urgent notifications requiring immediate action</li>
</ul>
<h3 id="managing-notifications"><a class="header" href="#managing-notifications">Managing Notifications</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mark specific notification as read
let success = client.mark_notification_read("notification_id").await?;

// Mark all notifications as read
let success = client.mark_all_notifications_read().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="email-notifications"><a class="header" href="#email-notifications">Email Notifications</a></h2>
<p>Configure email delivery for notifications with customizable templates and scheduling.</p>
<h3 id="email-notification-settings"><a class="header" href="#email-notification-settings">Email Notification Settings</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current email settings
let settings = client.get_notification_settings().await?;
println!("Email notifications enabled: {}", settings.email_notifications);

// Update email settings
let mut updated_settings = settings;
updated_settings.email_notifications = true;
updated_settings.preferred_methods = vec![
    NotificationMethod::Email,
    NotificationMethod::InApp,
];

let success = client.update_notification_settings(updated_settings).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="notification-delivery-methods"><a class="header" href="#notification-delivery-methods">Notification Delivery Methods</a></h3>
<ul>
<li><strong>InApp</strong>: Display within the application interface</li>
<li><strong>Email</strong>: Send via email to configured address</li>
<li><strong>Push</strong>: Push notifications to mobile devices</li>
<li><strong>Webhook</strong>: HTTP POST to configured webhook URL</li>
<li><strong>Telegram</strong>: Send to Telegram bot/channel</li>
<li><strong>Discord</strong>: Send to Discord webhook</li>
</ul>
<h2 id="notification-configuration"><a class="header" href="#notification-configuration">Notification Configuration</a></h2>
<h3 id="notification-settings-structure"><a class="header" href="#notification-settings-structure">Notification Settings Structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NotificationSettings {
    pub email_notifications: bool,
    pub push_notifications: bool,
    pub in_app_notifications: bool,
    pub price_alerts_enabled: bool,
    pub wallet_alerts_enabled: bool,
    pub social_mentions_enabled: bool,
    pub market_news_enabled: bool,
    pub trade_confirmations_enabled: bool,
    pub security_alerts_enabled: bool,
    pub quiet_hours: Option&lt;QuietHours&gt;,
    pub preferred_methods: Vec&lt;NotificationMethod&gt;,
    pub frequency_limits: FrequencyLimits,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="quiet-hours-configuration"><a class="header" href="#quiet-hours-configuration">Quiet Hours Configuration</a></h3>
<p>Set times when notifications should be suppressed:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let quiet_hours = QuietHours {
    enabled: true,
    start_time: "22:00".to_string(), // 10 PM
    end_time: "07:00".to_string(),   // 7 AM
    timezone: "UTC".to_string(),
    days: vec![
        "monday".to_string(),
        "tuesday".to_string(),
        "wednesday".to_string(),
        "thursday".to_string(),
        "friday".to_string(),
    ],
};
<span class="boring">}</span></code></pre></pre>
<h3 id="frequency-limits"><a class="header" href="#frequency-limits">Frequency Limits</a></h3>
<p>Control notification frequency to prevent spam:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frequency_limits = FrequencyLimits {
    max_price_alerts_per_hour: 10,
    max_wallet_alerts_per_hour: 20,
    max_social_alerts_per_hour: 5,
    batch_similar_notifications: true,
    batch_delay_minutes: 15,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="alert-management"><a class="header" href="#alert-management">Alert Management</a></h2>
<h3 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h3>
<ol>
<li><strong>Set Appropriate Thresholds</strong>: Avoid too many low-value alerts</li>
<li><strong>Use Expiration Dates</strong>: Set expiration for temporary alerts</li>
<li><strong>Configure Quiet Hours</strong>: Respect user sleep schedules</li>
<li><strong>Batch Similar Notifications</strong>: Reduce notification fatigue</li>
<li><strong>Monitor Delivery Success</strong>: Track notification effectiveness</li>
</ol>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<ul>
<li><strong>Rate Limiting</strong>: Respect API rate limits when creating multiple alerts</li>
<li><strong>Batch Operations</strong>: Use batch endpoints for multiple alerts</li>
<li><strong>Efficient Filtering</strong>: Use appropriate filters to reduce unnecessary notifications</li>
<li><strong>Cleanup</strong>: Remove expired or unnecessary alerts regularly</li>
</ul>
<h3 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::errors::AxiomError;

match client.create_price_alert(alert_request).await {
    Ok(alert_id) =&gt; {
        println!("Alert created successfully: {}", alert_id);
    }
    Err(AxiomError::Api { message }) =&gt; {
        eprintln!("API error creating alert: {}", message);
    }
    Err(AxiomError::Network(e)) =&gt; {
        eprintln!("Network error: {}", e);
    }
    Err(e) =&gt; {
        eprintln!("Unexpected error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="example-complete-notification-setup"><a class="header" href="#example-complete-notification-setup">Example: Complete Notification Setup</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::{
    api::notifications::NotificationsClient,
    models::notifications::*,
    errors::Result,
};

async fn setup_comprehensive_notifications() -&gt; Result&lt;()&gt; {
    let mut client = NotificationsClient::new()?;
    
    // Configure notification preferences
    let settings = NotificationSettings {
        email_notifications: true,
        push_notifications: true,
        in_app_notifications: true,
        price_alerts_enabled: true,
        wallet_alerts_enabled: true,
        social_mentions_enabled: false,
        market_news_enabled: true,
        trade_confirmations_enabled: true,
        security_alerts_enabled: true,
        quiet_hours: Some(QuietHours {
            enabled: true,
            start_time: "22:00".to_string(),
            end_time: "07:00".to_string(),
            timezone: "UTC".to_string(),
            days: vec!["saturday".to_string(), "sunday".to_string()],
        }),
        preferred_methods: vec![
            NotificationMethod::Email,
            NotificationMethod::InApp,
        ],
        frequency_limits: FrequencyLimits {
            max_price_alerts_per_hour: 5,
            max_wallet_alerts_per_hour: 10,
            max_social_alerts_per_hour: 3,
            batch_similar_notifications: true,
            batch_delay_minutes: 10,
        },
    };
    
    client.update_notification_settings(settings).await?;
    
    // Create price alert for SOL
    let sol_alert = PriceAlertRequest {
        token_address: "So11111111111111111111111111111111111111112".to_string(),
        alert_type: PriceAlertType::AbsolutePrice,
        target_price: 200.0,
        comparison: PriceComparison::Above,
        notification_methods: vec![
            NotificationMethod::Email,
            NotificationMethod::InApp,
        ],
        is_one_time: false, // Recurring alert
        expires_at: None,   // No expiration
    };
    
    let alert_id = client.create_price_alert(sol_alert).await?;
    println!("Created SOL price alert: {}", alert_id);
    
    // Create wallet monitoring alert
    let wallet_alert = WalletAlertRequest {
        wallet_address: "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1".to_string(),
        activity_types: vec![
            WalletActivityType::Buy,
            WalletActivityType::Sell,
        ],
        min_transaction_value: Some(500.0),
        token_filters: vec![], // Monitor all tokens
        notification_methods: vec![NotificationMethod::InApp],
        is_active: true,
    };
    
    let wallet_alert_id = client.create_wallet_alert(wallet_alert).await?;
    println!("Created wallet monitoring alert: {}", wallet_alert_id);
    
    // Check for new notifications
    let notifications = client.get_notifications().await?;
    println!("Current unread notifications: {}", 
        notifications.iter().filter(|n| !n.is_read).count()
    );
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-4"><a class="header" href="#security-considerations-4">Security Considerations</a></h2>
<ul>
<li><strong>Webhook Security</strong>: Use HTTPS endpoints and validate webhook signatures</li>
<li><strong>Email Privacy</strong>: Be cautious with sensitive information in email notifications</li>
<li><strong>Rate Limiting</strong>: Implement client-side rate limiting to prevent abuse</li>
<li><strong>Data Validation</strong>: Validate all notification data before processing</li>
<li><strong>Access Control</strong>: Ensure users can only access their own notifications</li>
</ul>
<p>The notifications API provides a comprehensive system for keeping users informed about their trading activities and platform updates. Proper configuration and management of notifications can significantly enhance the user experience while maintaining security and preventing notification fatigue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turnkey-integration"><a class="header" href="#turnkey-integration">Turnkey Integration</a></h1>
<p>The Turnkey integration provides enterprise-grade hardware wallet management with P256 cryptographic operations for secure trading on Axiom Trade. This integration handles key management, authentication, and secure signing through Turnkey's infrastructure.</p>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>Turnkey is a secure wallet infrastructure that provides:</p>
<ul>
<li>Hardware-level key security</li>
<li>P256 elliptic curve cryptography</li>
<li>API key management</li>
<li>Session-based authentication</li>
<li>Enterprise-grade access controls</li>
</ul>
<h2 id="turnkey-setup"><a class="header" href="#turnkey-setup">Turnkey Setup</a></h2>
<h3 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h3>
<p>Before using the Turnkey integration, ensure you have:</p>
<ol>
<li><strong>Turnkey Organization Account</strong>: A registered organization on Turnkey</li>
<li><strong>User Credentials</strong>: Valid user account within the organization</li>
<li><strong>Environment Variables</strong>: Properly configured authentication details</li>
</ol>
<h3 id="initial-configuration"><a class="header" href="#initial-configuration">Initial Configuration</a></h3>
<p>The Turnkey client requires minimal setup:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::turnkey::TurnkeyClient;

// Create a new Turnkey client
let mut turnkey_client = TurnkeyClient::new();

// Set credentials for authenticated operations
turnkey_client.set_credentials(
    organization_id,
    user_id,
    password  // Raw password for P256 key derivation
);
<span class="boring">}</span></code></pre></pre>
<h3 id="session-management-2"><a class="header" href="#session-management-2">Session Management</a></h3>
<p>Turnkey sessions are automatically managed through the authentication flow:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load existing session from file
let session_content = std::fs::read_to_string(".axiom_turnkey_session.json")?;
let session: AuthSession = serde_json::from_str(&amp;session_content)?;

if let Some(turnkey_session) = session.turnkey_session {
    // Use existing session
    println!("Organization: {}", turnkey_session.organization_id);
    println!("User: {}", turnkey_session.username);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hardware-wallet-authentication"><a class="header" href="#hardware-wallet-authentication">Hardware Wallet Authentication</a></h2>
<h3 id="authentication-flow"><a class="header" href="#authentication-flow">Authentication Flow</a></h3>
<p>The Turnkey authentication process involves several steps:</p>
<ol>
<li><strong>Identity Verification</strong>: Confirm user identity with the organization</li>
<li><strong>API Key Retrieval</strong>: Fetch available API keys for operations</li>
<li><strong>Session Creation</strong>: Establish secure session for trading operations</li>
</ol>
<h4 id="step-1-identity-verification"><a class="header" href="#step-1-identity-verification">Step 1: Identity Verification</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify user identity
let whoami = turnkey_client.whoami(
    &amp;organization_id,
    &amp;client_secret
).await?;

println!("Authenticated as: {}", whoami.username);
println!("Organization: {}", whoami.organization_name);
<span class="boring">}</span></code></pre></pre>
<h4 id="step-2-api-key-management"><a class="header" href="#step-2-api-key-management">Step 2: API Key Management</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Retrieve API keys for the user
let api_keys = turnkey_client.get_api_keys(
    &amp;user_id,
    &amp;organization_id,
    &amp;client_secret
).await?;

println!("Available API keys: {}", api_keys.api_keys.len());

for key in &amp;api_keys.api_keys {
    println!("Key: {} (Type: {})", key.api_key_name, key.credential.credential_type);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="step-3-session-creation"><a class="header" href="#step-3-session-creation">Step 3: Session Creation</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create read/write session for trading operations
let success = turnkey_client.create_read_write_session(
    organization_id,
    user_id,
    target_public_key,
    "trading-session"
).await?;

if success {
    println!("Trading session created successfully");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="session-validation-1"><a class="header" href="#session-validation-1">Session Validation</a></h3>
<p>The client provides methods to validate and monitor session health:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check service health
let is_healthy = turnkey_client.health_check().await?;

// Parse and validate session
let parsed_session = turnkey_client.parse_session(
    &amp;whoami,
    &amp;api_keys,
    &amp;client_secret
);

// Get session summary
let summary = turnkey_client.session_summary(&amp;parsed_session);
println!("Session status: {}", summary);
<span class="boring">}</span></code></pre></pre>
<h2 id="p256-cryptography"><a class="header" href="#p256-cryptography">P256 Cryptography</a></h2>
<h3 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h3>
<p>The integration uses P256 elliptic curve cryptography for secure operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::p256_crypto;

// Generate P256 keypair from password
let keypair = p256_crypto::generate_p256_keypair_from_password(
    password,
    None  // Random salt, or provide specific salt
)?;

println!("Public key: {}", keypair.public_key);
println!("Private key length: {}", keypair.private_key.len());
<span class="boring">}</span></code></pre></pre>
<h3 id="deterministic-key-recreation"><a class="header" href="#deterministic-key-recreation">Deterministic Key Recreation</a></h3>
<p>Keys can be recreated deterministically using the client secret:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Recreate keypair from stored client secret
let keypair = p256_crypto::recreate_keypair_from_client_secret(
    password,
    client_secret
)?;

// Keys will be identical to original generation
<span class="boring">}</span></code></pre></pre>
<h3 id="key-security-features"><a class="header" href="#key-security-features">Key Security Features</a></h3>
<ul>
<li><strong>PBKDF2 with SHA256</strong>: 600,000 iterations for key derivation</li>
<li><strong>P256 Curve</strong>: NIST P-256 elliptic curve (secp256r1)</li>
<li><strong>Compressed Public Keys</strong>: Space-efficient key representation</li>
<li><strong>Secure Salt Generation</strong>: Cryptographically secure random salts</li>
</ul>
<h2 id="secure-signing"><a class="header" href="#secure-signing">Secure Signing</a></h2>
<h3 id="message-signing"><a class="header" href="#message-signing">Message Signing</a></h3>
<p>The client handles request signing automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sign arbitrary message
let message = b"transaction_data";
let signature = p256_crypto::sign_message(message, &amp;private_key)?;

println!("Signature length: {} bytes", signature.len());
println!("Format: DER encoded");
<span class="boring">}</span></code></pre></pre>
<h3 id="webauthn-compatible-signing"><a class="header" href="#webauthn-compatible-signing">WebAuthn Compatible Signing</a></h3>
<p>For WebAuthn and browser-compatible operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generate WebAuthn-compatible signature (raw r,s format)
let webauthn_signature = p256_crypto::sign_message_webauthn(
    message,
    &amp;private_key
)?;

// Signature is exactly 64 bytes (32-byte r + 32-byte s)
assert_eq!(webauthn_signature.len(), 64);
<span class="boring">}</span></code></pre></pre>
<h3 id="signature-verification"><a class="header" href="#signature-verification">Signature Verification</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify signature authenticity
let is_valid = p256_crypto::verify_signature(
    message,
    &amp;signature,
    &amp;public_key
)?;

if is_valid {
    println!("Signature verified successfully");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="request-authentication"><a class="header" href="#request-authentication">Request Authentication</a></h3>
<p>Turnkey requests are automatically signed with the X-Stamp header:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal signing process (handled automatically)
let signature = self.sign_request(payload_json.as_bytes(), client_secret)?;

// Headers include authentication stamp
.header("X-Stamp", signature)
.header("x-client-version", "@turnkey/sdk-server@1.7.3")
<span class="boring">}</span></code></pre></pre>
<h2 id="api-methods"><a class="header" href="#api-methods">API Methods</a></h2>
<h3 id="core-operations"><a class="header" href="#core-operations">Core Operations</a></h3>
<h4 id="identity-and-authentication"><a class="header" href="#identity-and-authentication">Identity and Authentication</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current user identity
let whoami: TurnkeyWhoAmI = turnkey_client.whoami(
    organization_id,
    client_secret
).await?;

// Fields available:
// - organization_id: String
// - organization_name: String  
// - user_id: String
// - username: String
<span class="boring">}</span></code></pre></pre>
<h4 id="api-key-management"><a class="header" href="#api-key-management">API Key Management</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Retrieve all API keys for user
let api_keys: GetApiKeysResponse = turnkey_client.get_api_keys(
    user_id,
    organization_id,
    client_secret
).await?;

// Access key information
for key in api_keys.api_keys {
    println!("Key ID: {}", key.api_key_id);
    println!("Name: {}", key.api_key_name);
    println!("Public Key: {}", key.credential.public_key);
    println!("Type: {}", key.credential.credential_type);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="session-management-3"><a class="header" href="#session-management-3">Session Management</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create secure session for operations
let success: bool = turnkey_client.create_read_write_session(
    organization_id,
    user_id,
    target_public_key,
    api_key_name
).await?;

// Sessions expire after 30 days by default
<span class="boring">}</span></code></pre></pre>
<h3 id="utility-methods"><a class="header" href="#utility-methods">Utility Methods</a></h3>
<h4 id="session-information"><a class="header" href="#session-information">Session Information</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get specific API key by type
let session_key = turnkey_client.get_session_key(
    &amp;session,
    "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
);

// Generate human-readable session summary
let summary = turnkey_client.session_summary(&amp;session);
println!("{}", summary);
// Output: "Turnkey Session - User: alice, Keys: 2/3 active, Age: 45m, Expires: 120m"
<span class="boring">}</span></code></pre></pre>
<h4 id="health-monitoring"><a class="header" href="#health-monitoring">Health Monitoring</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check Turnkey service availability
let is_healthy: bool = turnkey_client.health_check().await?;

if !is_healthy {
    println!("Turnkey service may be experiencing issues");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-9"><a class="header" href="#error-handling-9">Error Handling</a></h3>
<p>The integration provides comprehensive error handling:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match turnkey_client.whoami(org_id, client_secret).await {
    Ok(whoami) =&gt; {
        println!("Authentication successful: {}", whoami.username);
    }
    Err(AxiomError::Api { message, .. }) if message.contains("PUBLIC_KEY_NOT_FOUND") =&gt; {
        println!("Public key not registered with Turnkey organization");
    }
    Err(AxiomError::Api { message, .. }) if message.contains("unauthorized") =&gt; {
        println!("Invalid authentication credentials");
    }
    Err(AxiomError::Network { .. }) =&gt; {
        println!("Network connectivity issue");
    }
    Err(e) =&gt; {
        println!("Unexpected error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-axiom-trade"><a class="header" href="#integration-with-axiom-trade">Integration with Axiom Trade</a></h2>
<h3 id="session-storage"><a class="header" href="#session-storage">Session Storage</a></h3>
<p>Turnkey sessions are integrated with the main authentication system:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sessions are stored in .axiom_turnkey_session.json
let auth_session = AuthSession {
    tokens: auth_tokens,
    cookies: auth_cookies,
    turnkey_session: Some(turnkey_session),
    user_info: user_info,
    session_metadata: metadata,
};
<span class="boring">}</span></code></pre></pre>
<h3 id="automatic-session-management"><a class="header" href="#automatic-session-management">Automatic Session Management</a></h3>
<p>The client automatically handles:</p>
<ul>
<li><strong>Session expiration checking</strong></li>
<li><strong>Key rotation</strong></li>
<li><strong>Error recovery</strong></li>
<li><strong>Health monitoring</strong></li>
</ul>
<h3 id="trading-integration"><a class="header" href="#trading-integration">Trading Integration</a></h3>
<p>Turnkey sessions enable secure trading operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Session provides cryptographic signing for trades
if let Some(turnkey) = &amp;session.turnkey_session {
    // Use Turnkey session for secure trade signing
    let trade_signature = sign_trade_request(&amp;trade_data, &amp;turnkey.client_secret)?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-5"><a class="header" href="#security-considerations-5">Security Considerations</a></h2>
<h3 id="key-security"><a class="header" href="#key-security">Key Security</a></h3>
<ul>
<li><strong>Hardware-backed</strong>: Keys are protected by Turnkey's hardware infrastructure</li>
<li><strong>Never exposed</strong>: Private keys never leave the secure environment</li>
<li><strong>P256 cryptography</strong>: Industry-standard elliptic curve cryptography</li>
<li><strong>Secure derivation</strong>: PBKDF2 with high iteration count</li>
</ul>
<h3 id="session-security"><a class="header" href="#session-security">Session Security</a></h3>
<ul>
<li><strong>Limited lifetime</strong>: Sessions expire automatically (30 days default)</li>
<li><strong>Activity tracking</strong>: All operations are logged and monitored</li>
<li><strong>Secure transmission</strong>: All communications use TLS encryption</li>
<li><strong>Authentication required</strong>: Every request requires cryptographic signature</li>
</ul>
<h3 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h3>
<ol>
<li><strong>Store passwords securely</strong>: Use OS keychain or secure storage</li>
<li><strong>Monitor session health</strong>: Regular health checks and renewal</li>
<li><strong>Handle errors gracefully</strong>: Implement proper error recovery</li>
<li><strong>Rotate keys regularly</strong>: Follow organizational key rotation policies</li>
<li><strong>Validate responses</strong>: Always verify API responses and signatures</li>
</ol>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="common-issues-3"><a class="header" href="#common-issues-3">Common Issues</a></h3>
<h4 id="authentication-failures"><a class="header" href="#authentication-failures">Authentication Failures</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Handle common authentication issues
fn handle_auth_failure(error: AxiomError) -&gt; Result&lt;()&gt; {
    match error {
        AxiomError::Api { message, .. } if message.contains("PUBLIC_KEY_NOT_FOUND") =&gt; {
            println!("Solution: Ensure public key is registered in Turnkey organization");
        }
        AxiomError::Api { message, .. } if message.contains("unauthorized") =&gt; {
            println!("Solution: Check password and client secret are correct");
        }
        AxiomError::Network { .. } =&gt; {
            println!("Solution: Check internet connection");
        }
        _ =&gt; {
            println!("Unknown error: {}", error);
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h4 id="session-issues"><a class="header" href="#session-issues">Session Issues</a></h4>
<ul>
<li><strong>Expired sessions</strong>: Re-authenticate to refresh session</li>
<li><strong>Invalid keys</strong>: Verify key registration in Turnkey organization</li>
<li><strong>Network issues</strong>: Check connectivity and retry with backoff</li>
</ul>
<h4 id="key-generation-problems"><a class="header" href="#key-generation-problems">Key Generation Problems</a></h4>
<ul>
<li><strong>Invalid salt</strong>: Ensure client secret is properly base64 encoded</li>
<li><strong>Wrong password</strong>: Verify password matches original key generation</li>
<li><strong>Curve validation</strong>: Ensure derived key is valid for P256 curve</li>
</ul>
<h3 id="debug-information"><a class="header" href="#debug-information">Debug Information</a></h3>
<p>Enable detailed logging for troubleshooting:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get comprehensive session information
let summary = turnkey_client.session_summary(&amp;session);
println!("Debug: {}", summary);

// Check individual key status
for key in &amp;session.api_keys {
    if let Some(expires_at) = key.expires_at {
        let remaining = expires_at - chrono::Utc::now();
        println!("Key {} expires in {} minutes", key.api_key_name, remaining.num_minutes());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This integration provides enterprise-grade security for cryptocurrency trading operations while maintaining ease of use and robust error handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-examples"><a class="header" href="#authentication-examples">Authentication Examples</a></h1>
<p>This section provides comprehensive examples of authentication with the Axiom Trade API. The examples demonstrate different authentication methods, session management, and OTP handling.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>The authentication system in axiomtrade-rs supports multiple authentication methods:</p>
<ul>
<li><strong>Basic Login</strong>: Email/password authentication with token management</li>
<li><strong>OTP Verification</strong>: Automatic OTP fetching from inbox.lv email service</li>
<li><strong>Session Management</strong>: Persistent sessions with token refresh capabilities</li>
<li><strong>Cookie Authentication</strong>: Web-based authentication for browser integrations</li>
</ul>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<p>Before running any authentication examples, ensure you have:</p>
<ol>
<li><strong>Environment Setup</strong>: Configure your <code>.env</code> file with required credentials</li>
<li><strong>Dependencies</strong>: All required crates are installed via <code>cargo build</code></li>
<li><strong>Optional OTP Setup</strong>: Configure inbox.lv for automatic OTP retrieval</li>
</ol>
<h3 id="required-environment-variables-2"><a class="header" href="#required-environment-variables-2">Required Environment Variables</a></h3>
<pre><code class="language-env"># Basic authentication (required)
AXIOM_EMAIL=your_email@example.com
AXIOM_PASSWORD=your_password

# Optional OTP automation (recommended)
INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_imap_password
</code></pre>
<h2 id="example-1-basic-login"><a class="header" href="#example-1-basic-login">Example 1: Basic Login</a></h2>
<p>The basic login example demonstrates the fundamental authentication flow with email/password credentials.</p>
<h3 id="location"><a class="header" href="#location">Location</a></h3>
<pre><code>examples/authentication/basic_login.rs
</code></pre>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">/// Basic Authentication Example
/// 
/// This example demonstrates the fundamental authentication flow with Axiom Trade,
/// including email/password login and token management.

use axiomtrade_rs::auth::{AuthClient, TokenManager};
use std::env;
use std::path::PathBuf;

#[tokio::main]
async fn main() {
    // Load credentials from environment variables
    dotenvy::dotenv().ok();
    
    let email = env::var("AXIOM_EMAIL")
        .expect("AXIOM_EMAIL must be set in .env file");
    let password = env::var("AXIOM_PASSWORD")
        .expect("AXIOM_PASSWORD must be set in .env file");

    println!("Starting basic authentication example...");
    println!("Email: {}", email);

    // Create a new auth client
    let mut auth_client = match AuthClient::new() {
        Ok(client) =&gt; {
            println!("Auth client initialized");
            client
        }
        Err(e) =&gt; {
            println!("Failed to create auth client: {}", e);
            return;
        }
    };
    
    // Check if OTP auto-fetching is configured
    let inbox_configured = env::var("INBOX_LV_EMAIL").is_ok()
        &amp;&amp; env::var("INBOX_LV_PASSWORD").is_ok();
    
    if inbox_configured {
        println!("OTP auto-fetching is configured");
    } else {
        println!("OTP auto-fetching not configured - will require manual entry");
    }
    
    // Perform login
    println!("\nAttempting login...");
    match auth_client.login(&amp;email, &amp;password, None).await {
        Ok(tokens) =&gt; {
            println!("Login successful!");
            
            println!(
                "Access Token: {}...",
                &amp;tokens.access_token[..20.min(tokens.access_token.len())]
            );
            println!(
                "Refresh Token: {}...",
                &amp;tokens.refresh_token[..20.min(tokens.refresh_token.len())]
            );
            
            // Save tokens for future use
            let tokens_file = PathBuf::from(".axiom_tokens.json");
            let token_manager = TokenManager::new(Some(tokens_file.clone()));
            
            if let Err(e) = token_manager.set_tokens(tokens).await {
                println!("Warning: Failed to save tokens: {}", e);
            } else {
                println!("\nTokens saved to {}", tokens_file.display());
                println!("You can now use these tokens for API calls without re-logging in");
            }
            
            // Test authenticated request using EnhancedClient
            println!("\nTesting authenticated request...");
            let enhanced_client = match axiomtrade_rs::client::EnhancedClient::new() {
                Ok(client) =&gt; client,
                Err(e) =&gt; {
                    println!("Failed to create enhanced client: {}", e);
                    return;
                }
            };
            
            println!("\nAuthentication example completed successfully!");
        }
        Err(e) =&gt; {
            println!("Login failed: {}", e);
            println!("\nPossible reasons:");
            println!("1. Invalid credentials");
            println!("2. Network connectivity issues");
            println!("3. API service unavailable");
            
            if !inbox_configured {
                println!("4. OTP required but auto-fetching not configured");
                println!("   Run: cargo run --example setup_env");
                println!("   Or see: examples/setup/auto_otp_setup.md");
            }
        }
    }
}</code></pre></pre>
<h3 id="how-to-run"><a class="header" href="#how-to-run">How to Run</a></h3>
<pre><code class="language-bash"># Ensure environment variables are set in .env file
cargo run --example basic_login
</code></pre>
<h3 id="features-demonstrated"><a class="header" href="#features-demonstrated">Features Demonstrated</a></h3>
<ul>
<li><strong>AuthClient Initialization</strong>: Creating and configuring the authentication client</li>
<li><strong>Email/Password Login</strong>: Basic credential-based authentication</li>
<li><strong>Token Management</strong>: Saving and managing access/refresh tokens</li>
<li><strong>Error Handling</strong>: Comprehensive error handling with helpful troubleshooting tips</li>
<li><strong>Token Persistence</strong>: Saving tokens to disk for future use</li>
</ul>
<h3 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h3>
<pre><code>Starting basic authentication example...
Email: your_email@example.com
Auth client initialized
OTP auto-fetching is configured
Attempting login...
Login successful!
Access Token: eyJhbGciOiJIUzI1NiIsI...
Refresh Token: eyJhbGciOiJIUzI1NiIsI...
Tokens saved to .axiom_tokens.json
You can now use these tokens for API calls without re-logging in
Testing authenticated request...
Authentication example completed successfully!
</code></pre>
<h2 id="example-2-otp-verification"><a class="header" href="#example-2-otp-verification">Example 2: OTP Verification</a></h2>
<p>This example demonstrates automatic OTP handling using the inbox.lv email service integration.</p>
<h3 id="location-1"><a class="header" href="#location-1">Location</a></h3>
<pre><code>examples/authentication/otp_verification.rs
</code></pre>
<h3 id="code-1"><a class="header" href="#code-1">Code</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">/// OTP Verification Example
/// 
/// This example demonstrates OTP verification with automatic email fetching
/// from inbox.lv when properly configured.

use axiomtrade_rs::auth::{AuthClient, TokenManager};
use std::env;
use std::io::{self, Write};
use std::path::PathBuf;

#[tokio::main]
async fn main() {
    // Load credentials from environment variables
    dotenvy::dotenv().ok();
    
    let email = env::var("AXIOM_EMAIL")
        .expect("AXIOM_EMAIL must be set in .env file");
    let password = env::var("AXIOM_PASSWORD")
        .expect("AXIOM_PASSWORD must be set in .env file");

    println!("Starting OTP verification example...");

    // Create a new auth client
    let mut auth_client = match AuthClient::new() {
        Ok(client) =&gt; {
            println!("Auth client initialized");
            client
        }
        Err(e) =&gt; {
            println!("Failed to create auth client: {}", e);
            return;
        }
    };
    
    // Check if automatic OTP fetching is configured
    let inbox_email = env::var("INBOX_LV_EMAIL").ok();
    let inbox_password = env::var("INBOX_LV_PASSWORD").ok();
    
    let auto_otp_configured = inbox_email.is_some() &amp;&amp; inbox_password.is_some();
    
    if auto_otp_configured {
        println!("Automatic OTP retrieval is configured");
        println!("The system will automatically fetch OTP from inbox.lv");
    } else {
        println!("Automatic OTP not configured");
        println!("To enable automatic OTP:");
        println!("1. Create an inbox.lv account");
        println!("2. Enable IMAP access in settings");
        println!("3. Set INBOX_LV_EMAIL and INBOX_LV_PASSWORD in .env");
        println!("4. Forward Axiom OTP emails to your inbox.lv address");
        println!("\nFor now, you'll need to enter OTP manually when prompted.");
    }
    
    println!("\nPerforming login...");
    
    // The login method handles OTP automatically if configured
    match auth_client.login(&amp;email, &amp;password, None).await {
        Ok(tokens) =&gt; {
            println!("\nLogin successful with OTP verification!");
            
            println!(
                "Access Token: {}...",
                &amp;tokens.access_token[..20.min(tokens.access_token.len())]
            );
            
            // Save tokens
            let tokens_file = PathBuf::from(".axiom_tokens.json");
            let token_manager = TokenManager::new(Some(tokens_file.clone()));
            
            if let Err(e) = token_manager.set_tokens(tokens).await {
                println!("Warning: Failed to save tokens: {}", e);
            } else {
                println!("\nTokens saved to {}", tokens_file.display());
            }
            
            println!("\nOTP verification example completed successfully!");
            
            if auto_otp_configured {
                println!("\nNote: OTP was fetched automatically from inbox.lv");
            } else {
                println!("\nNote: In production, configure auto-OTP for seamless authentication");
            }
        }
        Err(e) =&gt; {
            println!("Login failed: {}", e);
            
            if !auto_otp_configured {
                println!("\nHint: The login may have failed because OTP couldn't be retrieved automatically.");
                println!("Configure inbox.lv integration for automatic OTP handling.");
                println!("See: examples/setup/auto_otp_setup.md");
            }
        }
    }
}

/// Helper function to manually get OTP from user (not used with auto-OTP)
fn get_otp_from_user() -&gt; Result&lt;String, io::Error&gt; {
    print!("Enter OTP code: ");
    io::stdout().flush()?;
    
    let mut otp = String::new();
    io::stdin().read_line(&amp;mut otp)?;
    
    Ok(otp.trim().to_string())
}</code></pre></pre>
<h3 id="how-to-run-1"><a class="header" href="#how-to-run-1">How to Run</a></h3>
<pre><code class="language-bash"># With automatic OTP (recommended)
# Configure INBOX_LV_EMAIL and INBOX_LV_PASSWORD in .env first
cargo run --example otp_verification

# Without automatic OTP (manual entry required)
cargo run --example otp_verification
</code></pre>
<h3 id="features-demonstrated-1"><a class="header" href="#features-demonstrated-1">Features Demonstrated</a></h3>
<ul>
<li><strong>Automatic OTP Retrieval</strong>: Fetching OTP codes from inbox.lv email service</li>
<li><strong>Manual OTP Fallback</strong>: User input for OTP when automation is not configured</li>
<li><strong>OTP Configuration Detection</strong>: Checking if automatic OTP is properly set up</li>
<li><strong>Email Integration</strong>: IMAP integration for OTP retrieval</li>
<li><strong>Seamless Authentication</strong>: Handling OTP verification transparently</li>
</ul>
<h3 id="otp-setup-requirements"><a class="header" href="#otp-setup-requirements">OTP Setup Requirements</a></h3>
<p>To enable automatic OTP retrieval:</p>
<ol>
<li><strong>Create inbox.lv account</strong> at https://www.inbox.lv/</li>
<li><strong>Enable IMAP access</strong>:
<ul>
<li>Go to Settings → "Outlook, email programs"</li>
<li>Click "Enable" button</li>
<li>Wait 15 minutes for activation</li>
</ul>
</li>
<li><strong>Get IMAP password</strong> (different from web login password)</li>
<li><strong>Configure email forwarding</strong> from Axiom Trade to your inbox.lv address</li>
<li><strong>Set environment variables</strong>:
<pre><code class="language-env">INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_special_imap_password
</code></pre>
</li>
</ol>
<h3 id="expected-output-1"><a class="header" href="#expected-output-1">Expected Output</a></h3>
<pre><code>Starting OTP verification example...
Auth client initialized
Automatic OTP retrieval is configured
The system will automatically fetch OTP from inbox.lv
Performing login...
Login successful with OTP verification!
Access Token: eyJhbGciOiJIUzI1NiIsI...
Tokens saved to .axiom_tokens.json
OTP verification example completed successfully!
Note: OTP was fetched automatically from inbox.lv
</code></pre>
<h2 id="example-3-session-management"><a class="header" href="#example-3-session-management">Example 3: Session Management</a></h2>
<p>This example demonstrates persistent session management, token refresh, and handling multiple authentication sessions.</p>
<h3 id="location-2"><a class="header" href="#location-2">Location</a></h3>
<pre><code>examples/authentication/session_management.rs
</code></pre>
<h3 id="code-2"><a class="header" href="#code-2">Code</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">/// Session Management Example
/// 
/// This example demonstrates session persistence, token refresh,
/// and managing multiple authentication sessions.

use axiomtrade_rs::auth::{AuthClient, TokenManager, SessionManager};
use std::env;
use std::path::PathBuf;

#[tokio::main]
async fn main() {
    // Load credentials from environment variables
    dotenvy::dotenv().ok();
    
    println!("Session Management Example");
    println!("==========================\n");

    // Create token manager with persistent storage
    let tokens_file = PathBuf::from(".axiom_session.json");
    let token_manager = TokenManager::new(Some(tokens_file.clone()));
    
    // Check for existing session
    println!("Step 1: Checking for existing session...");
    if let Some(tokens) = token_manager.get_tokens().await {
        println!("✓ Found existing session");
        println!("  Access token: {}...", &amp;tokens.access_token[..20.min(tokens.access_token.len())]);
        
        // Check if tokens are still valid (simplified check)
        // In production, you'd check expiry time
        if !tokens.access_token.is_empty() {
            println!("✓ Session is still valid");
            
            // Test the session with an API call
            println!("\nTesting session with API call...");
            let client = match axiomtrade_rs::client::EnhancedClient::new() {
                Ok(c) =&gt; c,
                Err(e) =&gt; {
                    println!("Failed to create client: {}", e);
                    return;
                }
            };
            
            // In a real implementation, you would make an API call here
            println!("✓ Session is active and working");
            
        } else {
            println!("⚠ Session expired, need to refresh or re-login");
            
            // Try to refresh the session
            if !tokens.refresh_token.is_empty() {
                println!("\nAttempting to refresh session...");
                let mut auth_client = match AuthClient::new() {
                    Ok(c) =&gt; c,
                    Err(e) =&gt; {
                        println!("Failed to create auth client: {}", e);
                        return;
                    }
                };
                
                println!("Note: Token refresh would be called here in production");
            } else {
                perform_new_login(&amp;token_manager).await;
            }
        }
    } else {
        println!("No existing session found");
        perform_new_login(&amp;token_manager).await;
    }
    
    println!("\nStep 2: Managing multiple sessions...");
    
    // Create session manager for handling multiple accounts
    let session_path = PathBuf::from(".axiom_sessions.json");
    let session_manager = SessionManager::new(Some(session_path), true);
    
    // Example: Managing sessions for different accounts
    let session_files = vec![
        ".axiom_session_account1.json",
        ".axiom_session_account2.json",
        ".axiom_session_trading.json",
    ];
    
    println!("Available session files:");
    for file in &amp;session_files {
        let path = PathBuf::from(file);
        if path.exists() {
            println!("  ✓ {}", file);
        } else {
            println!("  ✗ {} (not found)", file);
        }
    }
    
    println!("\nStep 3: Session best practices...");
    println!("1. Always check token validity before API calls");
    println!("2. Implement automatic token refresh");
    println!("3. Store tokens securely (consider OS keychain)");
    println!("4. Handle session expiry gracefully");
    println!("5. Support multiple concurrent sessions");
    println!("6. Clear sessions on logout");
    
    println!("\nStep 4: Session lifecycle hooks...");
    println!("You can implement callbacks for:");
    println!("- onSessionCreated: New login successful");
    println!("- onSessionRefreshed: Tokens refreshed");
    println!("- onSessionExpired: Session no longer valid");
    println!("- onSessionError: Authentication error");
    
    println!("\nSession management example completed!");
}

async fn perform_new_login(token_manager: &amp;TokenManager) {
    println!("\nPerforming new login...");
    
    let email = match env::var("AXIOM_EMAIL") {
        Ok(e) =&gt; e,
        Err(_) =&gt; {
            println!("AXIOM_EMAIL not set");
            return;
        }
    };
    
    let password = match env::var("AXIOM_PASSWORD") {
        Ok(p) =&gt; p,
        Err(_) =&gt; {
            println!("AXIOM_PASSWORD not set");
            return;
        }
    };
    
    let mut auth_client = match AuthClient::new() {
        Ok(c) =&gt; c,
        Err(e) =&gt; {
            println!("Failed to create auth client: {}", e);
            return;
        }
    };
    
    match auth_client.login(&amp;email, &amp;password, None).await {
        Ok(tokens) =&gt; {
            println!("✓ Login successful");
            
            // Save the new session
            if let Err(e) = token_manager.set_tokens(tokens).await {
                println!("Warning: Failed to save session: {}", e);
            } else {
                println!("✓ Session saved for future use");
            }
        }
        Err(e) =&gt; {
            println!("✗ Login failed: {}", e);
        }
    }
}</code></pre></pre>
<h3 id="how-to-run-2"><a class="header" href="#how-to-run-2">How to Run</a></h3>
<pre><code class="language-bash">cargo run --example session_management
</code></pre>
<h3 id="features-demonstrated-2"><a class="header" href="#features-demonstrated-2">Features Demonstrated</a></h3>
<ul>
<li><strong>Session Persistence</strong>: Saving and loading authentication sessions</li>
<li><strong>Token Validation</strong>: Checking if existing tokens are still valid</li>
<li><strong>Session Refresh</strong>: Automatic token refresh before expiry</li>
<li><strong>Multiple Sessions</strong>: Managing sessions for different accounts</li>
<li><strong>Session Lifecycle</strong>: Best practices for session management</li>
<li><strong>Error Recovery</strong>: Graceful handling of session expiry</li>
</ul>
<h3 id="expected-output-2"><a class="header" href="#expected-output-2">Expected Output</a></h3>
<pre><code>Session Management Example
==========================

Step 1: Checking for existing session...
✓ Found existing session
  Access token: eyJhbGciOiJIUzI1NiIsI...
✓ Session is still valid

Testing session with API call...
✓ Session is active and working

Step 2: Managing multiple sessions...
Available session files:
  ✓ .axiom_session_account1.json
  ✗ .axiom_session_account2.json (not found)
  ✓ .axiom_session_trading.json

Step 3: Session best practices...
1. Always check token validity before API calls
2. Implement automatic token refresh
3. Store tokens securely (consider OS keychain)
4. Handle session expiry gracefully
5. Support multiple concurrent sessions
6. Clear sessions on logout

Step 4: Session lifecycle hooks...
You can implement callbacks for:
- onSessionCreated: New login successful
- onSessionRefreshed: Tokens refreshed
- onSessionExpired: Session no longer valid
- onSessionError: Authentication error

Session management example completed!
</code></pre>
<h2 id="example-4-cookie-authentication"><a class="header" href="#example-4-cookie-authentication">Example 4: Cookie Authentication</a></h2>
<p>This example demonstrates cookie-based authentication for web applications and browser integrations.</p>
<h3 id="location-3"><a class="header" href="#location-3">Location</a></h3>
<pre><code>examples/authentication/cookie_auth.rs
</code></pre>
<h3 id="code-3"><a class="header" href="#code-3">Code</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">/// Cookie Authentication Example
/// 
/// This example demonstrates authentication using cookies for session persistence,
/// useful for web-based integrations.

use axiomtrade_rs::auth::{AuthClient, AuthCookies};
use std::env;
use std::collections::HashMap;

#[tokio::main]
async fn main() {
    // Load credentials from environment variables
    dotenvy::dotenv().ok();
    
    let email = env::var("AXIOM_EMAIL")
        .expect("AXIOM_EMAIL must be set in .env file");
    let password = env::var("AXIOM_PASSWORD")
        .expect("AXIOM_PASSWORD must be set in .env file");

    println!("Cookie Authentication Example");
    println!("=============================\n");

    // Create a new auth client
    let mut auth_client = match AuthClient::new() {
        Ok(client) =&gt; {
            println!("Auth client initialized");
            client
        }
        Err(e) =&gt; {
            println!("Failed to create auth client: {}", e);
            return;
        }
    };
    
    println!("Step 1: Performing login with cookie support...");
    
    // Login and get both tokens and cookies
    match auth_client.login(&amp;email, &amp;password, None).await {
        Ok(tokens) =&gt; {
            println!("✓ Login successful");
            println!("  Access token received: {}...", &amp;tokens.access_token[..20.min(tokens.access_token.len())]);
            
            // Get cookies from the auth client
            // In the actual implementation, cookies would be extracted from response headers
            println!("\nStep 2: Managing authentication cookies...");
            
            // Example cookie structure (these would come from the actual response)
            let mut additional = HashMap::new();
            additional.insert("session_id".to_string(), "axiom_session_abc123".to_string());
            additional.insert("csrf_token".to_string(), "csrf_xyz789".to_string());
            
            let auth_cookies = AuthCookies {
                auth_access_token: Some("access_cookie_value".to_string()),
                auth_refresh_token: Some("refresh_cookie_value".to_string()),
                g_state: Some("google_state_value".to_string()),
                additional_cookies: additional,
            };
            
            if auth_cookies.auth_access_token.is_some() {
                println!("✓ Access token cookie set");
                println!("  Secure authentication established");
            }
            
            if auth_cookies.auth_refresh_token.is_some() {
                println!("✓ Refresh token cookie set");
                println!("  Session renewal enabled");
            }
            
            if auth_cookies.g_state.is_some() {
                println!("✓ Google state cookie set");
                println!("  OAuth integration ready");
            }
            
            if !auth_cookies.additional_cookies.is_empty() {
                println!("✓ Additional cookies: {}", auth_cookies.additional_cookies.len());
                for (name, _) in auth_cookies.additional_cookies.iter().take(3) {
                    println!("  - {}", name);
                }
            }
            
            println!("\nStep 3: Cookie-based API requests...");
            println!("Cookies can be used for:");
            println!("  - Web dashboard access");
            println!("  - Browser-based API calls");
            println!("  - Cross-origin requests (with proper CORS)");
            println!("  - Maintaining session across page reloads");
            
            println!("\nStep 4: Cookie security best practices...");
            println!("✓ HttpOnly flag: Prevents JavaScript access");
            println!("✓ Secure flag: HTTPS only transmission");
            println!("✓ SameSite: CSRF protection");
            println!("✓ Path restrictions: Limit cookie scope");
            println!("✓ Expiry management: Auto-logout after inactivity");
            
            println!("\nStep 5: Cookie refresh and rotation...");
            println!("In production, implement:");
            println!("  - Automatic cookie refresh before expiry");
            println!("  - Session rotation on privilege escalation");
            println!("  - Secure cookie storage in browser");
            println!("  - Clear cookies on logout");
            
            // Example: Using cookies for subsequent requests
            println!("\nStep 6: Making authenticated requests with cookies...");
            
            println!("✓ Cookie authentication flow completed");
            
            println!("\nNote: Cookie authentication is ideal for:");
            println!("  - Web applications");
            println!("  - Browser extensions");
            println!("  - Server-side rendered apps");
            println!("  - Progressive web apps (PWAs)");
            
        }
        Err(e) =&gt; {
            println!("✗ Login failed: {}", e);
            println!("\nTroubleshooting:");
            println!("  1. Check credentials are correct");
            println!("  2. Ensure cookies are enabled");
            println!("  3. Verify CORS settings if cross-origin");
            println!("  4. Check for cookie blocking extensions");
        }
    }
    
    println!("\nCookie authentication example completed!");
}</code></pre></pre>
<h3 id="how-to-run-3"><a class="header" href="#how-to-run-3">How to Run</a></h3>
<pre><code class="language-bash">cargo run --example cookie_auth
</code></pre>
<h3 id="features-demonstrated-3"><a class="header" href="#features-demonstrated-3">Features Demonstrated</a></h3>
<ul>
<li><strong>Cookie Management</strong>: Setting and managing authentication cookies</li>
<li><strong>Security Best Practices</strong>: HttpOnly, Secure, SameSite cookie flags</li>
<li><strong>Web Integration</strong>: Cookie-based authentication for web applications</li>
<li><strong>Session Persistence</strong>: Maintaining authentication across browser sessions</li>
<li><strong>CSRF Protection</strong>: Cross-site request forgery prevention</li>
<li><strong>Cookie Rotation</strong>: Secure session management practices</li>
</ul>
<h3 id="expected-output-3"><a class="header" href="#expected-output-3">Expected Output</a></h3>
<pre><code>Cookie Authentication Example
=============================

Auth client initialized
Step 1: Performing login with cookie support...
✓ Login successful
  Access token received: eyJhbGciOiJIUzI1NiIsI...

Step 2: Managing authentication cookies...
✓ Access token cookie set
  Secure authentication established
✓ Refresh token cookie set
  Session renewal enabled
✓ Google state cookie set
  OAuth integration ready
✓ Additional cookies: 2
  - session_id
  - csrf_token

Step 3: Cookie-based API requests...
Cookies can be used for:
  - Web dashboard access
  - Browser-based API calls
  - Cross-origin requests (with proper CORS)
  - Maintaining session across page reloads

Step 4: Cookie security best practices...
✓ HttpOnly flag: Prevents JavaScript access
✓ Secure flag: HTTPS only transmission
✓ SameSite: CSRF protection
✓ Path restrictions: Limit cookie scope
✓ Expiry management: Auto-logout after inactivity

Step 5: Cookie refresh and rotation...
In production, implement:
  - Automatic cookie refresh before expiry
  - Session rotation on privilege escalation
  - Secure cookie storage in browser
  - Clear cookies on logout

Step 6: Making authenticated requests with cookies...
✓ Cookie authentication flow completed

Note: Cookie authentication is ideal for:
  - Web applications
  - Browser extensions
  - Server-side rendered apps
  - Progressive web apps (PWAs)

Cookie authentication example completed!
</code></pre>
<h2 id="running-all-examples"><a class="header" href="#running-all-examples">Running All Examples</a></h2>
<p>To run all authentication examples in sequence:</p>
<pre><code class="language-bash"># Run each example individually
cargo run --example basic_login
cargo run --example otp_verification
cargo run --example session_management
cargo run --example cookie_auth

# Or build all examples at once
cargo build --examples
</code></pre>
<h2 id="common-issues-and-troubleshooting"><a class="header" href="#common-issues-and-troubleshooting">Common Issues and Troubleshooting</a></h2>
<h3 id="authentication-failures-1"><a class="header" href="#authentication-failures-1">Authentication Failures</a></h3>
<p><strong>Problem</strong>: Login fails with invalid credentials</p>
<pre><code>Login failed: Authentication failed: Invalid email or password
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Verify credentials in <code>.env</code> file</li>
<li>Check for typos in email/password</li>
<li>Ensure account is not locked or suspended</li>
</ol>
<h3 id="otp-issues"><a class="header" href="#otp-issues">OTP Issues</a></h3>
<p><strong>Problem</strong>: OTP verification fails</p>
<pre><code>Login failed: OTP verification failed
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Configure inbox.lv automatic OTP retrieval</li>
<li>Check email forwarding is set up correctly</li>
<li>Verify IMAP credentials are correct</li>
<li>Check for email delivery delays</li>
</ol>
<h3 id="token-issues"><a class="header" href="#token-issues">Token Issues</a></h3>
<p><strong>Problem</strong>: Token persistence fails</p>
<pre><code>Warning: Failed to save tokens: Permission denied
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Check file permissions in working directory</li>
<li>Ensure disk space is available</li>
<li>Run with appropriate user permissions</li>
</ol>
<h3 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h3>
<p><strong>Problem</strong>: Connection timeouts</p>
<pre><code>Login failed: Network error: Connection timeout
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Check internet connectivity</li>
<li>Verify firewall settings</li>
<li>Try again with network retry logic</li>
</ol>
<h2 id="security-considerations-6"><a class="header" href="#security-considerations-6">Security Considerations</a></h2>
<h3 id="token-storage"><a class="header" href="#token-storage">Token Storage</a></h3>
<ul>
<li><strong>Never commit tokens to version control</strong></li>
<li><strong>Use secure storage mechanisms</strong> (OS keychain when possible)</li>
<li><strong>Implement token rotation</strong> for long-running applications</li>
<li><strong>Clear tokens on logout</strong> to prevent misuse</li>
</ul>
<h3 id="otp-security"><a class="header" href="#otp-security">OTP Security</a></h3>
<ul>
<li><strong>Use dedicated email account</strong> for OTP automation</li>
<li><strong>Enable two-factor authentication</strong> on email account</li>
<li><strong>Monitor for unauthorized access</strong> to email account</li>
<li><strong>Consider rate limiting</strong> for OTP requests</li>
</ul>
<h3 id="cookie-security"><a class="header" href="#cookie-security">Cookie Security</a></h3>
<ul>
<li><strong>Always use HTTPS</strong> in production</li>
<li><strong>Set appropriate cookie flags</strong> (HttpOnly, Secure, SameSite)</li>
<li><strong>Implement CSRF protection</strong> for web applications</li>
<li><strong>Use short expiry times</strong> for sensitive operations</li>
</ul>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<ul>
<li><strong>Never commit <code>.env</code> files</strong> to version control</li>
<li><strong>Use environment-specific configurations</strong></li>
<li><strong>Implement secret rotation</strong> for production systems</li>
<li><strong>Monitor for credential leaks</strong> in logs and error messages</li>
</ul>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>After mastering authentication, explore these related topics:</p>
<ol>
<li><strong><a href="examples/trading.html">Trading Examples</a></strong>: Execute trades with authenticated sessions</li>
<li><strong><a href="examples/portfolio.html">Portfolio Examples</a></strong>: Manage portfolios and balances</li>
<li><strong><a href="examples/websocket.html">WebSocket Examples</a></strong>: Real-time data with authenticated connections</li>
<li><strong><a href="examples/advanced.html">Advanced Examples</a></strong>: Complex authentication patterns and automation</li>
</ol>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<p>For detailed API documentation, see:</p>
<ul>
<li><strong><a href="examples/../auth/login.html">Authentication API</a></strong>: Login and authentication methods</li>
<li><strong><a href="examples/../auth/tokens.html">Token Management</a></strong>: Token handling and refresh</li>
<li><strong><a href="examples/../auth/sessions.html">Session Management</a></strong>: Session persistence and management</li>
<li><strong><a href="examples/../automatic-otp.html">OTP Integration</a></strong>: Automatic OTP setup and configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portfolio-examples"><a class="header" href="#portfolio-examples">Portfolio Examples</a></h1>
<p>This section demonstrates comprehensive portfolio management capabilities using the Axiom Trade Rust client. These examples show how to retrieve, monitor, and analyze portfolio data across multiple wallets.</p>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>The portfolio examples showcase four key areas of functionality:</p>
<ol>
<li><strong>Basic Portfolio Retrieval</strong> - Getting complete portfolio summaries with performance metrics</li>
<li><strong>Batch Balance Operations</strong> - Efficiently querying multiple wallets simultaneously</li>
<li><strong>Real-time Monitoring</strong> - Continuous portfolio tracking with alerts and change detection</li>
<li><strong>Token Account Analysis</strong> - Deep analysis of token holdings, distribution, and risk assessment</li>
</ol>
<p>All examples require proper authentication and environment setup as described in the <a href="examples/authentication.html">Authentication Examples</a>.</p>
<h2 id="1-basic-portfolio-retrieval-get_portfoliors"><a class="header" href="#1-basic-portfolio-retrieval-get_portfoliors">1. Basic Portfolio Retrieval (<code>get_portfolio.rs</code>)</a></h2>
<h3 id="overview-13"><a class="header" href="#overview-13">Overview</a></h3>
<p>The basic portfolio retrieval example demonstrates how to fetch comprehensive portfolio information including balance statistics, performance metrics, top positions, and recent transactions.</p>
<h3 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h3>
<ul>
<li>Complete portfolio summary with SOL values</li>
<li>Performance metrics (1-day, 7-day, 30-day, all-time PnL)</li>
<li>Top position analysis with profit/loss percentages</li>
<li>Recent transaction history</li>
<li>Individual wallet balance breakdowns</li>
<li>Token holding details with market values</li>
</ul>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::api::portfolio::PortfolioClient;
use axiomtrade_rs::auth::AuthClient;

// Authenticate and create portfolio client
let mut auth_client = AuthClient::new()?;
auth_client.login(&amp;email, &amp;password, None).await?;
let mut portfolio_client = PortfolioClient::new()?;

// Define wallets to analyze
let wallet_addresses = vec![
    "DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK".to_string(),
    "5FHwkrdxntdK24hgQU8qgBjn35Y1zwhz1GZwCkP2UJnM".to_string(),
];

// Get comprehensive portfolio summary
let portfolio = portfolio_client.get_portfolio_summary(&amp;wallet_addresses).await?;

// Access portfolio data
println!("Total Value: {:.4} SOL", portfolio.balance_stats.total_value_sol);
println!("Available Balance: {:.4} SOL", portfolio.balance_stats.available_balance_sol);
println!("Unrealized PnL: {:.4} SOL", portfolio.balance_stats.unrealized_pnl_sol);
<span class="boring">}</span></code></pre></pre>
<h3 id="output-example"><a class="header" href="#output-example">Output Example</a></h3>
<pre><code>📊 Portfolio Summary
====================
  Total Value SOL: 125.4567 SOL
  Available SOL: 98.7654 SOL
  Unrealized PnL: 12.3456 SOL

📈 Performance Metrics:
  1 Day PnL: 2.3456 SOL
  7 Day PnL: 8.9012 SOL
  30 Day PnL: 15.6789 SOL
  All Time PnL: 45.2341 SOL

💎 Top Positions:
  1. BONK (Bonk Inu)
     Amount: 1234567.8900
     Value: $567.89
     PnL: +12.34%
</code></pre>
<h2 id="2-batch-balance-queries-batch_balancesrs"><a class="header" href="#2-batch-balance-queries-batch_balancesrs">2. Batch Balance Queries (<code>batch_balances.rs</code>)</a></h2>
<h3 id="overview-14"><a class="header" href="#overview-14">Overview</a></h3>
<p>This example demonstrates efficient batch querying capabilities for retrieving balance information across multiple wallets in a single API call, providing significant performance improvements over individual queries.</p>
<h3 id="key-features-2"><a class="header" href="#key-features-2">Key Features</a></h3>
<ul>
<li>Single API call for multiple wallet balances</li>
<li>Comprehensive balance statistics and aggregation</li>
<li>Token distribution analysis across wallets</li>
<li>Performance metrics and efficiency calculations</li>
<li>Fallback to individual queries on batch failure</li>
<li>Rich portfolio analytics and reporting</li>
</ul>
<h3 id="efficiency-benefits"><a class="header" href="#efficiency-benefits">Efficiency Benefits</a></h3>
<ul>
<li><strong>API Calls</strong>: 1 batch call vs N individual calls</li>
<li><strong>Network Overhead</strong>: Reduced latency and bandwidth usage</li>
<li><strong>Rate Limiting</strong>: More efficient use of API quotas</li>
<li><strong>Data Consistency</strong>: Snapshot of all balances at the same time</li>
</ul>
<h3 id="example-usage-1"><a class="header" href="#example-usage-1">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define multiple wallet addresses
let wallet_addresses = vec![
    "DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK".to_string(),
    "5FHwkrdxntdK24hgQU8qgBjn35Y1zwhz1GZwCkP2UJnM".to_string(),
    "7xLk17EQQ5KLDLDe44wCmupJKJjTGd8hs3eSVVhCx932".to_string(),
    // ... more wallets
];

// Perform batch balance query
let batch_response = portfolio_client.get_batch_balance(&amp;wallet_addresses).await?;

// Analyze results
for (address, balance) in batch_response.balances.iter() {
    println!("Wallet: {}...", &amp;address[..8]);
    println!("  SOL Balance: {:.6} SOL", balance.sol_balance);
    println!("  Total Value: ${:.2}", balance.total_value_usd);
    println!("  Token Count: {}", balance.token_balances.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="output-example-1"><a class="header" href="#output-example-1">Output Example</a></h3>
<pre><code>📊 Performing batch balance query...
✓ Batch query successful!

Address         SOL Balance     USD Value    Tokens
-----------------------------------------------------------------
DYw8jC...          12.345678      1,234.56        15
5FHwkr...          23.456789      2,345.67         8
7xLk17...           5.678901        567.89        22
-----------------------------------------------------------------
TOTAL              41.481368      4,148.12

📈 Token Distribution Analysis:
  Most common tokens:
    USDC - held by 3 wallet(s), total value: $1,234.56
    BONK - held by 2 wallet(s), total value: $567.89
    SOL - held by 3 wallet(s), total value: $2,345.67

📦 Batch Efficiency:
  Single queries would require: 3 API calls
  Batch query used: 1 API call
  Efficiency gain: 3x
</code></pre>
<h2 id="3-real-time-portfolio-monitoring-portfolio_monitoringrs"><a class="header" href="#3-real-time-portfolio-monitoring-portfolio_monitoringrs">3. Real-time Portfolio Monitoring (<code>portfolio_monitoring.rs</code>)</a></h2>
<h3 id="overview-15"><a class="header" href="#overview-15">Overview</a></h3>
<p>This example implements continuous real-time monitoring of portfolio changes with configurable update intervals, change detection algorithms, performance tracking, and alert systems.</p>
<h3 id="key-features-3"><a class="header" href="#key-features-3">Key Features</a></h3>
<ul>
<li><strong>Continuous Monitoring</strong>: Configurable update intervals (default 30 seconds)</li>
<li><strong>Change Detection</strong>: Automatic detection of value, balance, and position changes</li>
<li><strong>Performance Analysis</strong>: Historical tracking with volatility calculations</li>
<li><strong>Alert System</strong>: Configurable thresholds for significant changes</li>
<li><strong>Memory Management</strong>: Efficient historical data storage with cleanup</li>
<li><strong>Error Handling</strong>: Robust error recovery and authentication refresh</li>
</ul>
<h3 id="monitoring-capabilities"><a class="header" href="#monitoring-capabilities">Monitoring Capabilities</a></h3>
<h4 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h4>
<ul>
<li>Total portfolio value changes (SOL and percentage)</li>
<li>Available balance fluctuations</li>
<li>Active position count changes</li>
<li>New transaction detection</li>
</ul>
<h4 id="performance-analysis"><a class="header" href="#performance-analysis">Performance Analysis</a></h4>
<ul>
<li>Total performance since monitoring start</li>
<li>Recent trend analysis (last 5 data points)</li>
<li>Volatility calculation using standard deviation</li>
<li>Real-time profit/loss tracking</li>
</ul>
<h4 id="alert-system"><a class="header" href="#alert-system">Alert System</a></h4>
<ul>
<li>Portfolio value change alerts (&gt;5% threshold)</li>
<li>New position alerts</li>
<li>New transaction alerts</li>
<li>Custom threshold configuration</li>
</ul>
<h3 id="example-usage-2"><a class="header" href="#example-usage-2">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize monitoring
let demo_wallets = vec![
    "DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK".to_string(),
    "5FHwkrdxntdK24hgQU8qgBjn35Y1zwhz1GZwCkP2UJnM".to_string(),
];

let mut last_portfolio = client.get_portfolio_summary(&amp;demo_wallets).await?;
let initial_value = last_portfolio.balance_stats.total_value_sol;

// Monitoring loop
loop {
    sleep(Duration::from_secs(30)).await;
    
    let current_portfolio = client.get_portfolio_summary(&amp;demo_wallets).await?;
    let changes = detect_portfolio_changes(&amp;last_portfolio, &amp;current_portfolio);
    
    // Process changes and generate alerts
    if !changes.is_empty() {
        for change in &amp;changes {
            println!("  {}", change);
        }
    }
    
    // Performance and alert analysis
    analyze_performance(&amp;total_value_history, initial_value);
    check_alerts(&amp;current_portfolio, &amp;last_portfolio);
    
    last_portfolio = current_portfolio;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="output-example-2"><a class="header" href="#output-example-2">Output Example</a></h3>
<pre><code>============================================================
Update #3 - 30.2s since last update

Portfolio Summary:
  Active positions: 15
  Total SOL: 125.456789
  Available SOL: 98.765432
  Unrealized PnL: 12.345678 SOL
  Total transactions: 45

Detected Changes:
  Total value: +2.345678 SOL (+1.90%)
  New transactions: +2

Performance Analysis:
  Since start: $45.67 (+2.34%)
  Recent trend: $12.34 (+1.12%)
  Volatility: 3.45%

ALERT: 2 new transactions detected
</code></pre>
<h2 id="4-token-account-analysis-token_accountsrs"><a class="header" href="#4-token-account-analysis-token_accountsrs">4. Token Account Analysis (<code>token_accounts.rs</code>)</a></h2>
<h3 id="overview-16"><a class="header" href="#overview-16">Overview</a></h3>
<p>This sophisticated example provides comprehensive analysis of token holdings across multiple wallets, including position sizing, risk assessment, portfolio optimization suggestions, and distribution analysis.</p>
<h3 id="key-features-4"><a class="header" href="#key-features-4">Key Features</a></h3>
<ul>
<li><strong>Comprehensive Token Analysis</strong>: Aggregated view across all wallets</li>
<li><strong>Risk Assessment</strong>: Concentration risk and position size analysis</li>
<li><strong>Portfolio Optimization</strong>: Automated suggestions for improvement</li>
<li><strong>Distribution Analysis</strong>: Position size buckets and diversity metrics</li>
<li><strong>Wallet Diversity</strong>: Token distribution across wallet addresses</li>
<li><strong>Performance Metrics</strong>: Position sizing and value calculations</li>
</ul>
<h3 id="analysis-capabilities"><a class="header" href="#analysis-capabilities">Analysis Capabilities</a></h3>
<h4 id="token-aggregation"><a class="header" href="#token-aggregation">Token Aggregation</a></h4>
<ul>
<li>Total balance and USD value per token across all wallets</li>
<li>Wallet count per token (distribution analysis)</li>
<li>Average position size calculations</li>
<li>Comprehensive position tracking</li>
</ul>
<h4 id="risk-analysis-1"><a class="header" href="#risk-analysis-1">Risk Analysis</a></h4>
<ul>
<li><strong>Concentration Risk</strong>: Top 5 holdings percentage of total portfolio</li>
<li><strong>Small Position Analysis</strong>: Identification of positions under $5</li>
<li><strong>Distribution Buckets</strong>: Position categorization (&lt;$1, $1-10, $10-100, $100-1K, &gt;$1K)</li>
<li><strong>Wallet Diversity</strong>: Analysis of token distribution across wallets</li>
</ul>
<h4 id="optimization-suggestions"><a class="header" href="#optimization-suggestions">Optimization Suggestions</a></h4>
<ul>
<li>Concentration reduction recommendations</li>
<li>Small position consolidation advice</li>
<li>Dust position cleanup suggestions</li>
<li>Well-distributed holdings identification</li>
</ul>
<h3 id="example-usage-3"><a class="header" href="#example-usage-3">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get batch balances for analysis
let batch_response = client.get_batch_balance(&amp;demo_wallets).await?;

// Analyze token distribution
let mut token_summary: HashMap&lt;String, TokenSummary&gt; = HashMap::new();

for (wallet_address, wallet_balance) in &amp;batch_response.balances {
    // Process SOL balance
    if wallet_balance.sol_balance &gt; 0.0 {
        let sol_value_usd = wallet_balance.sol_balance * 100.0; // SOL price estimate
        // Add to token summary...
    }
    
    // Process token balances
    for (mint_address, token_balance) in &amp;wallet_balance.token_balances {
        // Aggregate token data across wallets...
    }
}

// Generate analysis and optimization suggestions
analyze_concentration_risk(&amp;sorted_tokens, total_value);
analyze_position_distribution(&amp;sorted_tokens);
generate_optimization_suggestions(&amp;sorted_tokens);
<span class="boring">}</span></code></pre></pre>
<h3 id="output-example-3"><a class="header" href="#output-example-3">Output Example</a></h3>
<pre><code>Token Portfolio Summary:
Total positions: 147
Total portfolio value: $12,345.67
Unique tokens: 23

Top 10 Token Holdings:
Symbol          Total Balance       USD Value    Wallets  Avg Position
--------------------------------------------------------------------------------
SOL                    45.678900      4,567.89         3      1,522.63
USDC                2,345.123400      2,345.12         2      1,172.56
BONK           12,345,678.900000      1,234.57         1      1,234.57

Risk Analysis:
Top 5 tokens concentration: 78.9%
  WARNING: High concentration risk detected
Positions under $5: 8 (34.8%)

Position Size Distribution:
  &lt;$1: 5 positions (21.7%)
  $1-10: 8 positions (34.8%)
  $10-100: 6 positions (26.1%)
  $100-1K: 3 positions (13.0%)
  &gt;$1K: 1 positions (4.3%)

Optimization Suggestions:
- Consider reducing concentration in top holdings
- Consider consolidating or closing positions under $5
- Consider cleaning up 5 dust positions

Well Distributed Holdings:
  USDC - 2 wallets, $2,345.12
  SOL - 3 wallets, $4,567.89
</code></pre>
<h2 id="practical-use-cases"><a class="header" href="#practical-use-cases">Practical Use Cases</a></h2>
<h3 id="1-portfolio-dashboards"><a class="header" href="#1-portfolio-dashboards">1. Portfolio Dashboards</a></h3>
<p>Use the portfolio retrieval and monitoring examples to build real-time dashboard applications showing:</p>
<ul>
<li>Current portfolio values and performance</li>
<li>Position changes and alerts</li>
<li>Historical performance tracking</li>
<li>Risk metrics and recommendations</li>
</ul>
<h3 id="2-automated-rebalancing"><a class="header" href="#2-automated-rebalancing">2. Automated Rebalancing</a></h3>
<p>Combine token account analysis with trading capabilities to:</p>
<ul>
<li>Identify overweight positions requiring rebalancing</li>
<li>Detect underweight allocations needing increases</li>
<li>Automate portfolio rebalancing based on target allocations</li>
<li>Implement risk management rules</li>
</ul>
<h3 id="3-multi-wallet-management"><a class="header" href="#3-multi-wallet-management">3. Multi-Wallet Management</a></h3>
<p>Use batch balance queries for:</p>
<ul>
<li>Managing institutional portfolios across multiple wallets</li>
<li>Consolidated reporting for multiple trading strategies</li>
<li>Risk assessment across wallet boundaries</li>
<li>Efficient monitoring of large wallet collections</li>
</ul>
<h3 id="4-risk-management-systems"><a class="header" href="#4-risk-management-systems">4. Risk Management Systems</a></h3>
<p>Implement automated risk monitoring using:</p>
<ul>
<li>Real-time position monitoring with configurable alerts</li>
<li>Concentration risk detection and warnings</li>
<li>Position size limit enforcement</li>
<li>Automated stop-loss and profit-taking triggers</li>
</ul>
<h3 id="5-performance-analytics"><a class="header" href="#5-performance-analytics">5. Performance Analytics</a></h3>
<p>Build comprehensive analytics systems featuring:</p>
<ul>
<li>Historical performance tracking and reporting</li>
<li>Volatility analysis and risk-adjusted returns</li>
<li>Benchmark comparisons and relative performance</li>
<li>Attribution analysis across tokens and time periods</li>
</ul>
<h3 id="6-compliance-and-reporting"><a class="header" href="#6-compliance-and-reporting">6. Compliance and Reporting</a></h3>
<p>Generate regulatory and internal reports using:</p>
<ul>
<li>Complete transaction history with timestamps</li>
<li>Position statements at specific points in time</li>
<li>Profit/loss calculations for tax reporting</li>
<li>Audit trails for trading activity</li>
</ul>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<h3 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h3>
<ol>
<li>
<p><strong>Environment Setup</strong>: Ensure your <code>.env</code> file contains:</p>
<pre><code>AXIOM_EMAIL=your_email@example.com
AXIOM_PASSWORD=your_password
</code></pre>
</li>
<li>
<p><strong>Dependencies</strong>: Make sure all required dependencies are installed:</p>
<pre><code class="language-bash">cargo build
</code></pre>
</li>
</ol>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>Run individual examples using:</p>
<pre><code class="language-bash"># Basic portfolio retrieval
cargo run --example get_portfolio

# Batch balance queries  
cargo run --example batch_balances

# Real-time monitoring
cargo run --example portfolio_monitoring

# Token account analysis
cargo run --example token_accounts
</code></pre>
<h3 id="customization"><a class="header" href="#customization">Customization</a></h3>
<p>Each example can be customized by:</p>
<ul>
<li>Modifying wallet addresses to use your actual wallets</li>
<li>Adjusting monitoring intervals and alert thresholds</li>
<li>Changing analysis parameters and risk thresholds</li>
<li>Adding additional metrics and reporting features</li>
</ul>
<h3 id="error-handling-10"><a class="header" href="#error-handling-10">Error Handling</a></h3>
<p>All examples include comprehensive error handling for:</p>
<ul>
<li>Authentication failures and token expiration</li>
<li>Network connectivity issues</li>
<li>API rate limiting and throttling</li>
<li>Invalid wallet addresses or missing data</li>
<li>Graceful degradation with fallback mechanisms</li>
</ul>
<p>These examples provide a solid foundation for building sophisticated portfolio management applications using the Axiom Trade Rust client.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trading-examples"><a class="header" href="#trading-examples">Trading Examples</a></h1>
<p>This section provides comprehensive examples for using the Axiom Trade API trading functionality, including simple trades, error handling patterns, and advanced trading strategies.</p>
<h2 id="simple-trade-example"><a class="header" href="#simple-trade-example">Simple Trade Example</a></h2>
<p>The <code>simple_trade.rs</code> example demonstrates the fundamental trading operations available through the Axiom Trade API. This example serves as a starting point for understanding the trading workflow and best practices.</p>
<h3 id="overview-17"><a class="header" href="#overview-17">Overview</a></h3>
<p>The simple trade example showcases:</p>
<ul>
<li>Authentication setup for trading</li>
<li>Buy and sell operations simulation</li>
<li>Price quote retrieval</li>
<li>Parameter validation</li>
<li>Error handling patterns</li>
<li>Security best practices</li>
</ul>
<h3 id="example-walkthrough"><a class="header" href="#example-walkthrough">Example Walkthrough</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::{AuthClient, Result, AxiomError};
use axiomtrade_rs::api::trading::TradingClient;
use std::env;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Load credentials and authenticate
    dotenvy::dotenv().ok();
    let mut trading_client = authenticate().await?;

    // Trading parameters
    let token_mint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // USDC
    let amount_sol = 0.001; // Small demonstration amount
    
    // Execute buy operation
    simulate_buy_trade(&amp;mut trading_client, token_mint, amount_sol).await?;
    
    // Execute sell operation  
    let amount_tokens = 1.0; // 1 USDC
    simulate_sell_trade(&amp;mut trading_client, token_mint, amount_tokens).await?;
    
    Ok(())
}</code></pre></pre>
<h3 id="authentication-setup"><a class="header" href="#authentication-setup">Authentication Setup</a></h3>
<p>The example begins with proper authentication using environment variables:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn authenticate() -&gt; Result&lt;TradingClient&gt; {
    let email = env::var("AXIOM_EMAIL")
        .expect("AXIOM_EMAIL must be set in .env file");
    let password = env::var("AXIOM_PASSWORD")
        .expect("AXIOM_PASSWORD must be set in .env file");

    let mut auth_client = AuthClient::new()?;
    
    match auth_client.login_full(&amp;email, &amp;password, None).await {
        Ok(login_result) =&gt; {
            println!("Authentication successful!");
            println!("Access token obtained: {}", &amp;login_result.tokens.access_token[..20]);
        }
        Err(e) =&gt; {
            return Err(AxiomError::Auth(e));
        }
    }

    TradingClient::new().map_err(|e| AxiomError::Api {
        message: format!("Failed to create trading client: {}", e),
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="trade-parameters"><a class="header" href="#trade-parameters">Trade Parameters</a></h2>
<h3 id="essential-parameters"><a class="header" href="#essential-parameters">Essential Parameters</a></h3>
<p>When executing trades, several key parameters must be configured:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>token_mint</code></td><td><code>&amp;str</code></td><td>Target token mint address</td><td><code>"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"</code></td></tr>
<tr><td><code>amount</code></td><td><code>f64</code></td><td>Trade amount in base units</td><td><code>0.001</code> (SOL) or <code>1.0</code> (tokens)</td></tr>
<tr><td><code>slippage</code></td><td><code>Option&lt;f64&gt;</code></td><td>Maximum acceptable slippage percentage</td><td><code>Some(1.0)</code> (1%)</td></tr>
<tr><td><code>priority_fee</code></td><td><code>Option&lt;f64&gt;</code></td><td>Additional priority fee in SOL</td><td><code>Some(0.00001)</code></td></tr>
</tbody></table>
</div>
<h3 id="token-mint-addresses"><a class="header" href="#token-mint-addresses">Token Mint Addresses</a></h3>
<p>Common token mint addresses used in examples:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Native SOL
const SOL_MINT: &amp;str = "So11111111111111111111111111111111111111112";

// USDC
const USDC_MINT: &amp;str = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

// USDT  
const USDT_MINT: &amp;str = "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB";
<span class="boring">}</span></code></pre></pre>
<h3 id="slippage-configuration"><a class="header" href="#slippage-configuration">Slippage Configuration</a></h3>
<p>Slippage tolerance should be set based on token liquidity and market conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slippage_scenarios = vec![0.1, 0.5, 1.0, 2.0, 5.0];

for slippage in slippage_scenarios {
    let estimated_impact = calculate_slippage_impact(amount_sol, slippage);
    println!("{}% slippage tolerance - Max cost: {} SOL", 
        slippage, estimated_impact);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Recommended slippage settings:</strong></p>
<ul>
<li><strong>Liquid tokens (SOL, USDC, USDT)</strong>: 0.1% - 0.5%</li>
<li><strong>Mid-cap tokens</strong>: 0.5% - 1.0%</li>
<li><strong>Low liquidity tokens</strong>: 1.0% - 5.0%</li>
<li><strong>Volatile markets</strong>: 2.0% - 5.0%</li>
</ul>
<h2 id="error-handling-11"><a class="header" href="#error-handling-11">Error Handling</a></h2>
<p>The trading system implements comprehensive error handling patterns to ensure robust operation.</p>
<h3 id="parameter-validation"><a class="header" href="#parameter-validation">Parameter Validation</a></h3>
<p>All trading parameters undergo validation before execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_amount(amount: f64, unit: &amp;str) -&gt; Result&lt;()&gt; {
    if amount &lt;= 0.0 {
        return Err(AxiomError::Api {
            message: format!("Amount must be greater than 0, got {} {}", amount, unit),
        });
    }
    
    if amount.is_nan() || amount.is_infinite() {
        return Err(AxiomError::Api {
            message: format!("Invalid amount: {} {}", amount, unit),
        });
    }
    
    Ok(())
}

fn validate_token_mint(mint: &amp;str) -&gt; Result&lt;()&gt; {
    if mint.is_empty() {
        return Err(AxiomError::Api {
            message: "Token mint cannot be empty".to_string(),
        });
    }
    
    if mint.len() &lt; 32 || mint.len() &gt; 44 {
        return Err(AxiomError::Api {
            message: format!("Invalid mint address length: {}", mint),
        });
    }
    
    if !mint.chars().all(|c| c.is_ascii_alphanumeric()) {
        return Err(AxiomError::Api {
            message: format!("Invalid characters in mint address: {}", mint),
        });
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trading-limits-verification"><a class="header" href="#trading-limits-verification">Trading Limits Verification</a></h3>
<p>Before executing trades, the system checks against trading limits:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.get_trading_limits().await {
    Ok(limits) =&gt; {
        if amount_sol &lt; limits.min_sol_amount {
            return Err(AxiomError::Api {
                message: format!("Amount {} SOL is below minimum {}", 
                    amount_sol, limits.min_sol_amount)
            });
        }
        if amount_sol &gt; limits.max_sol_amount {
            return Err(AxiomError::Api {
                message: format!("Amount {} SOL exceeds maximum {}", 
                    amount_sol, limits.max_sol_amount)
            });
        }
    }
    Err(_) =&gt; println!("Could not verify trading limits"),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="quote-retrieval-error-handling"><a class="header" href="#quote-retrieval-error-handling">Quote Retrieval Error Handling</a></h3>
<p>Price quotes may fail due to network issues or market conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.get_quote(sol_mint, token_mint, amount_sol, Some(1.0)).await {
    Ok(quote) =&gt; {
        println!("Current swap quote:");
        println!("  Input: {} SOL", quote.in_amount);
        println!("  Output: {} tokens", quote.out_amount);
        println!("  Price impact: {:.2}%", quote.price_impact);
        println!("  Fee: {} SOL", quote.fee);
    }
    Err(e) =&gt; {
        println!("Failed to get quote: {}", e);
        // Implement retry logic or fallback strategy
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<h3 id="1-pre-trade-validation"><a class="header" href="#1-pre-trade-validation">1. Pre-Trade Validation</a></h3>
<p>Always validate all parameters before executing trades:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate trade parameters
validate_amount(amount_sol, "SOL")?;
validate_token_mint(token_mint)?;

// Check trading limits
let limits = client.get_trading_limits().await?;
ensure_within_limits(amount_sol, &amp;limits)?;

// Get current quote for verification
let quote = client.get_quote(from_mint, to_mint, amount, slippage).await?;
verify_quote_acceptable(&amp;quote)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-liquidity-assessment"><a class="header" href="#2-liquidity-assessment">2. Liquidity Assessment</a></h3>
<p>Check token liquidity before executing large trades:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn assess_liquidity(client: &amp;TradingClient, token_mint: &amp;str) -&gt; Result&lt;bool&gt; {
    match client.get_token_info(token_mint).await {
        Ok(info) =&gt; {
            println!("Token liquidity: {} SOL", info.liquidity_sol);
            println!("24h volume: {} SOL", info.volume_24h);
            
            // Consider liquid if &gt; 100 SOL liquidity and &gt; 10 SOL daily volume
            Ok(info.liquidity_sol &gt; 100.0 &amp;&amp; info.volume_24h &gt; 10.0)
        }
        Err(_) =&gt; {
            println!("Could not assess liquidity for {}", token_mint);
            Ok(false)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-slippage-management"><a class="header" href="#3-slippage-management">3. Slippage Management</a></h3>
<p>Implement dynamic slippage based on market conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_optimal_slippage(
    amount: f64, 
    liquidity: f64, 
    volatility: f64
) -&gt; f64 {
    let base_slippage = 0.5; // 0.5% base
    let liquidity_factor = (amount / liquidity).min(0.1); // Cap at 10%
    let volatility_factor = volatility.min(0.05); // Cap at 5%
    
    base_slippage + liquidity_factor + volatility_factor
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-transaction-monitoring"><a class="header" href="#4-transaction-monitoring">4. Transaction Monitoring</a></h3>
<p>Monitor transaction status after execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn monitor_transaction(
    client: &amp;TradingClient, 
    signature: &amp;str
) -&gt; Result&lt;()&gt; {
    let mut attempts = 0;
    let max_attempts = 30; // 30 seconds timeout
    
    while attempts &lt; max_attempts {
        match client.get_transaction_status(signature).await {
            Ok(status) =&gt; {
                match status.as_str() {
                    "confirmed" =&gt; {
                        println!("Transaction confirmed: {}", signature);
                        return Ok(());
                    }
                    "failed" =&gt; {
                        return Err(AxiomError::Api {
                            message: format!("Transaction failed: {}", signature),
                        });
                    }
                    _ =&gt; {
                        println!("Transaction pending... ({})", status);
                    }
                }
            }
            Err(_) =&gt; {
                println!("Could not check transaction status");
            }
        }
        
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        attempts += 1;
    }
    
    Err(AxiomError::Api {
        message: "Transaction timeout".to_string(),
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-portfolio-impact-analysis"><a class="header" href="#5-portfolio-impact-analysis">5. Portfolio Impact Analysis</a></h3>
<p>Assess how trades will affect your portfolio:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn analyze_portfolio_impact(
    client: &amp;TradingClient,
    token_mint: &amp;str,
    amount: f64,
    is_buy: bool
) -&gt; Result&lt;()&gt; {
    let portfolio = client.get_portfolio().await?;
    
    if is_buy {
        // Check if we have sufficient SOL
        if portfolio.sol_balance &lt; amount {
            return Err(AxiomError::Api {
                message: format!("Insufficient SOL balance: {} &lt; {}", 
                    portfolio.sol_balance, amount),
            });
        }
    } else {
        // Check if we have sufficient tokens to sell
        let token_balance = portfolio.get_token_balance(token_mint);
        if token_balance &lt; amount {
            return Err(AxiomError::Api {
                message: format!("Insufficient token balance: {} &lt; {}", 
                    token_balance, amount),
            });
        }
    }
    
    println!("Portfolio impact analysis passed");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-trading-patterns"><a class="header" href="#advanced-trading-patterns">Advanced Trading Patterns</a></h2>
<h3 id="1-dollar-cost-averaging-dca"><a class="header" href="#1-dollar-cost-averaging-dca">1. Dollar Cost Averaging (DCA)</a></h3>
<p>Implement systematic buying over time:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DCAStrategy {
    token_mint: String,
    amount_per_trade: f64,
    interval_hours: u64,
    total_trades: usize,
    completed_trades: usize,
}

impl DCAStrategy {
    pub async fn execute_next_trade(
        &amp;mut self, 
        client: &amp;mut TradingClient
    ) -&gt; Result&lt;()&gt; {
        if self.completed_trades &gt;= self.total_trades {
            return Err(AxiomError::Api {
                message: "DCA strategy completed".to_string(),
            });
        }
        
        println!("Executing DCA trade {}/{}", 
            self.completed_trades + 1, self.total_trades);
            
        // Execute buy with current market conditions
        let result = client.buy_token(
            &amp;self.token_mint,
            self.amount_per_trade,
            Some(1.0) // 1% slippage tolerance
        ).await?;
        
        self.completed_trades += 1;
        
        println!("DCA trade executed: {}", result.signature);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-grid-trading"><a class="header" href="#2-grid-trading">2. Grid Trading</a></h3>
<p>Implement grid trading strategy:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GridStrategy {
    token_mint: String,
    base_price: f64,
    grid_spacing: f64,
    grid_levels: usize,
    amount_per_level: f64,
    buy_orders: Vec&lt;GridOrder&gt;,
    sell_orders: Vec&lt;GridOrder&gt;,
}

#[derive(Debug)]
pub struct GridOrder {
    price: f64,
    amount: f64,
    executed: bool,
}

impl GridStrategy {
    pub fn new(
        token_mint: String,
        base_price: f64,
        grid_spacing: f64,
        grid_levels: usize,
        amount_per_level: f64,
    ) -&gt; Self {
        let mut buy_orders = Vec::new();
        let mut sell_orders = Vec::new();
        
        // Create buy orders below current price
        for i in 1..=grid_levels {
            let price = base_price * (1.0 - (i as f64 * grid_spacing));
            buy_orders.push(GridOrder {
                price,
                amount: amount_per_level,
                executed: false,
            });
        }
        
        // Create sell orders above current price
        for i in 1..=grid_levels {
            let price = base_price * (1.0 + (i as f64 * grid_spacing));
            sell_orders.push(GridOrder {
                price,
                amount: amount_per_level,
                executed: false,
            });
        }
        
        Self {
            token_mint,
            base_price,
            grid_spacing,
            grid_levels,
            amount_per_level,
            buy_orders,
            sell_orders,
        }
    }
    
    pub async fn check_and_execute(
        &amp;mut self, 
        client: &amp;mut TradingClient,
        current_price: f64
    ) -&gt; Result&lt;()&gt; {
        // Check buy orders
        for order in &amp;mut self.buy_orders {
            if !order.executed &amp;&amp; current_price &lt;= order.price {
                println!("Executing grid buy at {}", order.price);
                
                match client.buy_token(&amp;self.token_mint, order.amount, Some(0.5)).await {
                    Ok(_) =&gt; {
                        order.executed = true;
                        println!("Grid buy executed successfully");
                    }
                    Err(e) =&gt; {
                        println!("Grid buy failed: {}", e);
                    }
                }
            }
        }
        
        // Check sell orders
        for order in &amp;mut self.sell_orders {
            if !order.executed &amp;&amp; current_price &gt;= order.price {
                println!("Executing grid sell at {}", order.price);
                
                match client.sell_token(&amp;self.token_mint, order.amount, Some(0.5)).await {
                    Ok(_) =&gt; {
                        order.executed = true;
                        println!("Grid sell executed successfully");
                    }
                    Err(e) =&gt; {
                        println!("Grid sell failed: {}", e);
                    }
                }
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-stop-loss-implementation"><a class="header" href="#3-stop-loss-implementation">3. Stop Loss Implementation</a></h3>
<p>Implement automatic stop loss orders:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StopLossManager {
    positions: Vec&lt;StopLossPosition&gt;,
}

#[derive(Debug)]
pub struct StopLossPosition {
    token_mint: String,
    entry_price: f64,
    amount: f64,
    stop_loss_percent: f64,
    trailing: bool,
    highest_price: f64,
}

impl StopLossManager {
    pub async fn check_positions(
        &amp;mut self,
        client: &amp;mut TradingClient
    ) -&gt; Result&lt;()&gt; {
        for position in &amp;mut self.positions {
            // Get current price
            let current_price = self.get_current_price(client, &amp;position.token_mint).await?;
            
            // Update trailing stop
            if position.trailing &amp;&amp; current_price &gt; position.highest_price {
                position.highest_price = current_price;
            }
            
            // Calculate stop loss price
            let reference_price = if position.trailing {
                position.highest_price
            } else {
                position.entry_price
            };
            
            let stop_price = reference_price * (1.0 - position.stop_loss_percent / 100.0);
            
            // Execute stop loss if triggered
            if current_price &lt;= stop_price {
                println!("Stop loss triggered for {} at price {}", 
                    position.token_mint, current_price);
                    
                match client.sell_token(&amp;position.token_mint, position.amount, Some(2.0)).await {
                    Ok(result) =&gt; {
                        println!("Stop loss executed: {}", result.signature);
                        // Remove position after execution
                    }
                    Err(e) =&gt; {
                        println!("Stop loss execution failed: {}", e);
                    }
                }
            }
        }
        
        Ok(())
    }
    
    async fn get_current_price(
        &amp;self,
        client: &amp;TradingClient,
        token_mint: &amp;str
    ) -&gt; Result&lt;f64&gt; {
        let sol_mint = "So11111111111111111111111111111111111111112";
        let quote = client.get_quote(token_mint, sol_mint, 1.0, Some(0.5)).await?;
        Ok(quote.out_amount)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-arbitrage-detection"><a class="header" href="#4-arbitrage-detection">4. Arbitrage Detection</a></h3>
<p>Detect arbitrage opportunities across different markets:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArbitrageScanner {
    min_profit_percent: f64,
    max_trade_amount: f64,
}

#[derive(Debug)]
pub struct ArbitrageOpportunity {
    token_mint: String,
    buy_market: String,
    sell_market: String,
    buy_price: f64,
    sell_price: f64,
    profit_percent: f64,
    max_amount: f64,
}

impl ArbitrageScanner {
    pub async fn scan_opportunities(
        &amp;self,
        client: &amp;TradingClient,
        tokens: &amp;[String]
    ) -&gt; Result&lt;Vec&lt;ArbitrageOpportunity&gt;&gt; {
        let mut opportunities = Vec::new();
        
        for token in tokens {
            // Get prices from different markets/DEXs
            let prices = self.get_multi_market_prices(client, token).await?;
            
            if prices.len() &lt; 2 {
                continue;
            }
            
            // Find min and max prices
            let min_price_market = prices.iter().min_by(|a, b| 
                a.price.partial_cmp(&amp;b.price).unwrap()).unwrap();
            let max_price_market = prices.iter().max_by(|a, b| 
                a.price.partial_cmp(&amp;b.price).unwrap()).unwrap();
            
            let profit_percent = 
                (max_price_market.price - min_price_market.price) / 
                min_price_market.price * 100.0;
            
            if profit_percent &gt;= self.min_profit_percent {
                opportunities.push(ArbitrageOpportunity {
                    token_mint: token.clone(),
                    buy_market: min_price_market.market.clone(),
                    sell_market: max_price_market.market.clone(),
                    buy_price: min_price_market.price,
                    sell_price: max_price_market.price,
                    profit_percent,
                    max_amount: self.max_trade_amount.min(min_price_market.liquidity),
                });
            }
        }
        
        Ok(opportunities)
    }
    
    async fn get_multi_market_prices(
        &amp;self,
        client: &amp;TradingClient,
        token: &amp;str
    ) -&gt; Result&lt;Vec&lt;MarketPrice&gt;&gt; {
        // Implementation would query multiple DEXs/markets
        // This is a simplified example
        Ok(vec![])
    }
}

#[derive(Debug)]
struct MarketPrice {
    market: String,
    price: f64,
    liquidity: f64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-the-examples-1"><a class="header" href="#running-the-examples-1">Running the Examples</a></h2>
<p>To run the trading examples:</p>
<ol>
<li>
<p><strong>Set up environment variables:</strong></p>
<pre><code class="language-bash">cp .env.example .env
# Edit .env with your credentials
</code></pre>
</li>
<li>
<p><strong>Run the simple trade example:</strong></p>
<pre><code class="language-bash">cargo run --example simple_trade
</code></pre>
</li>
<li>
<p><strong>Run with debug output:</strong></p>
<pre><code class="language-bash">RUST_LOG=debug cargo run --example simple_trade
</code></pre>
</li>
<li>
<p><strong>Run specific trading strategy:</strong></p>
<pre><code class="language-bash">cargo run --example grid_trading
cargo run --example dca_strategy  
cargo run --example stop_loss
</code></pre>
</li>
</ol>
<h2 id="security-considerations-7"><a class="header" href="#security-considerations-7">Security Considerations</a></h2>
<h3 id="never-share-sensitive-information"><a class="header" href="#never-share-sensitive-information">Never share sensitive information:</a></h3>
<ul>
<li>Private keys or seed phrases</li>
<li>Access tokens or refresh tokens</li>
<li>API credentials</li>
<li>Trading strategies or positions</li>
</ul>
<h3 id="always-verify-before-execution"><a class="header" href="#always-verify-before-execution">Always verify before execution:</a></h3>
<ul>
<li>Transaction details and amounts</li>
<li>Recipient addresses and token mints</li>
<li>Slippage tolerance and fees</li>
<li>Market conditions and liquidity</li>
</ul>
<h3 id="use-appropriate-security-measures"><a class="header" href="#use-appropriate-security-measures">Use appropriate security measures:</a></h3>
<ul>
<li>Hardware wallets for large amounts</li>
<li>Multi-signature wallets for institutional use</li>
<li>MEV protection services during high volatility</li>
<li>Regular security audits of trading strategies</li>
</ul>
<h3 id="monitor-for-suspicious-activity"><a class="header" href="#monitor-for-suspicious-activity">Monitor for suspicious activity:</a></h3>
<ul>
<li>Unexpected price movements</li>
<li>Failed transactions or errors</li>
<li>Unusual network latency</li>
<li>Account access from unknown locations</li>
</ul>
<p>The trading examples provide a comprehensive foundation for building sophisticated trading applications while maintaining security and reliability standards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-examples"><a class="header" href="#websocket-examples">WebSocket Examples</a></h1>
<p>This section demonstrates how to use WebSocket connections for real-time data streaming from Axiom Trade. WebSocket connections provide low-latency access to market updates, trade notifications, order status changes, and portfolio balance updates.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="examples/websocket.html#basic-websocket-connection">Basic WebSocket Connection</a></li>
<li><a href="examples/websocket.html#price-subscriptions">Price Subscriptions</a></li>
<li><a href="examples/websocket.html#messagehandler-implementations">MessageHandler Implementations</a></li>
<li><a href="examples/websocket.html#connection-management">Connection Management</a></li>
<li><a href="examples/websocket.html#real-world-use-cases">Real-World Use Cases</a></li>
<li><a href="examples/websocket.html#error-handling">Error Handling</a></li>
<li><a href="examples/websocket.html#performance-considerations">Performance Considerations</a></li>
</ul>
<h2 id="basic-websocket-connection-1"><a class="header" href="#basic-websocket-connection-1">Basic WebSocket Connection</a></h2>
<p>The simplest way to establish a WebSocket connection and receive real-time updates.</p>
<h3 id="example-basic_websocketrs"><a class="header" href="#example-basic_websocketrs">Example: basic_websocket.rs</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::websocket::{WebSocketClient, MessageHandler, WebSocketMessage};
use async_trait::async_trait;
use std::sync::Arc;
use std::time::Duration;
use tokio::time::sleep;

/// Simple message handler that prints incoming messages
struct BasicMessageHandler;

#[async_trait]
impl MessageHandler for BasicMessageHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                println!("Market Update: {} - ${:.6}", update.symbol, update.price_usd);
            }
            WebSocketMessage::OrderUpdate(order) =&gt; {
                println!("Order Update: {} - {:?}", order.order_id, order.status);
            }
            WebSocketMessage::TradeUpdate(trade) =&gt; {
                println!("Trade Update: {} - ${:.6}", trade.token_mint, trade.price);
            }
            WebSocketMessage::BalanceUpdate(balance) =&gt; {
                println!("Balance Update: {} SOL", balance.sol_balance);
            }
            WebSocketMessage::Connected { session_id } =&gt; {
                println!("Connected with session: {}", session_id);
            }
            WebSocketMessage::Disconnected { reason } =&gt; {
                println!("Disconnected: {}", reason);
            }
            WebSocketMessage::Error { code, message } =&gt; {
                println!("WebSocket Error {}: {}", code, message);
            }
            _ =&gt; {
                println!("Other message: {:?}", message);
            }
        }
    }

    async fn on_connected(&amp;self, session_id: String) {
        println!("WebSocket connected! Session ID: {}", session_id);
    }

    async fn on_disconnected(&amp;self, reason: String) {
        println!("WebSocket disconnected: {}", reason);
    }

    async fn on_error(&amp;self, error: String) {
        println!("WebSocket error: {}", error);
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Create message handler and WebSocket client
    let handler = Arc::new(BasicMessageHandler);
    let mut ws_client = WebSocketClient::new(handler.clone())?;
    
    // Connect to WebSocket (authentication is handled internally)
    ws_client.connect().await?;
    
    // Subscribe to new token listings
    ws_client.subscribe_new_tokens().await?;
    
    // Monitor the connection for 30 seconds
    let monitoring_duration = Duration::from_secs(30);
    let start_time = std::time::Instant::now();

    while start_time.elapsed() &lt; monitoring_duration {
        if !ws_client.is_connected().await {
            println!("Connection lost, attempting reconnection...");
            ws_client.reconnect().await?;
        }
        sleep(Duration::from_millis(1000)).await;
    }

    // Graceful disconnect
    ws_client.disconnect().await;
    println!("WebSocket disconnected gracefully");

    Ok(())
}</code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Simple connection establishment with automatic authentication</li>
<li>Basic message handling for different event types</li>
<li>Connection health monitoring with automatic reconnection</li>
<li>Graceful disconnection</li>
</ul>
<h2 id="price-subscriptions"><a class="header" href="#price-subscriptions">Price Subscriptions</a></h2>
<p>Advanced example demonstrating subscription to multiple token price feeds with real-time tracking.</p>
<h3 id="example-price_subscriptionsrs"><a class="header" href="#example-price_subscriptionsrs">Example: price_subscriptions.rs</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::websocket::{WebSocketClient, MessageHandler, WebSocketMessage};
use async_trait::async_trait;
use std::sync::Arc;
use std::time::Duration;
use std::collections::HashMap;
use tokio::time::sleep;
use tokio::sync::RwLock;

/// Price tracking message handler
struct PriceMessageHandler {
    price_tracker: Arc&lt;RwLock&lt;PriceTracker&gt;&gt;,
}

impl PriceMessageHandler {
    fn new(price_tracker: Arc&lt;RwLock&lt;PriceTracker&gt;&gt;) -&gt; Self {
        Self { price_tracker }
    }
}

#[async_trait]
impl MessageHandler for PriceMessageHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                let mut tracker = self.price_tracker.write().await;
                tracker.update_price(
                    &amp;update.symbol, 
                    update.price_usd, 
                    Some(update.volume_24h), 
                    Some(update.price_change_24h)
                ).await;
            }
            WebSocketMessage::TradeUpdate(trade) =&gt; {
                println!("Trade: {} - ${:.6}", trade.token_mint, trade.price);
            }
            _ =&gt; {}
        }
    }

    async fn on_connected(&amp;self, session_id: String) {
        println!("WebSocket connected! Session ID: {}", session_id);
    }

    async fn on_disconnected(&amp;self, reason: String) {
        println!("WebSocket disconnected: {}", reason);
    }

    async fn on_error(&amp;self, error: String) {
        println!("WebSocket error: {}", error);
    }
}

struct PriceTracker {
    prices: HashMap&lt;String, PriceData&gt;,
    update_count: u64,
}

struct PriceData {
    symbol: String,
    current_price: f64,
    previous_price: f64,
    high_24h: f64,
    low_24h: f64,
    volume_24h: f64,
    change_24h: f64,
    last_updated: std::time::Instant,
    update_count: u32,
}

impl PriceTracker {
    fn new() -&gt; Self {
        Self {
            prices: HashMap::new(),
            update_count: 0,
        }
    }

    async fn update_price(&amp;mut self, symbol: &amp;str, price: f64, volume: Option&lt;f64&gt;, change: Option&lt;f64&gt;) {
        self.update_count += 1;
        
        let price_data = self.prices.entry(symbol.to_string()).or_insert(PriceData {
            symbol: symbol.to_string(),
            current_price: price,
            previous_price: price,
            high_24h: price,
            low_24h: price,
            volume_24h: volume.unwrap_or(0.0),
            change_24h: change.unwrap_or(0.0),
            last_updated: std::time::Instant::now(),
            update_count: 0,
        });

        price_data.previous_price = price_data.current_price;
        price_data.current_price = price;
        
        if price &gt; price_data.high_24h {
            price_data.high_24h = price;
        }
        if price &lt; price_data.low_24h {
            price_data.low_24h = price;
        }
        
        if let Some(vol) = volume {
            price_data.volume_24h = vol;
        }
        if let Some(chg) = change {
            price_data.change_24h = chg;
        }
        
        price_data.last_updated = std::time::Instant::now();
        price_data.update_count += 1;

        // Display real-time update with direction indicator
        let direction = if price &gt; price_data.previous_price {
            "📈"
        } else if price &lt; price_data.previous_price {
            "📉"
        } else {
            "➡️"
        };

        println!("{} {} ${:.6} ({})", 
            chrono::Utc::now().format("%H:%M:%S"),
            symbol,
            price,
            direction
        );
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    dotenvy::dotenv().ok();

    // Create price tracker and message handler
    let price_tracker = Arc::new(RwLock::new(PriceTracker::new()));
    let handler = Arc::new(PriceMessageHandler::new(price_tracker.clone()));
    let mut ws_client = WebSocketClient::new(handler.clone())?;
    
    // Connect to WebSocket
    ws_client.connect().await?;

    // Subscribe to new token listings for general market updates
    ws_client.subscribe_new_tokens().await?;

    // Define tokens to monitor for specific price updates
    let tokens_to_watch = vec![
        ("SOL", "So11111111111111111111111111111111111111112"),
        ("USDC", "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
        ("BONK", "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"),
        ("WIF", "EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm"),
        ("PEPE", "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),
    ];

    // Subscribe to price feeds for multiple tokens
    for (symbol, mint) in &amp;tokens_to_watch {
        match ws_client.subscribe_token_price(mint).await {
            Ok(()) =&gt; println!("✓ Subscribed to {} price feed", symbol),
            Err(e) =&gt; println!("❌ Failed to subscribe to {}: {}", symbol, e),
        }
        sleep(Duration::from_millis(100)).await;
    }

    // Monitor prices for 2 minutes
    let monitoring_duration = Duration::from_secs(120);
    let start_time = std::time::Instant::now();
    let mut last_summary = std::time::Instant::now();

    while start_time.elapsed() &lt; monitoring_duration {
        // Check connection health
        if !ws_client.is_connected().await {
            println!("Connection lost, reconnecting...");
            ws_client.reconnect().await?;
            
            // Re-subscribe after reconnection
            ws_client.subscribe_new_tokens().await.ok();
            for (_symbol, mint) in &amp;tokens_to_watch {
                ws_client.subscribe_token_price(mint).await.ok();
            }
        }

        // Show periodic summary every 30 seconds
        if last_summary.elapsed() &gt;= Duration::from_secs(30) {
            show_price_summary(&amp;price_tracker).await;
            last_summary = std::time::Instant::now();
        }

        sleep(Duration::from_millis(500)).await;
    }

    // Final summary and disconnect
    show_detailed_summary(&amp;price_tracker).await;
    ws_client.disconnect().await;

    Ok(())
}

async fn show_price_summary(price_tracker: &amp;Arc&lt;RwLock&lt;PriceTracker&gt;&gt;) {
    let tracker = price_tracker.read().await;
    println!("\n📊 Price Summary ({} updates total):", tracker.update_count);
    println!("{:&lt;8} {:&gt;12} {:&gt;12} {:&gt;12} {:&gt;8}", "Symbol", "Price", "24h Change", "Volume", "Updates");
    println!("{}", "-".repeat(60));
    
    for symbol in tracker.get_symbols() {
        if let Some(data) = tracker.get_price_data(&amp;symbol) {
            println!("{:&lt;8} {:&gt;12.6} {:&gt;11.2}% {:&gt;12.0} {:&gt;8}", 
                data.symbol,
                data.current_price,
                data.change_24h,
                data.volume_24h,
                data.update_count
            );
        }
    }
}</code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Multi-token price subscription management</li>
<li>Real-time price tracking with historical data</li>
<li>Periodic summary reports</li>
<li>Automatic re-subscription after reconnection</li>
<li>Visual price direction indicators</li>
</ul>
<h2 id="messagehandler-implementations"><a class="header" href="#messagehandler-implementations">MessageHandler Implementations</a></h2>
<h3 id="default-messagehandler"><a class="header" href="#default-messagehandler">Default MessageHandler</a></h3>
<p>The library provides a built-in <code>DefaultMessageHandler</code> for basic use cases:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::websocket::handler::DefaultMessageHandler;

// Create default handler that stores all updates
let handler = Arc::new(DefaultMessageHandler::new());
let ws_client = WebSocketClient::new(handler.clone())?;

// After some time, retrieve stored updates
let market_updates = handler.get_market_updates().await;
let order_updates = handler.get_order_updates().await;
let trade_updates = handler.get_trade_updates().await;
let balance_updates = handler.get_balance_updates().await;

// Clear stored data to manage memory
handler.clear_all().await;
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-messagehandler"><a class="header" href="#custom-messagehandler">Custom MessageHandler</a></h3>
<p>Implement the <code>MessageHandler</code> trait for custom behavior:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::websocket::{MessageHandler, WebSocketMessage};
use async_trait::async_trait;

struct CustomHandler {
    // Your custom fields
}

#[async_trait]
impl MessageHandler for CustomHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        // Custom message processing logic
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                // Process market updates
                self.process_market_data(update).await;
            }
            WebSocketMessage::OrderUpdate(order) =&gt; {
                // Handle order status changes
                self.update_order_status(order).await;
            }
            WebSocketMessage::TradeUpdate(trade) =&gt; {
                // Log trade executions
                self.log_trade(trade).await;
            }
            WebSocketMessage::BalanceUpdate(balance) =&gt; {
                // Update portfolio tracking
                self.update_portfolio(balance).await;
            }
            _ =&gt; {}
        }
    }

    async fn on_connected(&amp;self, session_id: String) {
        // Connection established logic
        println!("Connected: {}", session_id);
    }

    async fn on_disconnected(&amp;self, reason: String) {
        // Cleanup on disconnection
        println!("Disconnected: {}", reason);
    }

    async fn on_error(&amp;self, error: String) {
        // Error handling
        eprintln!("Error: {}", error);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h2>
<h3 id="regional-selection"><a class="header" href="#regional-selection">Regional Selection</a></h3>
<p>Choose optimal regions for better latency:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::websocket::{WebSocketClient, Region};

// Use specific region for better performance
let ws_client = WebSocketClient::with_region(handler, Region::USWest)?;

// Available regions:
// - Region::USWest
// - Region::USCentral  
// - Region::USEast
// - Region::EUWest
// - Region::EUCentral
// - Region::EUEast
// - Region::Asia
// - Region::Australia
// - Region::Global (default)
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-health-monitoring-1"><a class="header" href="#connection-health-monitoring-1">Connection Health Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check connection status
let is_connected = ws_client.is_connected().await;

// Manual reconnection
if !is_connected {
    ws_client.reconnect().await?;
}

// Get current subscriptions
let subscriptions = ws_client.get_subscriptions().await;
println!("Active subscriptions: {:?}", subscriptions);

// Enable automatic token refresh
let ws_client = WebSocketClient::with_auto_refresh(handler, true)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="subscription-management"><a class="header" href="#subscription-management">Subscription Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to different data feeds
ws_client.subscribe_new_tokens().await?;
ws_client.subscribe_token_price("token_mint_address").await?;
ws_client.subscribe_portfolio_updates().await?;
ws_client.subscribe_order_updates().await?;

// Unsubscribe from feeds
ws_client.unsubscribe_token_price("token_mint_address").await?;
ws_client.unsubscribe_new_tokens().await?;

// Check active subscriptions
let active_subs = ws_client.get_subscriptions().await;
for subscription in active_subs {
    println!("Active: {:?}", subscription);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="trading-bot-with-real-time-signals"><a class="header" href="#trading-bot-with-real-time-signals">Trading Bot with Real-Time Signals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TradingBotHandler {
    trading_client: Arc&lt;TradingClient&gt;,
    strategy: Arc&lt;TradingStrategy&gt;,
}

#[async_trait]
impl MessageHandler for TradingBotHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                // Analyze market data for trading signals
                if let Some(signal) = self.strategy.analyze_market(&amp;update).await {
                    match signal {
                        TradingSignal::Buy { token, amount } =&gt; {
                            self.trading_client.execute_buy(&amp;token, amount).await.ok();
                        }
                        TradingSignal::Sell { token, amount } =&gt; {
                            self.trading_client.execute_sell(&amp;token, amount).await.ok();
                        }
                    }
                }
            }
            WebSocketMessage::OrderUpdate(order) =&gt; {
                // Track order execution
                self.strategy.update_order_status(order).await;
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="portfolio-monitoring-dashboard"><a class="header" href="#portfolio-monitoring-dashboard">Portfolio Monitoring Dashboard</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DashboardHandler {
    portfolio_state: Arc&lt;RwLock&lt;PortfolioState&gt;&gt;,
    alert_system: Arc&lt;AlertSystem&gt;,
}

#[async_trait]
impl MessageHandler for DashboardHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        match message {
            WebSocketMessage::BalanceUpdate(balance) =&gt; {
                let mut portfolio = self.portfolio_state.write().await;
                portfolio.update_balance(balance).await;
                
                // Check for alerts
                if portfolio.total_value_usd &lt; portfolio.stop_loss_threshold {
                    self.alert_system.send_alert(AlertType::StopLoss).await;
                }
            }
            WebSocketMessage::MarketUpdate(update) =&gt; {
                // Update portfolio value based on price changes
                let mut portfolio = self.portfolio_state.write().await;
                portfolio.update_token_price(&amp;update.token_mint, update.price_usd).await;
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="price-alert-system"><a class="header" href="#price-alert-system">Price Alert System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PriceAlertHandler {
    alert_rules: Arc&lt;RwLock&lt;Vec&lt;PriceAlert&gt;&gt;&gt;,
    notification_service: Arc&lt;NotificationService&gt;,
}

#[async_trait]
impl MessageHandler for PriceAlertHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        if let WebSocketMessage::MarketUpdate(update) = message {
            let alerts = self.alert_rules.read().await;
            
            for alert in alerts.iter() {
                if alert.token_mint == update.token_mint {
                    let triggered = match alert.condition {
                        AlertCondition::PriceAbove(price) =&gt; update.price_usd &gt; price,
                        AlertCondition::PriceBelow(price) =&gt; update.price_usd &lt; price,
                        AlertCondition::PriceChange(change) =&gt; update.price_change_24h.abs() &gt; change,
                    };
                    
                    if triggered {
                        self.notification_service.send_alert(&amp;alert, &amp;update).await;
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-12"><a class="header" href="#error-handling-12">Error Handling</a></h2>
<h3 id="connection-error-recovery"><a class="header" href="#connection-error-recovery">Connection Error Recovery</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn robust_websocket_connection() -&gt; Result&lt;(), WebSocketError&gt; {
    let handler = Arc::new(MyHandler::new());
    let mut ws_client = WebSocketClient::new(handler)?;
    
    let mut retry_count = 0;
    const MAX_RETRIES: u32 = 5;
    
    loop {
        match ws_client.connect().await {
            Ok(()) =&gt; {
                println!("Connected successfully");
                break;
            }
            Err(WebSocketError::AuthError(_)) =&gt; {
                // Authentication failed - check credentials
                eprintln!("Authentication failed - check credentials");
                return Err(WebSocketError::AuthError(AuthError::InvalidCredentials));
            }
            Err(e) if retry_count &lt; MAX_RETRIES =&gt; {
                retry_count += 1;
                eprintln!("Connection failed (attempt {}): {}", retry_count, e);
                tokio::time::sleep(Duration::from_secs(2_u64.pow(retry_count))).await;
            }
            Err(e) =&gt; {
                eprintln!("Failed to connect after {} attempts: {}", MAX_RETRIES, e);
                return Err(e);
            }
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="message-processing-error-handling"><a class="header" href="#message-processing-error-handling">Message Processing Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl MessageHandler for RobustHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        // Wrap message processing in error handling
        if let Err(e) = self.process_message_safe(message).await {
            eprintln!("Failed to process message: {}", e);
            
            // Optionally log error or send to monitoring system
            self.error_logger.log_error(e).await;
        }
    }
    
    async fn on_error(&amp;self, error: String) {
        // Implement sophisticated error handling
        if error.contains("token_expired") {
            // Trigger token refresh
            self.auth_client.refresh_token().await.ok();
        } else if error.contains("rate_limit") {
            // Implement backoff strategy
            self.apply_rate_limit_backoff().await;
        }
    }
}

impl RobustHandler {
    async fn process_message_safe(&amp;self, message: WebSocketMessage) -&gt; Result&lt;(), ProcessingError&gt; {
        match message {
            WebSocketMessage::MarketUpdate(update) =&gt; {
                self.validate_market_update(&amp;update)?;
                self.store_market_update(update).await?;
            }
            WebSocketMessage::Error { code, message } =&gt; {
                self.handle_websocket_error(code, &amp;message).await?;
            }
            _ =&gt; {}
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use bounded channels for message queuing
struct MemoryEfficientHandler {
    message_queue: Arc&lt;RwLock&lt;VecDeque&lt;WebSocketMessage&gt;&gt;&gt;,
    max_queue_size: usize,
}

#[async_trait]
impl MessageHandler for MemoryEfficientHandler {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        let mut queue = self.message_queue.write().await;
        
        // Prevent memory leaks by limiting queue size
        if queue.len() &gt;= self.max_queue_size {
            queue.pop_front(); // Remove oldest message
        }
        
        queue.push_back(message);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BatchProcessor {
    batch_buffer: Arc&lt;RwLock&lt;Vec&lt;MarketUpdate&gt;&gt;&gt;,
    batch_size: usize,
}

#[async_trait]
impl MessageHandler for BatchProcessor {
    async fn handle_message(&amp;self, message: WebSocketMessage) {
        if let WebSocketMessage::MarketUpdate(update) = message {
            let mut buffer = self.batch_buffer.write().await;
            buffer.push(update);
            
            // Process in batches for efficiency
            if buffer.len() &gt;= self.batch_size {
                let batch = buffer.drain(..).collect::&lt;Vec&lt;_&gt;&gt;();
                drop(buffer); // Release lock before processing
                
                self.process_batch(batch).await;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-optimization"><a class="header" href="#connection-optimization">Connection Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use connection pooling for high-frequency applications
struct OptimizedWebSocketClient {
    primary_connection: WebSocketClient,
    backup_connections: Vec&lt;WebSocketClient&gt;,
    load_balancer: LoadBalancer,
}

impl OptimizedWebSocketClient {
    async fn send_with_failover(&amp;mut self, message: &amp;str) -&gt; Result&lt;(), WebSocketError&gt; {
        // Try primary connection first
        if let Err(_) = self.primary_connection.send(message).await {
            // Failover to backup connections
            for backup in &amp;mut self.backup_connections {
                if backup.is_connected().await {
                    return backup.send(message).await;
                }
            }
        }
        
        Err(WebSocketError::NotConnected)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive guide covers all aspects of WebSocket usage in the Axiom Trade Rust library, from basic connections to advanced real-world implementations. The examples demonstrate proper error handling, performance optimization, and various use cases for different trading scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h1>
<p>This section covers sophisticated trading applications that demonstrate advanced patterns, optimizations, and multi-system integrations using the Axiom Trade Rust SDK.</p>
<h2 id="overview-18"><a class="header" href="#overview-18">Overview</a></h2>
<p>The advanced examples showcase production-ready implementations for:</p>
<ul>
<li><strong>Automated Trading Bots</strong>: Multi-strategy algorithmic trading systems</li>
<li><strong>High-Frequency Trading</strong>: Ultra-low latency optimization techniques</li>
<li><strong>Multi-Chain Portfolio Management</strong>: Cross-blockchain asset management</li>
</ul>
<p>Each example includes comprehensive architecture patterns, performance optimizations, and real-world considerations for professional trading systems.</p>
<h2 id="automated-trading-bot"><a class="header" href="#automated-trading-bot">Automated Trading Bot</a></h2>
<p><strong>Location</strong>: <code>examples/advanced/automated_trading_bot.rs</code></p>
<h3 id="overview-19"><a class="header" href="#overview-19">Overview</a></h3>
<p>A sophisticated automated trading bot demonstrating multiple strategies, risk management, and performance monitoring. This example shows how to build a production-ready algorithmic trading system.</p>
<h3 id="architecture-patterns"><a class="header" href="#architecture-patterns">Architecture Patterns</a></h3>
<h4 id="strategy-engine-pattern"><a class="header" href="#strategy-engine-pattern">Strategy Engine Pattern</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TradingStrategyTrait {
    fn name(&amp;self) -&gt; &amp;str;
    fn generate_signal(&amp;self, market_data: &amp;MarketData) -&gt; Option&lt;TradingSignal&gt;;
}

struct StrategyEngine {
    strategies: Vec&lt;Box&lt;dyn TradingStrategyTrait&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The strategy engine implements a pluggable architecture allowing multiple trading strategies to operate simultaneously:</p>
<ul>
<li><strong>DCA Strategy</strong>: Dollar-cost averaging for consistent market entry</li>
<li><strong>Momentum Strategy</strong>: Trend-following with technical indicators</li>
<li><strong>Arbitrage Strategy</strong>: Cross-exchange price discrepancy exploitation</li>
</ul>
<h4 id="position-management-pattern"><a class="header" href="#position-management-pattern">Position Management Pattern</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PositionManager {
    positions: HashMap&lt;String, Position&gt;,
}

impl PositionManager {
    fn update_position(&amp;mut self, trade_result: &amp;TradeResult);
    async fn check_positions(&amp;self, market_data: &amp;MarketData) -&gt; Vec&lt;PositionUpdate&gt;;
    fn get_open_positions(&amp;self) -&gt; Vec&lt;&amp;Position&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Centralized position tracking with automated monitoring for:</p>
<ul>
<li>Stop-loss triggers</li>
<li>Take-profit execution</li>
<li>Trailing stop adjustments</li>
<li>Position size validation</li>
</ul>
<h4 id="risk-management-system"><a class="header" href="#risk-management-system">Risk Management System</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RiskMonitor {
    config: RiskManagement,
}

#[derive(Debug, Clone)]
struct RiskManagement {
    max_portfolio_risk: f64,
    max_single_trade_risk: f64,
    stop_loss_percentage: f64,
    daily_loss_limit: f64,
    position_sizing: PositionSizing,
}
<span class="boring">}</span></code></pre></pre>
<p>Comprehensive risk controls including:</p>
<ul>
<li>Portfolio-level risk limits</li>
<li>Per-trade size restrictions</li>
<li>Daily loss limits</li>
<li>Dynamic position sizing</li>
</ul>
<h3 id="key-features-5"><a class="header" href="#key-features-5">Key Features</a></h3>
<h4 id="1-multi-strategy-configuration"><a class="header" href="#1-multi-strategy-configuration">1. Multi-Strategy Configuration</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bot_config = TradingBotConfig {
    strategies: vec![
        TradingStrategy::DcaStrategy {
            interval: Duration::from_secs(3600),
            amount_per_trade: 100.0,
            tokens: vec!["SOL".to_string(), "BTC".to_string()],
        },
        TradingStrategy::MomentumStrategy {
            lookback_period: Duration::from_secs(3600 * 24),
            momentum_threshold: 5.0,
            stop_loss: 2.0,
            take_profit: 8.0,
        },
        TradingStrategy::ArbitrageStrategy {
            min_profit_threshold: 0.5,
            max_position_size: 1000.0,
            supported_exchanges: vec!["axiom".to_string(), "hyperliquid".to_string()],
        },
    ],
    // ... additional configuration
};
<span class="boring">}</span></code></pre></pre>
<h4 id="2-real-time-market-data-processing"><a class="header" href="#2-real-time-market-data-processing">2. Real-Time Market Data Processing</a></h4>
<ul>
<li>WebSocket connections for live price feeds</li>
<li>Multi-token subscription management</li>
<li>Tick-by-tick processing with minimal latency</li>
</ul>
<h4 id="3-automated-execution-engine"><a class="header" href="#3-automated-execution-engine">3. Automated Execution Engine</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ExecutionSettings {
    slippage_tolerance: f64,
    timeout_seconds: u64,
    retry_attempts: u32,
    use_mev_protection: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Features MEV protection, retry logic, and slippage management for optimal execution.</p>
<h4 id="4-performance-monitoring"><a class="header" href="#4-performance-monitoring">4. Performance Monitoring</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FinalPerformanceReport {
    total_trades: u32,
    successful_trades: u32,
    success_rate: f64,
    total_pnl: f64,
    max_drawdown: f64,
    sharpe_ratio: f64,
    strategy_performance: Vec&lt;StrategyPerformance&gt;,
    risk_rejected_trades: u32,
    // ... additional metrics
}
<span class="boring">}</span></code></pre></pre>
<p>Comprehensive performance tracking with strategy-specific analytics and risk metrics.</p>
<h2 id="high-frequency-trading"><a class="header" href="#high-frequency-trading">High-Frequency Trading</a></h2>
<p><strong>Location</strong>: <code>examples/advanced/high_frequency_trading.rs</code></p>
<h3 id="overview-20"><a class="header" href="#overview-20">Overview</a></h3>
<p>Ultra-low latency trading system demonstrating microsecond-level optimizations, market microstructure analysis, and institutional-grade execution techniques.</p>
<h3 id="architecture-patterns-1"><a class="header" href="#architecture-patterns-1">Architecture Patterns</a></h3>
<h4 id="ultra-fast-data-pipeline"><a class="header" href="#ultra-fast-data-pipeline">Ultra-Fast Data Pipeline</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MarketDataBuffer {
    ticks: VecDeque&lt;MarketTick&gt;,
    max_size: usize,
}

struct LatencyTracker {
    execution_latencies: VecDeque&lt;Duration&gt;,
    max_samples: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>Optimized data structures for minimal allocation and maximum throughput.</p>
<h4 id="market-microstructure-analysis"><a class="header" href="#market-microstructure-analysis">Market Microstructure Analysis</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MicrostructureAnalyzer {
    config: Option&lt;MicrostructureConfig&gt;,
}

struct MicrostructureConfig {
    tick_size: f64,
    min_spread_threshold: f64,
    volume_imbalance_threshold: f64,
    price_impact_window: Duration,
    order_flow_analysis: bool,
    liquidity_detection: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Advanced market analysis including:</p>
<ul>
<li>Order flow toxicity detection</li>
<li>Liquidity scoring</li>
<li>Volume imbalance analysis</li>
<li>Price impact measurement</li>
</ul>
<h4 id="hft-strategy-framework"><a class="header" href="#hft-strategy-framework">HFT Strategy Framework</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HftStrategy: Send + Sync {
    fn generate_signal(&amp;self, market_state: &amp;MarketState) -&gt; Option&lt;HftSignal&gt;;
    fn name(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre></pre>
<p>Specialized HFT strategies:</p>
<ul>
<li><strong>Market Making</strong>: Automated bid-ask spread capture</li>
<li><strong>Statistical Arbitrage</strong>: Mean reversion and correlation trading</li>
<li><strong>Momentum Scalping</strong>: Ultra-short-term trend exploitation</li>
</ul>
<h3 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h3>
<h4 id="1-network-optimization"><a class="header" href="#1-network-optimization">1. Network Optimization</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NetworkOptimization {
    use_fastest_endpoint: bool,
    enable_connection_pooling: bool,
    tcp_no_delay: bool,
    keep_alive: bool,
    connection_timeout: Duration,
    read_timeout: Duration,
    preferred_regions: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Network-level optimizations for minimal latency:</p>
<ul>
<li>TCP_NODELAY for immediate packet transmission</li>
<li>Connection pooling for reduced handshake overhead</li>
<li>Regional endpoint selection</li>
<li>Aggressive timeout settings</li>
</ul>
<h4 id="2-execution-engine"><a class="header" href="#2-execution-engine">2. Execution Engine</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ExecutionConfig {
    max_latency_tolerance: Duration,
    order_batching: bool,
    smart_routing: bool,
    post_only_default: bool,
    ioc_default: bool,
    mev_protection: bool,
    co_location_mode: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Ultra-fast execution with:</p>
<ul>
<li>Sub-5ms latency tolerance</li>
<li>Immediate-or-cancel (IOC) orders</li>
<li>Smart order routing</li>
<li>Co-location optimizations</li>
</ul>
<h4 id="3-real-time-risk-management"><a class="header" href="#3-real-time-risk-management">3. Real-Time Risk Management</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn calculate_real_time_risk() -&gt; PortfolioRisk {
    PortfolioRisk {
        exceeds_limits: false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Tick-level risk monitoring to prevent exposure accumulation.</p>
<h3 id="key-features-6"><a class="header" href="#key-features-6">Key Features</a></h3>
<h4 id="1-redundant-websocket-connections"><a class="header" href="#1-redundant-websocket-connections">1. Redundant WebSocket Connections</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut primary_ws = WebSocketClient::new(handler.clone()).unwrap();
let mut backup_ws = WebSocketClient::new(handler.clone()).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Multiple connections ensure zero downtime and data continuity.</p>
<h4 id="2-microsecond-level-latency-tracking"><a class="header" href="#2-microsecond-level-latency-tracking">2. Microsecond-Level Latency Tracking</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let execution_latency = execution_start.elapsed();
if execution_latency &gt; Duration::from_millis(10) {
    println!("⚠️  High execution latency: {:.2}ms", 
        execution_latency.as_secs_f64() * 1000.0);
}
<span class="boring">}</span></code></pre></pre>
<p>Continuous latency monitoring with alerting for performance degradation.</p>
<h4 id="3-market-making-strategy"><a class="header" href="#3-market-making-strategy">3. Market Making Strategy</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl HftStrategy for MarketMakingStrategy {
    fn generate_signal(&amp;self, _market_state: &amp;MarketState) -&gt; Option&lt;HftSignal&gt; {
        Some(HftSignal {
            action: HftAction::MakeMarket {
                bid_price: 125.49,
                ask_price: 125.51,
                bid_size: self.quote_size,
                ask_size: self.quote_size,
            },
            urgency: SignalUrgency::Normal,
            confidence: 0.8,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Automated market making with dynamic spread adjustment and inventory management.</p>
<h2 id="multi-chain-portfolio-management"><a class="header" href="#multi-chain-portfolio-management">Multi-Chain Portfolio Management</a></h2>
<p><strong>Location</strong>: <code>examples/advanced/multi_chain_portfolio.rs</code></p>
<h3 id="overview-21"><a class="header" href="#overview-21">Overview</a></h3>
<p>Comprehensive cross-blockchain portfolio management system supporting Solana, Hyperliquid, and other networks with automated rebalancing and arbitrage detection.</p>
<h3 id="architecture-patterns-2"><a class="header" href="#architecture-patterns-2">Architecture Patterns</a></h3>
<h4 id="multi-chain-configuration"><a class="header" href="#multi-chain-configuration">Multi-Chain Configuration</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MultiChainPortfolioConfig {
    track_solana: bool,
    track_hyperliquid: bool,
    track_ethereum: bool,
    track_arbitrum: bool,
    auto_sync: bool,
    sync_interval: Duration,
    include_staking: bool,
    include_liquidity: bool,
    base_currency: String,
}
<span class="boring">}</span></code></pre></pre>
<p>Unified configuration for multiple blockchain networks with flexible tracking options.</p>
<h4 id="cross-chain-transfer-management"><a class="header" href="#cross-chain-transfer-management">Cross-Chain Transfer Management</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CrossChainTransfer {
    from_chain: String,
    to_chain: String,
    token_symbol: String,
    amount: f64,
    recipient_address: String,
    bridge_provider: String,
    slippage_tolerance: f64,
    priority_fee: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Structured approach to cross-chain asset transfers with bridge integration and fee optimization.</p>
<h4 id="portfolio-rebalancing-engine"><a class="header" href="#portfolio-rebalancing-engine">Portfolio Rebalancing Engine</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RebalanceStrategy {
    target_allocations: HashMap&lt;String, f64&gt;,
    rebalance_threshold: f64,
    min_trade_size: f64,
    max_slippage: f64,
    include_gas_optimization: bool,
    dry_run: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Automated rebalancing with configurable thresholds and cost optimization.</p>
<h3 id="key-features-7"><a class="header" href="#key-features-7">Key Features</a></h3>
<h4 id="1-cross-chain-arbitrage-detection"><a class="header" href="#1-cross-chain-arbitrage-detection">1. Cross-Chain Arbitrage Detection</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("  Opportunity #1:");
println!("    Token: USDC");
println!("    Buy on: Solana at $0.999500");
println!("    Sell on: Hyperliquid at $1.001200");
println!("    Profit potential: $1.70 (0.17%)");
println!("    Min trade size: $1000.00");
println!("    Est. gas costs: $0.50");
println!("    Net profit: $1.20");
<span class="boring">}</span></code></pre></pre>
<p>Real-time detection of price discrepancies across chains with profitability analysis.</p>
<h4 id="2-yield-farming-analysis"><a class="header" href="#2-yield-farming-analysis">2. Yield Farming Analysis</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("  Protocol: Marinade Finance");
println!("    Chain: Solana");
println!("    Pool: mSOL Staking");
println!("    APY: 7.85%");
println!("    TVL: $125000000");
println!("    Required tokens: [\"SOL\"]");
println!("    Risks: [\"Slashing\", \"Protocol\"]");
<span class="boring">}</span></code></pre></pre>
<p>Comprehensive DeFi yield opportunity analysis across multiple chains.</p>
<h4 id="3-risk-assessment-framework"><a class="header" href="#3-risk-assessment-framework">3. Risk Assessment Framework</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Multi-chain risk assessment (simulated):");
println!("  Overall risk score: 6.5/10");
println!("  Diversification score: 7.2/10");
println!("Risk factors:");
println!("  🟡 Bridge Risk: Cross-chain bridges have historical vulnerability");
println!("  🟢 Protocol Risk: Smart contract risks on DeFi protocols");
<span class="boring">}</span></code></pre></pre>
<p>Multi-dimensional risk analysis including bridge risks, protocol risks, and concentration metrics.</p>
<h4 id="4-performance-analytics"><a class="header" href="#4-performance-analytics">4. Performance Analytics</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Multi-chain performance analytics (30 days, simulated):");
println!("  Total return: +8.5%");
println!("  Best performing chain: Solana (+12.3%)");
println!("  Worst performing chain: Hyperliquid (+4.2%)");
<span class="boring">}</span></code></pre></pre>
<p>Comprehensive performance tracking across all supported chains with detailed metrics.</p>
<h2 id="performance-optimizations-1"><a class="header" href="#performance-optimizations-1">Performance Optimizations</a></h2>
<h3 id="memory-management-2"><a class="header" href="#memory-management-2">Memory Management</a></h3>
<ul>
<li><strong>Zero-copy deserialization</strong> where possible</li>
<li><strong>Bounded collections</strong> to prevent memory leaks</li>
<li><strong>RAII patterns</strong> for automatic resource cleanup</li>
</ul>
<h3 id="concurrency-patterns"><a class="header" href="#concurrency-patterns">Concurrency Patterns</a></h3>
<ul>
<li><strong>Actor model</strong> for message passing between components</li>
<li><strong>Lock-free data structures</strong> for high-frequency operations</li>
<li><strong>Async/await</strong> for non-blocking I/O operations</li>
</ul>
<h3 id="network-optimizations"><a class="header" href="#network-optimizations">Network Optimizations</a></h3>
<ul>
<li><strong>Connection pooling</strong> to reduce handshake overhead</li>
<li><strong>Compression</strong> for large data transfers</li>
<li><strong>TCP optimization</strong> with NO_DELAY and keep-alive settings</li>
</ul>
<h3 id="data-processing"><a class="header" href="#data-processing">Data Processing</a></h3>
<ul>
<li><strong>Streaming processing</strong> for real-time market data</li>
<li><strong>Batch operations</strong> where latency permits</li>
<li><strong>Caching strategies</strong> for frequently accessed data</li>
</ul>
<h2 id="error-handling-and-resilience"><a class="header" href="#error-handling-and-resilience">Error Handling and Resilience</a></h2>
<h3 id="retry-mechanisms"><a class="header" href="#retry-mechanisms">Retry Mechanisms</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ExecutionSettings {
    retry_attempts: u32,
    timeout_seconds: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Configurable retry logic with exponential backoff for transient failures.</p>
<h3 id="circuit-breaker-pattern"><a class="header" href="#circuit-breaker-pattern">Circuit Breaker Pattern</a></h3>
<p>Automatic fallback mechanisms when services become unavailable or performance degrades.</p>
<h3 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h3>
<p>Systems continue operating with reduced functionality when components fail.</p>
<h2 id="testing-and-validation"><a class="header" href="#testing-and-validation">Testing and Validation</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<p>Each component includes comprehensive unit tests with mock data and edge case coverage.</p>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<p>End-to-end tests verify complete workflows across multiple systems.</p>
<h3 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h3>
<p>Latency and throughput benchmarks ensure optimization targets are met.</p>
<h2 id="production-considerations"><a class="header" href="#production-considerations">Production Considerations</a></h2>
<h3 id="monitoring-and-alerting"><a class="header" href="#monitoring-and-alerting">Monitoring and Alerting</a></h3>
<ul>
<li>Real-time performance metrics</li>
<li>Automated alerting for anomalies</li>
<li>Health check endpoints</li>
</ul>
<h3 id="security-2"><a class="header" href="#security-2">Security</a></h3>
<ul>
<li>Secure credential management</li>
<li>Rate limiting and abuse prevention</li>
<li>Audit logging for all transactions</li>
</ul>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<ul>
<li>Horizontal scaling capabilities</li>
<li>Load balancing across instances</li>
<li>Database optimization for high throughput</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>These advanced examples provide a foundation for building production trading systems. Consider these enhancements for real-world deployment:</p>
<ol>
<li><strong>Hardware Optimization</strong>: FPGA acceleration for ultra-low latency</li>
<li><strong>Machine Learning</strong>: Predictive models for market behavior</li>
<li><strong>Advanced Risk Models</strong>: VaR, stress testing, and scenario analysis</li>
<li><strong>Compliance</strong>: Regulatory reporting and audit trails</li>
<li><strong>High Availability</strong>: Disaster recovery and failover mechanisms</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-best-practices"><a class="header" href="#error-handling-best-practices">Error Handling Best Practices</a></h1>
<p>This guide covers comprehensive error handling strategies for axiomtrade-rs, including error types, Result handling patterns, retry logic, graceful degradation, and debugging approaches.</p>
<h2 id="error-type-hierarchy"><a class="header" href="#error-type-hierarchy">Error Type Hierarchy</a></h2>
<h3 id="core-error-types"><a class="header" href="#core-error-types">Core Error Types</a></h3>
<p>The axiomtrade-rs library uses a well-structured error hierarchy with the <code>AxiomError</code> enum as the central error type:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum AxiomError {
    #[error("Authentication error: {0}")]
    Auth(#[from] crate::auth::error::AuthError),
    
    #[error("Network request failed: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("API error: {message}")]
    Api { message: String },
    
    #[error("Rate limit exceeded")]
    RateLimit,
    
    #[error("Service unavailable")]
    ServiceUnavailable,
    
    #[error("Timeout error")]
    Timeout,
    
    #[error("Configuration error: {0}")]
    Config(String),
    
    #[error("WebSocket error: {0}")]
    WebSocket(String),
}

pub type Result&lt;T&gt; = std::result::Result&lt;T, AxiomError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-errors"><a class="header" href="#authentication-errors">Authentication Errors</a></h3>
<p>Authentication errors are handled through a dedicated <code>AuthError</code> enum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum AuthError {
    #[error("Network request failed: {0}")]
    NetworkError(#[from] reqwest::Error),
    
    #[error("Invalid credentials")]
    InvalidCredentials,
    
    #[error("OTP required but not provided")]
    OtpRequired,
    
    #[error("Invalid OTP code")]
    InvalidOtp,
    
    #[error("Token expired")]
    TokenExpired,
    
    #[error("Token not found")]
    TokenNotFound,
    
    #[error("Email fetcher error: {0}")]
    EmailError(String),
    
    #[error("API error: {message}")]
    ApiError { message: String },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="client-specific-errors"><a class="header" href="#client-specific-errors">Client-Specific Errors</a></h3>
<p>Enhanced client operations use <code>EnhancedClientError</code> for more specific error handling:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum EnhancedClientError {
    #[error("Authentication error: {0}")]
    AuthError(#[from] AuthError),
    
    #[error("Network error: {0}")]
    NetworkError(#[from] reqwest::Error),
    
    #[error("Rate limit exceeded")]
    RateLimitExceeded,
    
    #[error("Max retries exceeded")]
    MaxRetriesExceeded,
    
    #[error("Request failed: {0}")]
    RequestFailed(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="result-handling-patterns"><a class="header" href="#result-handling-patterns">Result Handling Patterns</a></h2>
<h3 id="basic-error-propagation"><a class="header" href="#basic-error-propagation">Basic Error Propagation</a></h3>
<p>Use the <code>?</code> operator for clean error propagation:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn get_portfolio_balance(&amp;self, wallet: &amp;str) -&gt; Result&lt;PortfolioData&gt; {
    let auth_token = self.auth_client.get_valid_token().await?;
    let response = self.make_request("GET", &amp;format!("/portfolio/{}", wallet), None).await?;
    let portfolio: PortfolioData = serde_json::from_value(response)?;
    Ok(portfolio)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-mapping-and-context"><a class="header" href="#error-mapping-and-context">Error Mapping and Context</a></h3>
<p>Add context to errors using <code>map_err</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(&amp;mut self, email: &amp;str, password: &amp;str) -&gt; Result&lt;AuthTokens&gt; {
    let response = self.client
        .post(&amp;format!("{}/auth/login", self.base_url))
        .json(&amp;login_request)
        .send()
        .await
        .map_err(|e| AxiomError::Network(e))?;
    
    let auth_data: AuthResponse = response
        .json()
        .await
        .map_err(|e| AxiomError::Serialization(serde_json::Error::from(e)))?;
    
    Ok(auth_data.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-multiple-error-types"><a class="header" href="#handling-multiple-error-types">Handling Multiple Error Types</a></h3>
<p>Pattern match on specific error types for different handling strategies:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn robust_api_call(&amp;self, endpoint: &amp;str) -&gt; Result&lt;Value&gt; {
    match self.make_request(endpoint).await {
        Ok(response) =&gt; Ok(response),
        Err(AxiomError::Auth(AuthError::TokenExpired)) =&gt; {
            self.refresh_token().await?;
            self.make_request(endpoint).await
        },
        Err(AxiomError::RateLimit) =&gt; {
            tokio::time::sleep(Duration::from_secs(60)).await;
            self.make_request(endpoint).await
        },
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="retry-logic-implementation"><a class="header" href="#retry-logic-implementation">Retry Logic Implementation</a></h2>
<h3 id="retryconfig-structure"><a class="header" href="#retryconfig-structure">RetryConfig Structure</a></h3>
<p>The library provides a comprehensive retry configuration system:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct RetryConfig {
    pub max_retries: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub exponential_base: f64,
    pub jitter: bool,
}

impl Default for RetryConfig {
    fn default() -&gt; Self {
        Self {
            max_retries: 3,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(30),
            exponential_base: 2.0,
            jitter: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exponential-backoff-with-jitter"><a class="header" href="#exponential-backoff-with-jitter">Exponential Backoff with Jitter</a></h3>
<p>The retry system implements exponential backoff with optional jitter to prevent thundering herd problems:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RetryConfig {
    fn calculate_delay(&amp;self, attempt: u32) -&gt; Duration {
        let base_delay = self.initial_delay.as_millis() as f64;
        let exponential_delay = base_delay * self.exponential_base.powi(attempt as i32);
        
        let mut delay_ms = exponential_delay.min(self.max_delay.as_millis() as f64);
        
        if self.jitter {
            use rand::Rng;
            let mut rng = rand::thread_rng();
            let jitter_factor = rng.gen_range(0.5..1.5);
            delay_ms *= jitter_factor;
        }
        
        Duration::from_millis(delay_ms as u64)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="retryable-error-detection"><a class="header" href="#retryable-error-detection">Retryable Error Detection</a></h3>
<p>Implement the <code>RetryableError</code> trait to determine which errors should trigger retries:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RetryableError {
    fn is_retryable(&amp;self) -&gt; bool;
}

impl RetryableError for reqwest::Error {
    fn is_retryable(&amp;self) -&gt; bool {
        if self.is_timeout() || self.is_connect() {
            return true;
        }
        
        if let Some(status) = self.status() {
            matches!(status.as_u16(), 429 | 500 | 502 | 503 | 504)
        } else {
            true
        }
    }
}

impl RetryableError for EnhancedClientError {
    fn is_retryable(&amp;self) -&gt; bool {
        match self {
            EnhancedClientError::NetworkError(e) =&gt; e.is_timeout() || e.is_connect(),
            EnhancedClientError::RateLimitExceeded =&gt; true,
            EnhancedClientError::RequestFailed(msg) =&gt; {
                msg.contains("timeout") || msg.contains("connection")
            }
            _ =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-retry-functions"><a class="header" href="#using-retry-functions">Using Retry Functions</a></h3>
<p>Use the retry utilities for resilient operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::utils::retry::{retry_with_config, RetryConfig};

pub async fn resilient_api_call(&amp;self) -&gt; Result&lt;Value&gt; {
    let retry_config = RetryConfig::default()
        .with_max_delay(Duration::from_secs(10))
        .with_jitter(true);

    retry_with_config(retry_config, || async {
        self.make_api_request("/some-endpoint").await
    }).await
}
<span class="boring">}</span></code></pre></pre>
<h2 id="graceful-degradation-strategies"><a class="header" href="#graceful-degradation-strategies">Graceful Degradation Strategies</a></h2>
<h3 id="service-availability-fallbacks"><a class="header" href="#service-availability-fallbacks">Service Availability Fallbacks</a></h3>
<p>Implement fallback mechanisms when primary services are unavailable:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn get_token_price_with_fallback(&amp;self, token: &amp;str) -&gt; Result&lt;f64&gt; {
    // Try primary price source
    match self.get_primary_price(token).await {
        Ok(price) =&gt; Ok(price),
        Err(AxiomError::ServiceUnavailable) =&gt; {
            // Fall back to secondary source
            self.get_fallback_price(token).await
        },
        Err(e) =&gt; Err(e),
    }
}

async fn get_fallback_price(&amp;self, token: &amp;str) -&gt; Result&lt;f64&gt; {
    // Implement fallback price fetching logic
    // Could use different API, cached data, or estimated values
    Ok(0.0) // Placeholder
}
<span class="boring">}</span></code></pre></pre>
<h3 id="partial-success-handling"><a class="header" href="#partial-success-handling">Partial Success Handling</a></h3>
<p>Handle scenarios where some operations succeed and others fail:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn bulk_portfolio_update(&amp;self, wallets: &amp;[String]) -&gt; PartialResult&lt;Vec&lt;PortfolioData&gt;&gt; {
    let mut successes = Vec::new();
    let mut failures = Vec::new();
    
    for wallet in wallets {
        match self.get_portfolio_balance(wallet).await {
            Ok(portfolio) =&gt; successes.push(portfolio),
            Err(e) =&gt; failures.push((wallet.clone(), e)),
        }
    }
    
    PartialResult {
        successes,
        failures,
        total_attempted: wallets.len(),
    }
}

pub struct PartialResult&lt;T&gt; {
    pub successes: Vec&lt;T&gt;,
    pub failures: Vec&lt;(String, AxiomError)&gt;,
    pub total_attempted: usize,
}

impl&lt;T&gt; PartialResult&lt;T&gt; {
    pub fn success_rate(&amp;self) -&gt; f64 {
        self.successes.len() as f64 / self.total_attempted as f64
    }
    
    pub fn has_any_success(&amp;self) -&gt; bool {
        !self.successes.is_empty()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="circuit-breaker-pattern-1"><a class="header" href="#circuit-breaker-pattern-1">Circuit Breaker Pattern</a></h3>
<p>Implement circuit breaker for failing services:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,    // Normal operation
    Open,      // Failing fast
    HalfOpen,  // Testing if service recovered
}

pub struct CircuitBreaker {
    state: Arc&lt;Mutex&lt;CircuitState&gt;&gt;,
    failure_count: Arc&lt;Mutex&lt;u32&gt;&gt;,
    last_failure_time: Arc&lt;Mutex&lt;Option&lt;Instant&gt;&gt;&gt;,
    failure_threshold: u32,
    recovery_timeout: Duration,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, recovery_timeout: Duration) -&gt; Self {
        Self {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(Mutex::new(0)),
            last_failure_time: Arc::new(Mutex::new(None)),
            failure_threshold,
            recovery_timeout,
        }
    }
    
    pub async fn call&lt;F, T&gt;(&amp;self, operation: F) -&gt; Result&lt;T&gt;
    where
        F: FnOnce() -&gt; std::pin::Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Result&lt;T&gt;&gt; + Send&gt;&gt;,
    {
        {
            let state = self.state.lock().unwrap();
            match *state {
                CircuitState::Open =&gt; {
                    if self.should_attempt_reset() {
                        drop(state);
                        *self.state.lock().unwrap() = CircuitState::HalfOpen;
                    } else {
                        return Err(AxiomError::ServiceUnavailable);
                    }
                }
                _ =&gt; {}
            }
        }
        
        match operation().await {
            Ok(result) =&gt; {
                self.on_success();
                Ok(result)
            }
            Err(e) =&gt; {
                self.on_failure();
                Err(e)
            }
        }
    }
    
    fn should_attempt_reset(&amp;self) -&gt; bool {
        if let Some(last_failure) = *self.last_failure_time.lock().unwrap() {
            Instant::now().duration_since(last_failure) &gt;= self.recovery_timeout
        } else {
            false
        }
    }
    
    fn on_success(&amp;self) {
        *self.state.lock().unwrap() = CircuitState::Closed;
        *self.failure_count.lock().unwrap() = 0;
    }
    
    fn on_failure(&amp;self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count += 1;
        *self.last_failure_time.lock().unwrap() = Some(Instant::now());
        
        if *failure_count &gt;= self.failure_threshold {
            *self.state.lock().unwrap() = CircuitState::Open;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="logging-and-debugging"><a class="header" href="#logging-and-debugging">Logging and Debugging</a></h2>
<h3 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h3>
<p>Use structured logging for better error tracking:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{error, warn, info, debug, span, Level};

pub async fn authenticated_request(&amp;self, endpoint: &amp;str) -&gt; Result&lt;Value&gt; {
    let span = span!(Level::INFO, "authenticated_request", endpoint = endpoint);
    let _enter = span.enter();
    
    debug!("Starting authenticated request");
    
    match self.make_request(endpoint).await {
        Ok(response) =&gt; {
            info!("Request successful");
            Ok(response)
        }
        Err(e) =&gt; {
            error!(error = %e, "Request failed");
            
            // Log additional context based on error type
            match &amp;e {
                AxiomError::Auth(auth_err) =&gt; {
                    warn!(auth_error = %auth_err, "Authentication error occurred");
                }
                AxiomError::RateLimit =&gt; {
                    warn!("Rate limit exceeded, consider implementing backoff");
                }
                AxiomError::Network(net_err) =&gt; {
                    warn!(network_error = %net_err, "Network connectivity issue");
                }
                _ =&gt; {}
            }
            
            Err(e)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-context-and-tracing"><a class="header" href="#error-context-and-tracing">Error Context and Tracing</a></h3>
<p>Add context to errors for better debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::{Context, Result as AnyhowResult};

pub async fn complex_operation(&amp;self, user_id: u64) -&gt; AnyhowResult&lt;ProcessedData&gt; {
    let user_data = self.fetch_user_data(user_id).await
        .with_context(|| format!("Failed to fetch user data for user {}", user_id))?;
    
    let portfolio = self.get_portfolio(&amp;user_data.wallet_address).await
        .with_context(|| format!("Failed to get portfolio for wallet {}", user_data.wallet_address))?;
    
    let processed = self.process_portfolio_data(&amp;portfolio).await
        .context("Failed to process portfolio data")?;
    
    Ok(processed)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debug-logging-for-development"><a class="header" href="#debug-logging-for-development">Debug Logging for Development</a></h3>
<p>Implement debug logging that can be enabled in development:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(debug_assertions)]
macro_rules! debug_log {
    ($($arg:tt)*) =&gt; {
        eprintln!("[DEBUG] {}: {}", chrono::Utc::now().format("%Y-%m-%d %H:%M:%S%.3f"), format!($($arg)*));
    };
}

#[cfg(not(debug_assertions))]
macro_rules! debug_log {
    ($($arg:tt)*) =&gt; {};
}

pub async fn debug_enabled_request(&amp;self, endpoint: &amp;str) -&gt; Result&lt;Value&gt; {
    debug_log!("Making request to endpoint: {}", endpoint);
    
    let start_time = std::time::Instant::now();
    let result = self.make_request(endpoint).await;
    let duration = start_time.elapsed();
    
    match &amp;result {
        Ok(_) =&gt; debug_log!("Request to {} completed successfully in {:?}", endpoint, duration),
        Err(e) =&gt; debug_log!("Request to {} failed after {:?}: {}", endpoint, duration, e),
    }
    
    result
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-best-practices-1"><a class="header" href="#error-handling-best-practices-1">Error Handling Best Practices</a></h2>
<h3 id="1-fail-fast-principle"><a class="header" href="#1-fail-fast-principle">1. Fail Fast Principle</a></h3>
<p>Validate inputs early and return errors immediately:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn create_trade_order(&amp;self, amount: f64, token_address: &amp;str) -&gt; Result&lt;TradeOrder&gt; {
    // Validate inputs early
    if amount &lt;= 0.0 {
        return Err(AxiomError::Config("Amount must be positive".to_string()));
    }
    
    if token_address.len() != 44 {
        return Err(AxiomError::Config("Invalid token address format".to_string()));
    }
    
    // Proceed with operation
    self.execute_trade(amount, token_address).await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-specific-error-types"><a class="header" href="#2-specific-error-types">2. Specific Error Types</a></h3>
<p>Use specific error types rather than generic strings:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Specific error types
#[derive(Error, Debug)]
pub enum TradeError {
    #[error("Insufficient balance: required {required}, available {available}")]
    InsufficientBalance { required: f64, available: f64 },
    
    #[error("Invalid token address: {address}")]
    InvalidTokenAddress { address: String },
    
    #[error("Slippage tolerance exceeded: expected {expected}%, actual {actual}%")]
    SlippageExceeded { expected: f64, actual: f64 },
}

// Bad: Generic string errors
fn bad_example() -&gt; Result&lt;()&gt; {
    Err(AxiomError::Config("Something went wrong".to_string()))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-error-recovery-strategies"><a class="header" href="#3-error-recovery-strategies">3. Error Recovery Strategies</a></h3>
<p>Implement appropriate recovery strategies for different error types:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn resilient_portfolio_fetch(&amp;self, wallet: &amp;str, max_retries: u32) -&gt; Result&lt;Portfolio&gt; {
    for attempt in 0..max_retries {
        match self.get_portfolio(wallet).await {
            Ok(portfolio) =&gt; return Ok(portfolio),
            Err(AxiomError::RateLimit) =&gt; {
                // Wait longer for rate limits
                let delay = Duration::from_secs(60 * (attempt + 1) as u64);
                tokio::time::sleep(delay).await;
            }
            Err(AxiomError::Network(_)) =&gt; {
                // Shorter wait for network issues
                let delay = Duration::from_millis(1000 * (attempt + 1) as u64);
                tokio::time::sleep(delay).await;
            }
            Err(AxiomError::Auth(_)) =&gt; {
                // Try to refresh authentication
                self.refresh_auth().await?;
            }
            Err(e) =&gt; {
                // Non-recoverable errors
                return Err(e);
            }
        }
    }
    
    Err(AxiomError::Config("Max retries exceeded".to_string()))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-resource-cleanup"><a class="header" href="#4-resource-cleanup">4. Resource Cleanup</a></h3>
<p>Ensure proper resource cleanup even when errors occur:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn websocket_with_cleanup(&amp;self) -&gt; Result&lt;Vec&lt;Message&gt;&gt; {
    let ws_connection = self.connect_websocket().await?;
    let mut messages = Vec::new();
    
    let result = async {
        loop {
            match ws_connection.next().await {
                Some(Ok(message)) =&gt; messages.push(message),
                Some(Err(e)) =&gt; return Err(AxiomError::WebSocket(e.to_string())),
                None =&gt; break,
            }
        }
        Ok(messages)
    }.await;
    
    // Ensure connection is properly closed regardless of success/failure
    if let Err(e) = ws_connection.close().await {
        warn!("Failed to close WebSocket connection: {}", e);
    }
    
    result
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-testing-error-scenarios"><a class="header" href="#5-testing-error-scenarios">5. Testing Error Scenarios</a></h3>
<p>Write comprehensive tests for error conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_retry_on_rate_limit() {
        let mut client = MockClient::new();
        
        // First call returns rate limit error
        client.expect_get_portfolio()
            .times(1)
            .returning(|_| Err(AxiomError::RateLimit));
        
        // Second call succeeds
        client.expect_get_portfolio()
            .times(1)
            .returning(|_| Ok(Portfolio::default()));
        
        let result = client.resilient_portfolio_fetch("test_wallet", 2).await;
        assert!(result.is_ok());
    }
    
    #[tokio::test]
    async fn test_non_retryable_error() {
        let mut client = MockClient::new();
        
        client.expect_get_portfolio()
            .times(1)
            .returning(|_| Err(AxiomError::Config("Invalid wallet".to_string())));
        
        let result = client.resilient_portfolio_fetch("invalid_wallet", 3).await;
        assert!(result.is_err());
        
        // Should not retry non-retryable errors
        assert_eq!(client.call_count(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-and-alerting-1"><a class="header" href="#monitoring-and-alerting-1">Monitoring and Alerting</a></h2>
<h3 id="error-metrics-collection"><a class="header" href="#error-metrics-collection">Error Metrics Collection</a></h3>
<p>Implement error metrics for monitoring:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, Ordering};
use std::collections::HashMap;
use std::sync::Arc;

pub struct ErrorMetrics {
    error_counts: Arc&lt;HashMap&lt;String, AtomicU64&gt;&gt;,
    total_requests: AtomicU64,
    successful_requests: AtomicU64,
}

impl ErrorMetrics {
    pub fn new() -&gt; Self {
        Self {
            error_counts: Arc::new(HashMap::new()),
            total_requests: AtomicU64::new(0),
            successful_requests: AtomicU64::new(0),
        }
    }
    
    pub fn record_request_success(&amp;self) {
        self.total_requests.fetch_add(1, Ordering::Relaxed);
        self.successful_requests.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_request_error(&amp;self, error_type: &amp;str) {
        self.total_requests.fetch_add(1, Ordering::Relaxed);
        // Note: This is simplified - in practice, you'd need thread-safe HashMap updates
    }
    
    pub fn get_error_rate(&amp;self) -&gt; f64 {
        let total = self.total_requests.load(Ordering::Relaxed);
        let successful = self.successful_requests.load(Ordering::Relaxed);
        
        if total == 0 {
            0.0
        } else {
            1.0 - (successful as f64 / total as f64)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="health-check-endpoints"><a class="header" href="#health-check-endpoints">Health Check Endpoints</a></h3>
<p>Implement health checks that consider error rates:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(serde::Serialize)]
pub struct HealthStatus {
    pub status: String,
    pub error_rate: f64,
    pub recent_errors: Vec&lt;String&gt;,
    pub uptime_seconds: u64,
}

impl AxiomClient {
    pub async fn health_check(&amp;self) -&gt; HealthStatus {
        let error_rate = self.metrics.get_error_rate();
        
        let status = if error_rate &gt; 0.5 {
            "unhealthy"
        } else if error_rate &gt; 0.1 {
            "degraded"
        } else {
            "healthy"
        }.to_string();
        
        HealthStatus {
            status,
            error_rate,
            recent_errors: self.get_recent_errors(),
            uptime_seconds: self.get_uptime().as_secs(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Effective error handling in axiomtrade-rs requires:</p>
<ol>
<li><strong>Structured Error Types</strong>: Use the provided error hierarchy with specific, actionable error types</li>
<li><strong>Robust Retry Logic</strong>: Implement exponential backoff with jitter for retryable errors</li>
<li><strong>Graceful Degradation</strong>: Provide fallbacks and partial success handling</li>
<li><strong>Comprehensive Logging</strong>: Use structured logging with appropriate context</li>
<li><strong>Proactive Monitoring</strong>: Collect metrics and implement health checks</li>
<li><strong>Thorough Testing</strong>: Test error scenarios and recovery strategies</li>
</ol>
<p>By following these patterns, you can build resilient applications that handle failures gracefully and provide excellent user experience even when things go wrong.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rate-limiting-2"><a class="header" href="#rate-limiting-2">Rate Limiting</a></h1>
<h2 id="overview-22"><a class="header" href="#overview-22">Overview</a></h2>
<p>Rate limiting is a critical component for managing API requests and ensuring stable operation within Axiom Trade's API limits. The <code>axiomtrade-rs</code> library provides three distinct rate limiting implementations to handle different scenarios and requirements.</p>
<h2 id="rate-limiting-implementations"><a class="header" href="#rate-limiting-implementations">Rate Limiting Implementations</a></h2>
<h3 id="1-window-based-rate-limiter"><a class="header" href="#1-window-based-rate-limiter">1. Window-Based Rate Limiter</a></h3>
<p>The <code>RateLimiter</code> uses a sliding window approach to track requests over a specified time period.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::RateLimiter;
use std::time::Duration;

// Allow 100 requests per minute
let limiter = RateLimiter::new(100, Duration::from_secs(60));

// Wait if necessary before making a request
limiter.wait_if_needed().await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Sliding window implementation using <code>VecDeque</code></li>
<li>Thread-safe with <code>Arc&lt;RwLock&gt;</code></li>
<li>Automatic cleanup of expired requests</li>
<li>Non-blocking permission acquisition</li>
</ul>
<p><strong>Configuration Parameters:</strong></p>
<ul>
<li><code>max_requests</code>: Maximum number of requests allowed in the window</li>
<li><code>window</code>: Time duration for the rate limit window</li>
</ul>
<h3 id="2-token-bucket-rate-limiter"><a class="header" href="#2-token-bucket-rate-limiter">2. Token Bucket Rate Limiter</a></h3>
<p>The <code>BucketRateLimiter</code> implements a token bucket algorithm for more flexible rate limiting with burst capabilities.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::BucketRateLimiter;

// Allow 10 tokens with refill rate of 1 token per second
let bucket = BucketRateLimiter::new(10.0, 1.0);

// Consume 2 tokens
bucket.consume(2.0).await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Token bucket algorithm with configurable refill rate</li>
<li>Supports burst requests up to bucket capacity</li>
<li>Fractional token consumption</li>
<li>Automatic token refill based on elapsed time</li>
</ul>
<p><strong>Configuration Parameters:</strong></p>
<ul>
<li><code>max_tokens</code>: Maximum bucket capacity</li>
<li><code>refill_rate</code>: Tokens added per second</li>
</ul>
<h3 id="3-endpoint-specific-rate-limiter"><a class="header" href="#3-endpoint-specific-rate-limiter">3. Endpoint-Specific Rate Limiter</a></h3>
<p>The <code>EndpointRateLimiter</code> provides per-endpoint rate limiting with fallback to default limits.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::EndpointRateLimiter;
use std::time::Duration;

let endpoint_limiter = EndpointRateLimiter::new();

// Add specific limit for trading endpoint
endpoint_limiter.add_endpoint_limit(
    "/api/v1/trade".to_string(),
    50,
    Duration::from_secs(60)
).await;

// Wait for endpoint-specific limit
endpoint_limiter.wait_for_endpoint("/api/v1/trade").await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Per-endpoint rate limiting configuration</li>
<li>Default rate limiter fallback (100 requests/minute)</li>
<li>Dynamic endpoint limit addition</li>
<li>Automatic endpoint-specific limit enforcement</li>
</ul>
<h2 id="configurable-limits"><a class="header" href="#configurable-limits">Configurable Limits</a></h2>
<h3 id="recommended-rate-limits-by-endpoint-category"><a class="header" href="#recommended-rate-limits-by-endpoint-category">Recommended Rate Limits by Endpoint Category</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Endpoint Category</th><th>Recommended Limit</th><th>Window</th><th>Rationale</th></tr></thead><tbody>
<tr><td>Authentication</td><td>10 requests/minute</td><td>60s</td><td>Prevent brute force attacks</td></tr>
<tr><td>Trading</td><td>50 requests/minute</td><td>60s</td><td>Balance speed with stability</td></tr>
<tr><td>Portfolio</td><td>100 requests/minute</td><td>60s</td><td>Allow frequent balance checks</td></tr>
<tr><td>Market Data</td><td>200 requests/minute</td><td>60s</td><td>High-frequency data needs</td></tr>
<tr><td>WebSocket</td><td>No limit</td><td>N/A</td><td>Real-time streaming</td></tr>
</tbody></table>
</div>
<h3 id="environment-based-configuration"><a class="header" href="#environment-based-configuration">Environment-Based Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Production limits (conservative)
let auth_limiter = RateLimiter::new(10, Duration::from_secs(60));
let trading_limiter = RateLimiter::new(50, Duration::from_secs(60));

// Development limits (more permissive)
let dev_limiter = RateLimiter::new(1000, Duration::from_secs(60));
<span class="boring">}</span></code></pre></pre>
<h2 id="backoff-strategies"><a class="header" href="#backoff-strategies">Backoff Strategies</a></h2>
<h3 id="linear-backoff"><a class="header" href="#linear-backoff">Linear Backoff</a></h3>
<p>The basic rate limiters implement linear backoff by calculating exact wait times.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wait_time = limiter.acquire().await;
if wait_time &gt; Duration::ZERO {
    tokio::time::sleep(wait_time).await;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exponential-backoff-recommended-for-retries"><a class="header" href="#exponential-backoff-recommended-for-retries">Exponential Backoff (Recommended for Retries)</a></h3>
<p>For API errors, implement exponential backoff in conjunction with rate limiting:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::min;

async fn make_request_with_backoff(limiter: &amp;RateLimiter) -&gt; Result&lt;Response, Error&gt; {
    let mut attempts = 0;
    let max_attempts = 5;
    
    loop {
        limiter.wait_if_needed().await;
        
        match api_request().await {
            Ok(response) =&gt; return Ok(response),
            Err(error) if attempts &lt; max_attempts =&gt; {
                let delay = Duration::from_millis(100 * 2_u64.pow(attempts));
                let jitter = Duration::from_millis(rand::random::&lt;u64&gt;() % 100);
                tokio::time::sleep(delay + jitter).await;
                attempts += 1;
            }
            Err(error) =&gt; return Err(error),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="circuit-breakers"><a class="header" href="#circuit-breakers">Circuit Breakers</a></h2>
<p>While not implemented in the current rate limiters, circuit breakers can be combined with rate limiting for enhanced reliability:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU32, Ordering};

struct CircuitBreaker {
    failure_count: AtomicU32,
    failure_threshold: u32,
    recovery_timeout: Duration,
    last_failure: std::sync::Mutex&lt;Option&lt;Instant&gt;&gt;,
}

impl CircuitBreaker {
    fn is_open(&amp;self) -&gt; bool {
        let count = self.failure_count.load(Ordering::Relaxed);
        if count &gt;= self.failure_threshold {
            if let Ok(last_failure) = self.last_failure.lock() {
                if let Some(time) = *last_failure {
                    return time.elapsed() &lt; self.recovery_timeout;
                }
            }
        }
        false
    }
    
    fn record_success(&amp;self) {
        self.failure_count.store(0, Ordering::Relaxed);
    }
    
    fn record_failure(&amp;self) {
        self.failure_count.fetch_add(1, Ordering::Relaxed);
        if let Ok(mut last_failure) = self.last_failure.lock() {
            *last_failure = Some(Instant::now());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<h3 id="1-choose-the-right-rate-limiter"><a class="header" href="#1-choose-the-right-rate-limiter">1. Choose the Right Rate Limiter</a></h3>
<ul>
<li><strong>Window-based (<code>RateLimiter</code>)</strong>: Use for consistent request rates</li>
<li><strong>Token bucket (<code>BucketRateLimiter</code>)</strong>: Use when burst requests are acceptable</li>
<li><strong>Endpoint-specific (<code>EndpointRateLimiter</code>)</strong>: Use for APIs with different limits per endpoint</li>
</ul>
<h3 id="2-monitor-rate-limit-usage"><a class="header" href="#2-monitor-rate-limit-usage">2. Monitor Rate Limit Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let current_requests = limiter.get_request_count().await;
let utilization = (current_requests as f64 / max_requests as f64) * 100.0;

if utilization &gt; 80.0 {
    log::warn!("Rate limit utilization high: {:.1}%", utilization);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-implement-graceful-degradation"><a class="header" href="#3-implement-graceful-degradation">3. Implement Graceful Degradation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn make_request_with_fallback(limiter: &amp;RateLimiter) -&gt; Result&lt;Response, Error&gt; {
    let wait_time = limiter.acquire().await;
    
    if wait_time &gt; Duration::from_secs(5) {
        // If wait time is too long, use cached data or simplified response
        return get_cached_response().await;
    }
    
    if wait_time &gt; Duration::ZERO {
        tokio::time::sleep(wait_time).await;
    }
    
    api_request().await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-use-jitter-for-distributed-systems"><a class="header" href="#4-use-jitter-for-distributed-systems">4. Use Jitter for Distributed Systems</a></h3>
<p>When multiple clients are involved, add jitter to prevent thundering herd:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::Rng;

async fn wait_with_jitter(base_duration: Duration) {
    let jitter_ms = rand::thread_rng().gen_range(0..=100);
    let jitter = Duration::from_millis(jitter_ms);
    tokio::time::sleep(base_duration + jitter).await;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-configure-based-on-environment"><a class="header" href="#5-configure-based-on-environment">5. Configure Based on Environment</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_rate_limiter_for_env() -&gt; RateLimiter {
    match std::env::var("ENVIRONMENT").as_deref() {
        Ok("production") =&gt; RateLimiter::new(50, Duration::from_secs(60)),
        Ok("staging") =&gt; RateLimiter::new(100, Duration::from_secs(60)),
        _ =&gt; RateLimiter::new(200, Duration::from_secs(60)), // development
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-reset-rate-limiters-when-appropriate"><a class="header" href="#6-reset-rate-limiters-when-appropriate">6. Reset Rate Limiters When Appropriate</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reset rate limiter after authentication renewal
if token_renewed {
    limiter.reset().await;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="7-log-rate-limiting-events"><a class="header" href="#7-log-rate-limiting-events">7. Log Rate Limiting Events</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wait_time = limiter.acquire().await;
if wait_time &gt; Duration::ZERO {
    log::info!("Rate limited: waiting {:?}", wait_time);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-axiom-client"><a class="header" href="#integration-with-axiom-client">Integration with Axiom Client</a></h2>
<p>The Axiom client integrates rate limiting at multiple levels:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::client::EnhancedClient;

let client = EnhancedClient::builder()
    .with_rate_limiting(true)
    .with_trading_rate_limit(50, Duration::from_secs(60))
    .with_portfolio_rate_limit(100, Duration::from_secs(60))
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Window-based rate limiter: O(n) where n is max_requests</li>
<li>Token bucket: O(1) constant memory</li>
<li>Endpoint-specific: O(m) where m is number of endpoints</li>
</ul>
<h3 id="cpu-overhead"><a class="header" href="#cpu-overhead">CPU Overhead</a></h3>
<ul>
<li>Window cleanup: O(k) where k is expired requests</li>
<li>Token calculation: O(1) constant time</li>
<li>Lock contention: Minimized with <code>RwLock</code></li>
</ul>
<h3 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h3>
<ol>
<li>Use token bucket for high-frequency operations</li>
<li>Clean up endpoint limiters periodically in long-running applications</li>
<li>Monitor lock contention in highly concurrent scenarios</li>
<li>Consider using <code>Arc::clone()</code> instead of sharing references</li>
</ol>
<h2 id="testing-rate-limiters"><a class="header" href="#testing-rate-limiters">Testing Rate Limiters</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_rate_limiter_behavior() {
    let limiter = RateLimiter::new(2, Duration::from_secs(1));
    
    // First two requests should be immediate
    assert_eq!(limiter.acquire().await, Duration::ZERO);
    assert_eq!(limiter.acquire().await, Duration::ZERO);
    
    // Third request should require waiting
    let wait_time = limiter.acquire().await;
    assert!(wait_time &gt; Duration::ZERO);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="common-issues-4"><a class="header" href="#common-issues-4">Common Issues</a></h3>
<ol>
<li><strong>Requests still blocked after wait</strong>: Check system clock synchronization</li>
<li><strong>High memory usage</strong>: Verify window cleanup is working properly</li>
<li><strong>Inconsistent behavior</strong>: Ensure thread-safe access patterns</li>
<li><strong>Performance degradation</strong>: Monitor lock contention and consider alternatives</li>
</ol>
<h3 id="debug-information-1"><a class="header" href="#debug-information-1">Debug Information</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check current state
let request_count = limiter.get_request_count().await;
println!("Current requests in window: {}", request_count);

// Reset if needed
if request_count &gt; expected_max {
    limiter.reset().await;
}
<span class="boring">}</span></code></pre></pre>
<p>Rate limiting is essential for building robust, production-ready trading applications. By implementing appropriate rate limiting strategies, you can ensure reliable operation within API constraints while maintaining optimal performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-best-practices-1"><a class="header" href="#security-best-practices-1">Security Best Practices</a></h1>
<p>This document outlines the comprehensive security practices implemented in axiomtrade-rs, based on analysis of the codebase's security patterns and mechanisms.</p>
<h2 id="overview-23"><a class="header" href="#overview-23">Overview</a></h2>
<p>The axiomtrade-rs library implements multiple layers of security to protect user credentials, tokens, and trading operations. Security measures span credential management, cryptographic operations, secure communications, and MEV protection.</p>
<h2 id="1-credential-management"><a class="header" href="#1-credential-management">1. Credential Management</a></h2>
<h3 id="password-security"><a class="header" href="#password-security">Password Security</a></h3>
<p>The library uses industry-standard PBKDF2 password hashing with SHA256:</p>
<ul>
<li><strong>Hash Function</strong>: PBKDF2-HMAC-SHA256</li>
<li><strong>Iterations</strong>: 600,000 (exceeds OWASP recommendations)</li>
<li><strong>Salt</strong>: 32-byte fixed salt for deterministic hashing</li>
<li><strong>Output</strong>: Base64-encoded 32-byte hash</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example from src/utils/password.rs
const ITERATIONS: u32 = 600000;
pub fn hashpassword(password: &amp;str) -&gt; String {
    let mut derived_key = [0u8; 32];
    pbkdf2_hmac::&lt;Sha256&gt;(password.as_bytes(), &amp;SALT, ITERATIONS, &amp;mut derived_key);
    general_purpose::STANDARD.encode(&amp;derived_key)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Benefits:</strong></p>
<ul>
<li>Resistance to brute-force attacks through high iteration count</li>
<li>Deterministic hashing enables consistent authentication</li>
<li>SHA256 provides cryptographic strength</li>
<li>No plain-text password storage</li>
</ul>
<h3 id="environment-variable-safety"><a class="header" href="#environment-variable-safety">Environment Variable Safety</a></h3>
<p>Custom environment loader handles special characters securely:</p>
<ul>
<li><strong>Parsing</strong>: Safe parsing of <code>.env</code> files with quote handling</li>
<li><strong>Special Characters</strong>: Proper handling of passwords containing <code>$</code>, <code>!</code>, etc.</li>
<li><strong>Validation</strong>: Required variable checking with clear error messages</li>
<li><strong>Isolation</strong>: Environment variables don't leak into process space</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safe environment variable loading
let loader = EnvLoader::from_file(Path::new(".env"))?;
let password = loader.get_required("AXIOM_PASSWORD")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Best Practices:</strong></p>
<ul>
<li>Store sensitive credentials in <code>.env</code> files, not in code</li>
<li>Use quotes for values containing special characters</li>
<li>Never commit <code>.env</code> files to version control</li>
<li>Validate required environment variables at startup</li>
</ul>
<h2 id="2-token-security"><a class="header" href="#2-token-security">2. Token Security</a></h2>
<h3 id="jwt-token-management"><a class="header" href="#jwt-token-management">JWT Token Management</a></h3>
<p>Comprehensive token lifecycle management with secure storage:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthTokens {
    pub access_token: String,
    pub refresh_token: String,
    pub expires_at: Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Features:</strong></p>
<ul>
<li><strong>Expiration Tracking</strong>: Automatic token expiry detection with buffer zones</li>
<li><strong>Refresh Logic</strong>: Proactive token refresh 15 minutes before expiry</li>
<li><strong>Secure Storage</strong>: Optional persistent storage with file-based caching</li>
<li><strong>Memory Safety</strong>: Thread-safe in-memory token management</li>
</ul>
<h3 id="session-security-1"><a class="header" href="#session-security-1">Session Security</a></h3>
<p>Enhanced session management with multiple authentication layers:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthSession {
    pub tokens: AuthTokens,           // JWT tokens
    pub cookies: AuthCookies,         // HTTP session cookies
    pub turnkey_session: Option&lt;TurnkeySession&gt;, // Wallet management
    pub user_info: Option&lt;UserInfo&gt;,  // User metadata
    pub session_metadata: SessionMetadata, // Tracking data
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Measures:</strong></p>
<ul>
<li><strong>Multi-Factor Authentication</strong>: Combines JWTs and HTTP cookies</li>
<li><strong>Session Tracking</strong>: Metadata for debugging and security monitoring</li>
<li><strong>Automatic Cleanup</strong>: Session invalidation on logout</li>
<li><strong>Secure Headers</strong>: Proper cookie formatting for HTTP security</li>
</ul>
<h3 id="cookie-security-1"><a class="header" href="#cookie-security-1">Cookie Security</a></h3>
<p>HTTP cookies managed with security-first approach:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthCookies {
    pub auth_access_token: Option&lt;String&gt;,    // HttpOnly token
    pub auth_refresh_token: Option&lt;String&gt;,   // HttpOnly refresh
    pub g_state: Option&lt;String&gt;,              // Google state
    pub additional_cookies: HashMap&lt;String, String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Implementation Details:</strong></p>
<ul>
<li><strong>HttpOnly Flags</strong>: Prevents JavaScript access to sensitive tokens</li>
<li><strong>Secure Transmission</strong>: Cookies sent only over HTTPS</li>
<li><strong>State Management</strong>: Google OAuth state tracking</li>
<li><strong>Flexible Storage</strong>: Support for additional session cookies</li>
</ul>
<h2 id="3-cryptographic-security"><a class="header" href="#3-cryptographic-security">3. Cryptographic Security</a></h2>
<h3 id="p256-key-management"><a class="header" href="#p256-key-management">P256 Key Management</a></h3>
<p>Advanced elliptic curve cryptography for wallet operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct P256KeyPair {
    pub private_key: String,    // Hex-encoded private key
    pub public_key: String,     // Compressed public key
    pub client_secret: String,  // Base64-encoded salt
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Cryptographic Features:</strong></p>
<ul>
<li><strong>NIST P-256 Curve</strong>: Industry-standard elliptic curve</li>
<li><strong>Password-Derived Keys</strong>: PBKDF2-based key generation</li>
<li><strong>Deterministic Generation</strong>: Reproducible keys from password + salt</li>
<li><strong>WebAuthn Support</strong>: Compatible signature formats</li>
</ul>
<h3 id="key-generation-security"><a class="header" href="#key-generation-security">Key Generation Security</a></h3>
<p>Multi-layer key derivation process:</p>
<ol>
<li><strong>Password Input</strong>: User-provided password</li>
<li><strong>Salt Generation</strong>: Random 32-byte salt (or provided salt)</li>
<li><strong>PBKDF2 Derivation</strong>: 600,000 iterations with SHA256</li>
<li><strong>Curve Validation</strong>: Ensure key falls within valid P-256 range</li>
<li><strong>Key Pair Creation</strong>: Generate public key from private key</li>
</ol>
<p><strong>Security Validations:</strong></p>
<ul>
<li>Curve order validation prevents invalid keys</li>
<li>Zero-key rejection ensures cryptographic strength</li>
<li>Retry mechanism for edge cases</li>
<li>Deterministic regeneration from client secret</li>
</ul>
<h3 id="digital-signatures"><a class="header" href="#digital-signatures">Digital Signatures</a></h3>
<p>Dual signature formats for different use cases:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DER format for general use
pub fn sign_message(message: &amp;[u8], private_key_hex: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt;

// WebAuthn format for browser compatibility
pub fn sign_message_webauthn(message: &amp;[u8], private_key_hex: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Properties:</strong></p>
<ul>
<li><strong>ECDSA Signatures</strong>: Cryptographically secure signing</li>
<li><strong>Format Flexibility</strong>: DER and raw signature support</li>
<li><strong>Message Integrity</strong>: Tamper-evident message signing</li>
<li><strong>Non-Repudiation</strong>: Proof of message origin</li>
</ul>
<h2 id="4-environment-variable-safety"><a class="header" href="#4-environment-variable-safety">4. Environment Variable Safety</a></h2>
<h3 id="secure-loading-patterns"><a class="header" href="#secure-loading-patterns">Secure Loading Patterns</a></h3>
<p>Custom environment loader with enhanced security:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EnvLoader {
    pub fn from_file(path: &amp;Path) -&gt; Result&lt;Self, std::io::Error&gt;
    pub fn get_required(&amp;self, key: &amp;str) -&gt; Result&lt;String, String&gt;
    pub fn apply_to_env(&amp;self)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Safety Features:</strong></p>
<ul>
<li><strong>Quote Handling</strong>: Proper parsing of quoted values</li>
<li><strong>Special Character Support</strong>: Safe handling of <code>$</code>, <code>!</code>, <code>@</code> in passwords</li>
<li><strong>Comment Filtering</strong>: Ignores comment lines and empty lines</li>
<li><strong>Error Handling</strong>: Clear error messages for missing variables</li>
</ul>
<h3 id="environment-security-best-practices"><a class="header" href="#environment-security-best-practices">Environment Security Best Practices</a></h3>
<p><strong>File Structure:</strong></p>
<pre><code class="language-bash"># Production .env file
AXIOM_EMAIL=user@example.com
AXIOM_PASSWORD="MyP@ssw0rd$2024!"
AXIOM_ACCESS_TOKEN=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
AXIOM_REFRESH_TOKEN=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...

# OTP automation (optional)
INBOX_LV_EMAIL=otp@inbox.lv
INBOX_LV_PASSWORD="imap_password_from_inbox_lv"
</code></pre>
<p><strong>Security Checklist:</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
Never commit <code>.env</code> files to version control</li>
<li><input disabled="" type="checkbox"/>
Use strong, unique passwords</li>
<li><input disabled="" type="checkbox"/>
Rotate tokens regularly</li>
<li><input disabled="" type="checkbox"/>
Quote values containing special characters</li>
<li><input disabled="" type="checkbox"/>
Validate all required variables at startup</li>
</ul>
<h2 id="5-mev-protection"><a class="header" href="#5-mev-protection">5. MEV Protection</a></h2>
<h3 id="mev-mitigation-strategies"><a class="header" href="#mev-mitigation-strategies">MEV Mitigation Strategies</a></h3>
<p>The library implements multiple MEV (Maximum Extractable Value) protection mechanisms:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Trading with slippage protection
pub async fn buy_token(
    &amp;self,
    token_address: &amp;str,
    amount_sol: f64,
    slippage_percent: Option&lt;f64&gt;, // MEV protection via slippage limits
) -&gt; Result&lt;TradingResponse, TradingError&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>MEV Protection Features:</strong></p>
<ul>
<li><strong>Slippage Limits</strong>: Configurable slippage tolerance (0.1-5%)</li>
<li><strong>Service Monitoring</strong>: Health checks for MEV protection services</li>
<li><strong>Multiple Providers</strong>: Integration with 0slot, Jito, and other MEV services</li>
<li><strong>Batch Operations</strong>: Reduced MEV exposure through transaction batching</li>
</ul>
<h3 id="mev-service-integration"><a class="header" href="#mev-service-integration">MEV Service Integration</a></h3>
<p>Infrastructure monitoring for MEV protection:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn check_external_mev_health(&amp;self) -&gt; Result&lt;ServiceHealth&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>Supported Services:</strong></p>
<ul>
<li><strong>0slot</strong>: Primary MEV protection service</li>
<li><strong>Jito</strong>: Alternative MEV protection</li>
<li><strong>Custom Services</strong>: Configurable external MEV protection</li>
<li><strong>Health Monitoring</strong>: Continuous service availability checks</li>
</ul>
<h3 id="anti-mev-trading-patterns"><a class="header" href="#anti-mev-trading-patterns">Anti-MEV Trading Patterns</a></h3>
<p><strong>Best Practices:</strong></p>
<ul>
<li>Use appropriate slippage tolerance (0.1-1% for liquid tokens)</li>
<li>Monitor transaction timing and ordering</li>
<li>Implement randomized delays for automated trading</li>
<li>Use MEV protection services for large transactions</li>
<li>Consider private mempools for sensitive operations</li>
</ul>
<h2 id="6-network-security"><a class="header" href="#6-network-security">6. Network Security</a></h2>
<h3 id="https-enforcement"><a class="header" href="#https-enforcement">HTTPS Enforcement</a></h3>
<p>All network communications use TLS encryption:</p>
<ul>
<li><strong>TLS 1.2+ Required</strong>: Modern encryption standards</li>
<li><strong>Certificate Validation</strong>: Proper SSL certificate checking</li>
<li><strong>Secure Headers</strong>: Implementation of security headers</li>
<li><strong>Request Signing</strong>: Cryptographic request authentication</li>
</ul>
<h3 id="rate-limiting-3"><a class="header" href="#rate-limiting-3">Rate Limiting</a></h3>
<p>Built-in rate limiting prevents abuse:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RateLimiter {
    // Implementation details for API rate limiting
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Protection Features:</strong></p>
<ul>
<li><strong>Request Throttling</strong>: Prevents API abuse</li>
<li><strong>Backoff Strategies</strong>: Exponential backoff for retries</li>
<li><strong>Burst Protection</strong>: Handles traffic spikes gracefully</li>
<li><strong>Error Recovery</strong>: Graceful degradation under load</li>
</ul>
<h2 id="7-automated-otp-security"><a class="header" href="#7-automated-otp-security">7. Automated OTP Security</a></h2>
<h3 id="secure-otp-fetching"><a class="header" href="#secure-otp-fetching">Secure OTP Fetching</a></h3>
<p>Optional automated OTP retrieval with secure IMAP:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OtpFetcher {
    email: String,    // inbox.lv email
    password: String, // IMAP-specific password
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Features:</strong></p>
<ul>
<li><strong>Dedicated Email</strong>: Separate inbox.lv account for OTP</li>
<li><strong>IMAP Security</strong>: Secure IMAP/SSL connection</li>
<li><strong>Credential Isolation</strong>: OTP credentials separate from trading credentials</li>
<li><strong>Pattern Matching</strong>: Secure regex parsing for OTP codes</li>
</ul>
<h3 id="otp-best-practices"><a class="header" href="#otp-best-practices">OTP Best Practices</a></h3>
<p><strong>Setup Requirements:</strong></p>
<ol>
<li>Create dedicated inbox.lv account</li>
<li>Enable IMAP access with special password</li>
<li>Configure email forwarding from Axiom Trade</li>
<li>Store IMAP credentials securely</li>
<li>Monitor for unauthorized access</li>
</ol>
<h2 id="8-security-monitoring-and-debugging"><a class="header" href="#8-security-monitoring-and-debugging">8. Security Monitoring and Debugging</a></h2>
<h3 id="session-tracking"><a class="header" href="#session-tracking">Session Tracking</a></h3>
<p>Comprehensive session monitoring:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SessionMetadata {
    pub created_at: DateTime&lt;Utc&gt;,
    pub last_refreshed_at: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub last_api_call_at: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub current_api_server: Option&lt;String&gt;,
    pub user_agent: String,
    pub ip_address: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Monitoring Features:</strong></p>
<ul>
<li><strong>Session Lifecycle</strong>: Track session creation and usage</li>
<li><strong>API Activity</strong>: Monitor API call patterns</li>
<li><strong>User Agent Rotation</strong>: Prevent fingerprinting</li>
<li><strong>Server Selection</strong>: Track API server usage</li>
<li><strong>Anomaly Detection</strong>: Identify unusual patterns</li>
</ul>
<h3 id="security-logs"><a class="header" href="#security-logs">Security Logs</a></h3>
<p>Structured logging for security events:</p>
<ul>
<li><strong>Authentication Events</strong>: Login, logout, token refresh</li>
<li><strong>Trading Activity</strong>: All trading operations with metadata</li>
<li><strong>Error Tracking</strong>: Security-related errors and failures</li>
<li><strong>Session Changes</strong>: User agent updates, server switches</li>
</ul>
<h2 id="9-deployment-security"><a class="header" href="#9-deployment-security">9. Deployment Security</a></h2>
<h3 id="production-hardening"><a class="header" href="#production-hardening">Production Hardening</a></h3>
<p><strong>Environment Security:</strong></p>
<ul>
<li>Use container orchestration secrets management</li>
<li>Implement network segmentation</li>
<li>Enable audit logging</li>
<li>Regular security updates</li>
<li>Monitoring and alerting</li>
</ul>
<p><strong>Infrastructure Security:</strong></p>
<ul>
<li>Firewall configuration</li>
<li>VPN access for management</li>
<li>Encrypted storage for session data</li>
<li>Regular backup and recovery testing</li>
<li>Incident response procedures</li>
</ul>
<h3 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h3>
<p><strong>Pre-Deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
All secrets in environment variables, not code</li>
<li><input disabled="" type="checkbox"/>
TLS/SSL certificates properly configured</li>
<li><input disabled="" type="checkbox"/>
Rate limiting enabled and tested</li>
<li><input disabled="" type="checkbox"/>
Monitoring and alerting configured</li>
<li><input disabled="" type="checkbox"/>
Backup and recovery procedures tested</li>
</ul>
<p><strong>Ongoing Security:</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
Regular token rotation</li>
<li><input disabled="" type="checkbox"/>
Monitor for unusual trading patterns</li>
<li><input disabled="" type="checkbox"/>
Keep dependencies updated</li>
<li><input disabled="" type="checkbox"/>
Review security logs regularly</li>
<li><input disabled="" type="checkbox"/>
Test incident response procedures</li>
</ul>
<h2 id="10-compliance-and-best-practices"><a class="header" href="#10-compliance-and-best-practices">10. Compliance and Best Practices</a></h2>
<h3 id="industry-standards"><a class="header" href="#industry-standards">Industry Standards</a></h3>
<p>The library adheres to multiple security standards:</p>
<ul>
<li><strong>OWASP Guidelines</strong>: Secure coding practices</li>
<li><strong>NIST Cryptographic Standards</strong>: P-256, SHA256, PBKDF2</li>
<li><strong>OAuth 2.0 Security</strong>: Proper token handling</li>
<li><strong>JWT Best Practices</strong>: Secure token management</li>
</ul>
<h3 id="security-development-lifecycle"><a class="header" href="#security-development-lifecycle">Security Development Lifecycle</a></h3>
<p><strong>Code Security:</strong></p>
<ul>
<li>Static analysis for security vulnerabilities</li>
<li>Dependency scanning for known vulnerabilities</li>
<li>Regular security reviews and audits</li>
<li>Penetration testing for critical paths</li>
</ul>
<p><strong>Operational Security:</strong></p>
<ul>
<li>Incident response procedures</li>
<li>Security monitoring and alerting</li>
<li>Regular security training</li>
<li>Vulnerability disclosure process</li>
</ul>
<p>This comprehensive security framework ensures that axiomtrade-rs provides enterprise-grade protection for trading operations while maintaining usability and performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization-guide"><a class="header" href="#performance-optimization-guide">Performance Optimization Guide</a></h1>
<p>This comprehensive guide covers performance best practices for high-frequency trading applications, based on patterns observed in the axiomtrade-rs codebase.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ol>
<li><a href="best-practices/performance.html#asyncawait-best-practices">Async/Await Best Practices</a></li>
<li><a href="best-practices/performance.html#connection-pooling-and-management">Connection Pooling and Management</a></li>
<li><a href="best-practices/performance.html#batch-operations">Batch Operations</a></li>
<li><a href="best-practices/performance.html#memory-management">Memory Management</a></li>
<li><a href="best-practices/performance.html#rate-limiting-and-throttling">Rate Limiting and Throttling</a></li>
<li><a href="best-practices/performance.html#benchmarking-and-monitoring">Benchmarking and Monitoring</a></li>
<li><a href="best-practices/performance.html#high-frequency-trading-optimizations">High-Frequency Trading Optimizations</a></li>
<li><a href="best-practices/performance.html#network-optimization">Network Optimization</a></li>
</ol>
<h2 id="asyncawait-best-practices"><a class="header" href="#asyncawait-best-practices">Async/Await Best Practices</a></h2>
<h3 id="1-efficient-task-spawning"><a class="header" href="#1-efficient-task-spawning">1. Efficient Task Spawning</a></h3>
<p>Use <code>tokio::spawn</code> for CPU-intensive tasks and concurrent operations:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Spawn independent tasks
let handles: Vec&lt;_&gt; = wallet_addresses.iter().map(|address| {
    let client = client.clone();
    let address = address.clone();
    tokio::spawn(async move {
        client.get_balance(&amp;address).await
    })
}).collect();

// Wait for all tasks to complete
let results = futures_util::future::try_join_all(handles).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-avoid-blocking-in-async-context"><a class="header" href="#2-avoid-blocking-in-async-context">2. Avoid Blocking in Async Context</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Blocking I/O in async context
async fn bad_example() {
    std::fs::read_to_string("file.json").unwrap(); // Blocks entire runtime
}

// Good: Use async I/O
async fn good_example() {
    tokio::fs::read_to_string("file.json").await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-strategic-use-of-arc-and-rwlock"><a class="header" href="#3-strategic-use-of-arc-and-rwlock">3. Strategic Use of Arc and RwLock</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EnhancedClient {
    auth_client: Arc&lt;RwLock&lt;AuthClient&gt;&gt;,
    rate_limiter: EndpointRateLimiter,
    global_rate_limiter: RateLimiter,
}

// Minimize lock contention
impl EnhancedClient {
    pub async fn make_request(&amp;self, method: Method, url: &amp;str) -&gt; Result&lt;Response&gt; {
        // Check rate limits first (no lock needed)
        self.global_rate_limiter.wait_if_needed().await;
        
        // Only acquire lock when needed
        let auth_client = Arc::clone(&amp;self.auth_client);
        let result = retry_with_config(self.retry_config.clone(), || {
            let auth_client = Arc::clone(&amp;auth_client);
            async move {
                auth_client.write().await
                    .make_authenticated_request(method, url, body)
                    .await
            }
        }).await?;
        
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-efficient-error-handling"><a class="header" href="#4-efficient-error-handling">4. Efficient Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RetryableError for EnhancedClientError {
    fn is_retryable(&amp;self) -&gt; bool {
        match self {
            EnhancedClientError::NetworkError(e) =&gt; e.is_timeout() || e.is_connect(),
            EnhancedClientError::RateLimitExceeded =&gt; true,
            _ =&gt; false,
        }
    }
}

// Use custom retry logic for better performance
pub async fn retry_with_backoff&lt;F, Fut, T, E&gt;(
    config: RetryConfig,
    mut operation: F,
) -&gt; Result&lt;T, E&gt;
where
    F: FnMut() -&gt; Fut,
    Fut: Future&lt;Output = Result&lt;T, E&gt;&gt;,
    E: RetryableError,
{
    for attempt in 0..=config.max_retries {
        match operation().await {
            Ok(result) =&gt; return Ok(result),
            Err(error) =&gt; {
                if !error.is_retryable() || attempt == config.max_retries {
                    return Err(error);
                }
                
                let delay = config.calculate_delay(attempt);
                tokio::time::sleep(delay).await;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-pooling-and-management"><a class="header" href="#connection-pooling-and-management">Connection Pooling and Management</a></h2>
<h3 id="1-http-client-reuse"><a class="header" href="#1-http-client-reuse">1. HTTP Client Reuse</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Reuse client with connection pooling
lazy_static! {
    static ref HTTP_CLIENT: reqwest::Client = {
        reqwest::Client::builder()
            .pool_max_idle_per_host(10)
            .pool_idle_timeout(Duration::from_secs(30))
            .timeout(Duration::from_secs(30))
            .tcp_keepalive(Duration::from_secs(60))
            .tcp_nodelay(true)
            .build()
            .expect("Failed to create HTTP client")
    };
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-websocket-connection-management"><a class="header" href="#2-websocket-connection-management">2. WebSocket Connection Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WebSocketClient {
    region: Region,
    handler: Arc&lt;dyn MessageHandler&gt;,
    is_connected: Arc&lt;RwLock&lt;bool&gt;&gt;,
    reconnect_on_expire: bool,
}

impl WebSocketClient {
    // Use multiple endpoints for redundancy
    fn get_random_url(&amp;self) -&gt; &amp;'static str {
        let urls = match self.region {
            Region::USWest =&gt; vec!["socket8.axiom.trade", "cluster-usw2.axiom.trade"],
            Region::USCentral =&gt; vec!["cluster3.axiom.trade", "cluster-usc2.axiom.trade"],
            // ...
        };
        urls[fastrand::usize(0..urls.len())]
    }
    
    // Automatic token refresh
    fn spawn_token_refresh_task(&amp;self) {
        let auth_client = Arc::clone(&amp;self.auth_client);
        let is_connected = Arc::clone(&amp;self.is_connected);
        
        tokio::spawn(async move {
            let mut refresh_interval = interval(Duration::from_secs(600));
            
            loop {
                refresh_interval.tick().await;
                
                if !*is_connected.read().await {
                    break;
                }
                
                if let Err(e) = auth_client.write().await.ensure_valid_authentication().await {
                    *is_connected.write().await = false;
                    break;
                }
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-session-management"><a class="header" href="#3-session-management">3. Session Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SessionManager {
    session: Arc&lt;RwLock&lt;Option&lt;AuthSession&gt;&gt;&gt;,
    storage_path: Option&lt;PathBuf&gt;,
    auto_save: bool,
}

impl SessionManager {
    // Efficient session validation
    pub async fn is_session_valid(&amp;self) -&gt; bool {
        let guard = self.session.read().await;
        guard.as_ref().map_or(false, |session| session.is_valid())
    }
    
    // Batch operations for session updates
    pub async fn update_session_data(
        &amp;self, 
        tokens: Option&lt;AuthTokens&gt;,
        cookies: Option&lt;AuthCookies&gt;
    ) -&gt; Result&lt;(), AuthError&gt; {
        {
            let mut guard = self.session.write().await;
            if let Some(session) = guard.as_mut() {
                if let Some(tokens) = tokens {
                    session.update_tokens(tokens);
                }
                if let Some(cookies) = cookies {
                    session.cookies.merge_with(&amp;cookies);
                }
            }
        }
        
        if self.auto_save {
            self.save_session().await?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="batch-operations-1"><a class="header" href="#batch-operations-1">Batch Operations</a></h2>
<h3 id="1-efficient-batch-balance-queries"><a class="header" href="#1-efficient-batch-balance-queries">1. Efficient Batch Balance Queries</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of individual queries
pub async fn get_balances_inefficient(
    &amp;self, 
    addresses: &amp;[String]
) -&gt; Result&lt;Vec&lt;Balance&gt;, PortfolioError&gt; {
    let mut balances = Vec::new();
    for address in addresses {
        let balance = self.get_balance(address).await?; // N API calls
        balances.push(balance);
    }
    Ok(balances)
}

// Use batch endpoint
pub async fn get_batch_balance(
    &amp;self,
    wallet_addresses: &amp;[String],
) -&gt; Result&lt;BatchBalanceResponse, PortfolioError&gt; {
    let request_body = json!({
        "wallets": wallet_addresses
    });
    
    self.client
        .make_json_request(Method::POST, "/portfolio/batch-balance", Some(request_body))
        .await
        .map_err(PortfolioError::from)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-concurrent-processing"><a class="header" href="#2-concurrent-processing">2. Concurrent Processing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn process_batch_concurrent&lt;T, F, Fut&gt;(
    items: Vec&lt;T&gt;,
    concurrency_limit: usize,
    processor: F,
) -&gt; Vec&lt;Result&lt;F::Output, F::Error&gt;&gt;
where
    F: Fn(T) -&gt; Fut + Clone + Send + 'static,
    Fut: Future&lt;Output = Result&lt;F::Output, F::Error&gt;&gt; + Send,
    T: Send + 'static,
{
    let semaphore = Arc::new(Semaphore::new(concurrency_limit));
    let tasks: Vec&lt;_&gt; = items.into_iter().map(|item| {
        let semaphore = Arc::clone(&amp;semaphore);
        let processor = processor.clone();
        
        tokio::spawn(async move {
            let _permit = semaphore.acquire().await.unwrap();
            processor(item).await
        })
    }).collect();
    
    futures_util::future::join_all(tasks).await
        .into_iter()
        .map(|result| result.unwrap())
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-management-3"><a class="header" href="#memory-management-3">Memory Management</a></h2>
<h3 id="1-efficient-data-structures"><a class="header" href="#1-efficient-data-structures">1. Efficient Data Structures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use bounded collections for streaming data
struct MarketDataBuffer {
    ticks: VecDeque&lt;MarketTick&gt;,
    max_size: usize,
}

impl MarketDataBuffer {
    fn new() -&gt; Self {
        Self {
            ticks: VecDeque::with_capacity(10000),
            max_size: 10000,
        }
    }
    
    fn add_tick(&amp;mut self, tick: MarketTick) {
        if self.ticks.len() &gt;= self.max_size {
            self.ticks.pop_front(); // Remove oldest
        }
        self.ticks.push_back(tick);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-zero-copy-patterns"><a class="header" href="#2-zero-copy-patterns">2. Zero-Copy Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use references instead of cloning
pub fn process_market_data(data: &amp;[MarketTick]) -&gt; MarketState {
    let mut total_volume = 0.0;
    let mut price_sum = 0.0;
    
    for tick in data.iter() {  // Iterator over references
        total_volume += tick.quantity;
        price_sum += tick.price;
    }
    
    MarketState {
        avg_price: price_sum / data.len() as f64,
        total_volume,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-memory-pool-usage"><a class="header" href="#3-memory-pool-usage">3. Memory Pool Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pre-allocate frequently used objects
pub struct OrderPool {
    orders: Vec&lt;Order&gt;,
    free_indices: Vec&lt;usize&gt;,
}

impl OrderPool {
    pub fn new(capacity: usize) -&gt; Self {
        let orders = (0..capacity)
            .map(|_| Order::default())
            .collect();
        let free_indices = (0..capacity).collect();
        
        Self { orders, free_indices }
    }
    
    pub fn acquire(&amp;mut self) -&gt; Option&lt;&amp;mut Order&gt; {
        self.free_indices.pop()
            .map(|idx| &amp;mut self.orders[idx])
    }
    
    pub fn release(&amp;mut self, order: &amp;Order) {
        if let Some(idx) = self.orders.iter().position(|o| std::ptr::eq(o, order)) {
            self.orders[idx].reset();
            self.free_indices.push(idx);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rate-limiting-and-throttling"><a class="header" href="#rate-limiting-and-throttling">Rate Limiting and Throttling</a></h2>
<h3 id="1-token-bucket-rate-limiter"><a class="header" href="#1-token-bucket-rate-limiter">1. Token Bucket Rate Limiter</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BucketRateLimiter {
    tokens: Arc&lt;RwLock&lt;f64&gt;&gt;,
    max_tokens: f64,
    refill_rate: f64,
    last_refill: Arc&lt;RwLock&lt;Instant&gt;&gt;,
}

impl BucketRateLimiter {
    pub async fn try_consume(&amp;self, tokens_needed: f64) -&gt; Option&lt;Duration&gt; {
        let mut tokens = self.tokens.write().await;
        let mut last_refill = self.last_refill.write().await;
        let now = Instant::now();
        
        // Refill tokens based on elapsed time
        let elapsed = now.duration_since(*last_refill).as_secs_f64();
        let tokens_to_add = (elapsed * self.refill_rate).min(self.max_tokens - *tokens);
        *tokens = (*tokens + tokens_to_add).min(self.max_tokens);
        *last_refill = now;
        
        if *tokens &gt;= tokens_needed {
            *tokens -= tokens_needed;
            None
        } else {
            let tokens_deficit = tokens_needed - *tokens;
            let wait_time = Duration::from_secs_f64(tokens_deficit / self.refill_rate);
            Some(wait_time)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-endpoint-specific-rate-limiting"><a class="header" href="#2-endpoint-specific-rate-limiting">2. Endpoint-Specific Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EndpointRateLimiter {
    limiters: Arc&lt;RwLock&lt;HashMap&lt;String, RateLimiter&gt;&gt;&gt;,
    default_limiter: RateLimiter,
}

impl EndpointRateLimiter {
    pub async fn wait_for_endpoint(&amp;self, endpoint: &amp;str) {
        let limiters = self.limiters.read().await;
        
        if let Some(limiter) = limiters.get(endpoint) {
            limiter.wait_if_needed().await;
        } else {
            drop(limiters); // Release read lock
            self.default_limiter.wait_if_needed().await;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="benchmarking-and-monitoring"><a class="header" href="#benchmarking-and-monitoring">Benchmarking and Monitoring</a></h2>
<h3 id="1-performance-metrics-collection"><a class="header" href="#1-performance-metrics-collection">1. Performance Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LatencyTracker {
    execution_latencies: VecDeque&lt;Duration&gt;,
    max_samples: usize,
}

impl LatencyTracker {
    pub fn record_execution_latency(&amp;mut self, latency: Duration) {
        if self.execution_latencies.len() &gt;= self.max_samples {
            self.execution_latencies.pop_front();
        }
        self.execution_latencies.push_back(latency);
    }
    
    pub fn get_percentiles(&amp;self) -&gt; LatencyPercentiles {
        let mut sorted: Vec&lt;_&gt; = self.execution_latencies.iter().collect();
        sorted.sort();
        
        let len = sorted.len();
        LatencyPercentiles {
            p50: *sorted[len * 50 / 100],
            p95: *sorted[len * 95 / 100],
            p99: *sorted[len * 99 / 100],
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-real-time-performance-monitoring"><a class="header" href="#2-real-time-performance-monitoring">2. Real-time Performance Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn monitor_performance(
    &amp;self,
    interval: Duration
) -&gt; tokio::task::JoinHandle&lt;()&gt; {
    let latency_tracker = Arc::clone(&amp;self.latency_tracker);
    
    tokio::spawn(async move {
        let mut monitoring_interval = tokio::time::interval(interval);
        
        loop {
            monitoring_interval.tick().await;
            
            let tracker = latency_tracker.lock().await;
            let avg_latency = tracker.get_average_latency();
            let percentiles = tracker.get_percentiles();
            
            if avg_latency &gt; Duration::from_millis(10) {
                println!("⚠️  High average latency: {:.2}ms", 
                    avg_latency.as_secs_f64() * 1000.0);
            }
            
            if percentiles.p99 &gt; Duration::from_millis(50) {
                println!("🚨 P99 latency spike: {:.2}ms", 
                    percentiles.p99.as_secs_f64() * 1000.0);
            }
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-benchmarking-framework"><a class="header" href="#3-benchmarking-framework">3. Benchmarking Framework</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod benchmarks {
    use super::*;
    use std::time::Instant;
    
    #[tokio::test]
    async fn benchmark_batch_vs_individual() {
        let client = setup_test_client().await;
        let addresses = generate_test_addresses(100);
        
        // Benchmark individual requests
        let start = Instant::now();
        for address in &amp;addresses {
            client.get_balance(address).await.unwrap();
        }
        let individual_time = start.elapsed();
        
        // Benchmark batch request
        let start = Instant::now();
        client.get_batch_balance(&amp;addresses).await.unwrap();
        let batch_time = start.elapsed();
        
        println!("Individual: {:.2}ms", individual_time.as_secs_f64() * 1000.0);
        println!("Batch: {:.2}ms", batch_time.as_secs_f64() * 1000.0);
        println!("Speedup: {:.2}x", individual_time.as_secs_f64() / batch_time.as_secs_f64());
        
        assert!(batch_time &lt; individual_time / 5); // At least 5x faster
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="high-frequency-trading-optimizations"><a class="header" href="#high-frequency-trading-optimizations">High-Frequency Trading Optimizations</a></h2>
<h3 id="1-ultra-low-latency-execution"><a class="header" href="#1-ultra-low-latency-execution">1. Ultra-Low Latency Execution</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ExecutionEngine {
    config: ExecutionConfig,
}

impl ExecutionEngine {
    pub async fn execute_order_ultra_fast(
        &amp;self,
        client: &amp;EnhancedClient,
        signal: &amp;HftSignal,
    ) -&gt; Result&lt;ExecutionResult&gt; {
        let execution_start = Instant::now();
        
        // Pre-validate signal (avoid blocking operations)
        if signal.confidence &lt; self.config.min_confidence {
            return Err(ExecutionError::LowConfidence);
        }
        
        // Use IOC (Immediate or Cancel) orders for speed
        let order_request = self.build_order_request(signal, OrderTimeInForce::IOC);
        
        // Execute with timeout
        let result = tokio::time::timeout(
            self.config.max_latency_tolerance,
            client.submit_order(order_request)
        ).await??;
        
        let execution_latency = execution_start.elapsed();
        
        // Record metrics
        self.metrics.record_execution_latency(execution_latency);
        
        if execution_latency &gt; self.config.max_latency_tolerance {
            println!("⚠️  Execution exceeded latency budget: {:.3}ms", 
                execution_latency.as_secs_f64() * 1000.0);
        }
        
        Ok(ExecutionResult {
            execution_latency,
            ..result
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-market-microstructure-analysis"><a class="header" href="#2-market-microstructure-analysis">2. Market Microstructure Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MicrostructureAnalyzer {
    order_flow_buffer: VecDeque&lt;OrderFlowEvent&gt;,
    tick_buffer: VecDeque&lt;MarketTick&gt;,
}

impl MicrostructureAnalyzer {
    pub fn analyze_market_impact(&amp;self, order_size: f64) -&gt; f64 {
        let recent_ticks: Vec&lt;_&gt; = self.tick_buffer
            .iter()
            .rev()
            .take(100)
            .collect();
        
        if recent_ticks.is_empty() {
            return 0.0;
        }
        
        // Calculate volume-weighted average price
        let total_volume: f64 = recent_ticks.iter().map(|t| t.quantity).sum();
        let vwap: f64 = recent_ticks.iter()
            .map(|t| t.price * t.quantity)
            .sum::&lt;f64&gt;() / total_volume;
        
        // Estimate impact based on order size vs recent volume
        let avg_volume = total_volume / recent_ticks.len() as f64;
        let impact_factor = (order_size / avg_volume).min(1.0);
        
        impact_factor * 0.001 // Convert to basis points
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-smart-order-routing"><a class="header" href="#3-smart-order-routing">3. Smart Order Routing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SmartOrderRouter {
    venues: Vec&lt;TradingVenue&gt;,
    latency_tracker: HashMap&lt;VenueId, LatencyTracker&gt;,
}

impl SmartOrderRouter {
    pub async fn route_order(&amp;self, order: &amp;Order) -&gt; Result&lt;VenueId&gt; {
        let mut best_venue = None;
        let mut best_score = f64::NEG_INFINITY;
        
        for venue in &amp;self.venues {
            let score = self.calculate_venue_score(venue, order).await;
            if score &gt; best_score {
                best_score = score;
                best_venue = Some(venue.id);
            }
        }
        
        best_venue.ok_or(RoutingError::NoSuitableVenue)
    }
    
    async fn calculate_venue_score(&amp;self, venue: &amp;TradingVenue, order: &amp;Order) -&gt; f64 {
        let liquidity_score = venue.get_liquidity_score(order.symbol()).await;
        let latency_score = self.get_latency_score(venue.id).await;
        let fee_score = 1.0 - venue.get_fee_rate(order.symbol()).await;
        
        // Weighted combination
        liquidity_score * 0.4 + latency_score * 0.4 + fee_score * 0.2
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="network-optimization"><a class="header" href="#network-optimization">Network Optimization</a></h2>
<h3 id="1-tcp-optimization"><a class="header" href="#1-tcp-optimization">1. TCP Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure HTTP client for optimal performance
fn create_optimized_client() -&gt; reqwest::Client {
    reqwest::Client::builder()
        .tcp_nodelay(true)                    // Disable Nagle's algorithm
        .tcp_keepalive(Duration::from_secs(60)) // Keep connections alive
        .pool_max_idle_per_host(20)           // Connection pooling
        .pool_idle_timeout(Duration::from_secs(30))
        .timeout(Duration::from_secs(10))     // Request timeout
        .connect_timeout(Duration::from_secs(5)) // Connection timeout
        .user_agent("axiomtrade-rs/1.0")
        .build()
        .expect("Failed to create HTTP client")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-websocket-optimization"><a class="header" href="#2-websocket-optimization">2. WebSocket Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure WebSocket for minimal latency
pub async fn connect_optimized_websocket(url: &amp;str) -&gt; Result&lt;WebSocketStream&gt; {
    let request = http::Request::builder()
        .method("GET")
        .uri(url)
        .header("Connection", "Upgrade")
        .header("Upgrade", "websocket")
        .header("Sec-WebSocket-Version", "13")
        .header("Sec-WebSocket-Key", generate_key())
        .header("Cache-Control", "no-cache")
        .header("Pragma", "no-cache")
        .body(())?;
    
    let (ws_stream, _) = connect_async(request).await?;
    
    // Configure stream for minimal buffering
    // (Platform-specific socket options would go here)
    
    Ok(ws_stream)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-regional-optimization"><a class="header" href="#3-regional-optimization">3. Regional Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Region {
    USWest,
    USCentral, 
    USEast,
    EUWest,
    // ...
}

impl Region {
    pub fn get_optimal_endpoints(&amp;self) -&gt; Vec&lt;&amp;'static str&gt; {
        match self {
            Region::USWest =&gt; vec![
                "socket8.axiom.trade",      // Primary
                "cluster-usw2.axiom.trade", // Backup
            ],
            // Select closest endpoints for minimal latency
        }
    }
    
    pub async fn measure_latency(&amp;self, endpoint: &amp;str) -&gt; Result&lt;Duration&gt; {
        let start = Instant::now();
        let _response = reqwest::get(format!("https://{}/health", endpoint)).await?;
        Ok(start.elapsed())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-monitoring-dashboard"><a class="header" href="#performance-monitoring-dashboard">Performance Monitoring Dashboard</a></h2>
<h3 id="real-time-metrics"><a class="header" href="#real-time-metrics">Real-time Metrics</a></h3>
<p>Monitor these key performance indicators:</p>
<ul>
<li><strong>Execution Latency</strong>: P50, P95, P99 execution times</li>
<li><strong>Network Latency</strong>: Round-trip times to API endpoints</li>
<li><strong>Rate Limit Status</strong>: Remaining capacity for each endpoint</li>
<li><strong>Memory Usage</strong>: Heap usage and garbage collection frequency</li>
<li><strong>Connection Health</strong>: Active connections and error rates</li>
<li><strong>Order Flow</strong>: Orders per second and fill rates</li>
</ul>
<h3 id="alerting-thresholds"><a class="header" href="#alerting-thresholds">Alerting Thresholds</a></h3>
<p>Set up alerts for:</p>
<ul>
<li>P99 latency &gt; 50ms</li>
<li>Error rate &gt; 1%</li>
<li>Memory usage &gt; 80%</li>
<li>Rate limit utilization &gt; 90%</li>
<li>Connection failures &gt; 5 per minute</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Effective performance optimization requires:</p>
<ol>
<li><strong>Proactive Monitoring</strong>: Instrument code to measure what matters</li>
<li><strong>Efficient Resource Usage</strong>: Pool connections, batch operations, minimize allocations</li>
<li><strong>Network Optimization</strong>: Choose optimal endpoints, configure TCP properly</li>
<li><strong>Async Best Practices</strong>: Avoid blocking, use appropriate concurrency patterns</li>
<li><strong>Continuous Benchmarking</strong>: Measure improvements and catch regressions</li>
</ol>
<p>The patterns demonstrated in this codebase provide a solid foundation for building high-performance trading applications that can handle the demands of modern financial markets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-issues-5"><a class="header" href="#common-issues-5">Common Issues</a></h1>
<p>This guide covers the most frequently encountered issues when using the Axiom Trade Rust client and their solutions.</p>
<h2 id="authentication-failures-2"><a class="header" href="#authentication-failures-2">Authentication Failures</a></h2>
<h3 id="invalid-login-credentials"><a class="header" href="#invalid-login-credentials">Invalid Login Credentials</a></h3>
<p><strong>Problem</strong>: Login fails with "Invalid credentials" error.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Verify credentials</strong>: Double-check your email and password</li>
<li><strong>Check password hashing</strong>: Ensure you're using the correct PBKDF2 implementation with 600,000 iterations</li>
<li><strong>Account status</strong>: Verify your account is active and not suspended</li>
<li><strong>Case sensitivity</strong>: Email addresses are case-sensitive in some systems</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Correct password hashing example
use pbkdf2::{password_hash::{PasswordHasher, SaltString}, Pbkdf2};

let salt = SaltString::generate(&amp;mut OsRng);
let password_hash = Pbkdf2.hash_password_customized(
    password.as_bytes(),
    Some(pbkdf2::password_hash::Ident::new("pbkdf2")?),
    None,
    pbkdf2::Params {
        rounds: 600_000,
        output_length: 32,
    },
    &amp;salt,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="otp-verification-issues"><a class="header" href="#otp-verification-issues">OTP Verification Issues</a></h3>
<p><strong>Problem</strong>: OTP verification fails or times out.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Time synchronization</strong>: Ensure your system clock is accurate</li>
<li><strong>OTP expiration</strong>: Use the OTP within 5 minutes of receipt</li>
<li><strong>Email delivery</strong>: Check spam folder for OTP emails</li>
<li><strong>Automated OTP setup</strong>: Configure inbox.lv automation for seamless OTP handling</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable automated OTP fetching
std::env::set_var("INBOX_LV_EMAIL", "your_email@inbox.lv");
std::env::set_var("INBOX_LV_PASSWORD", "your_imap_password");
<span class="boring">}</span></code></pre></pre>
<h3 id="token-expiration"><a class="header" href="#token-expiration">Token Expiration</a></h3>
<p><strong>Problem</strong>: API calls fail with "Token expired" error.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Automatic refresh</strong>: Implement token refresh logic</li>
<li><strong>Token storage</strong>: Persist tokens securely between sessions</li>
<li><strong>Expiration monitoring</strong>: Check token expiry before making API calls</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Token refresh example
if token_manager.is_expired() {
    token_manager.refresh_token().await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-issues"><a class="header" href="#connection-issues">Connection Issues</a></h2>
<h3 id="network-timeouts"><a class="header" href="#network-timeouts">Network Timeouts</a></h3>
<p><strong>Problem</strong>: Requests timeout or fail to connect.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Increase timeout</strong>: Set appropriate timeout values for your network</li>
<li><strong>Retry logic</strong>: Implement exponential backoff for failed requests</li>
<li><strong>Network connectivity</strong>: Check internet connection and DNS resolution</li>
<li><strong>Firewall settings</strong>: Ensure Axiom Trade endpoints are not blocked</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure client with proper timeouts
let client = reqwest::Client::builder()
    .timeout(Duration::from_secs(30))
    .connect_timeout(Duration::from_secs(10))
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="ssltls-errors"><a class="header" href="#ssltls-errors">SSL/TLS Errors</a></h3>
<p><strong>Problem</strong>: SSL certificate verification failures.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Certificate validation</strong>: Ensure system certificates are up to date</li>
<li><strong>TLS version</strong>: Use TLS 1.2 or higher</li>
<li><strong>Corporate proxies</strong>: Configure proxy settings if behind corporate firewall</li>
<li><strong>Certificate pinning</strong>: Implement certificate pinning for enhanced security</li>
</ol>
<h3 id="dns-resolution-issues"><a class="header" href="#dns-resolution-issues">DNS Resolution Issues</a></h3>
<p><strong>Problem</strong>: Cannot resolve Axiom Trade domain names.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>DNS servers</strong>: Try different DNS servers (8.8.8.8, 1.1.1.1)</li>
<li><strong>Hosts file</strong>: Check for incorrect entries in hosts file</li>
<li><strong>Network configuration</strong>: Verify network adapter settings</li>
<li><strong>VPN interference</strong>: Disable VPN temporarily to test connectivity</li>
</ol>
<h2 id="rate-limit-errors"><a class="header" href="#rate-limit-errors">Rate Limit Errors</a></h2>
<h3 id="http-429-too-many-requests"><a class="header" href="#http-429-too-many-requests">HTTP 429 Too Many Requests</a></h3>
<p><strong>Problem</strong>: API returns rate limit exceeded errors.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Request spacing</strong>: Implement delays between API calls</li>
<li><strong>Rate limiter</strong>: Use built-in rate limiting functionality</li>
<li><strong>Batch operations</strong>: Combine multiple operations into batch requests</li>
<li><strong>Retry-After header</strong>: Respect the Retry-After header in responses</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rate limiting example
use std::time::{Duration, Instant};

struct RateLimiter {
    last_request: Instant,
    min_interval: Duration,
}

impl RateLimiter {
    fn wait_if_needed(&amp;mut self) {
        let elapsed = self.last_request.elapsed();
        if elapsed &lt; self.min_interval {
            std::thread::sleep(self.min_interval - elapsed);
        }
        self.last_request = Instant::now();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="burst-rate-limits"><a class="header" href="#burst-rate-limits">Burst Rate Limits</a></h3>
<p><strong>Problem</strong>: Hitting burst limits with rapid successive requests.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Queue requests</strong>: Implement request queuing system</li>
<li><strong>Parallel limits</strong>: Limit concurrent requests</li>
<li><strong>Request prioritization</strong>: Prioritize critical operations</li>
<li><strong>Caching</strong>: Cache frequently requested data</li>
</ol>
<h3 id="api-quota-exhaustion"><a class="header" href="#api-quota-exhaustion">API Quota Exhaustion</a></h3>
<p><strong>Problem</strong>: Daily or monthly API quotas exceeded.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Usage monitoring</strong>: Track API usage against quotas</li>
<li><strong>Efficient queries</strong>: Optimize queries to reduce API calls</li>
<li><strong>Data caching</strong>: Cache responses to avoid repeated requests</li>
<li><strong>Upgrade plan</strong>: Consider upgrading to higher tier plan</li>
</ol>
<h2 id="websocket-disconnections"><a class="header" href="#websocket-disconnections">WebSocket Disconnections</a></h2>
<h3 id="connection-drops"><a class="header" href="#connection-drops">Connection Drops</a></h3>
<p><strong>Problem</strong>: WebSocket connections frequently disconnect.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Keepalive</strong>: Implement ping/pong keepalive mechanism</li>
<li><strong>Reconnection logic</strong>: Automatic reconnection with exponential backoff</li>
<li><strong>Connection monitoring</strong>: Monitor connection health</li>
<li><strong>Network stability</strong>: Check network connection stability</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024">// WebSocket reconnection example
async fn maintain_websocket_connection(mut ws: WebSocket) -&gt; Result&lt;()&gt; {
    let mut reconnect_attempts = 0;
    const MAX_RECONNECT_ATTEMPTS: u32 = 5;
    
    loop {
        match ws.next().await {
            Some(Ok(message)) =&gt; {
                // Handle message
                reconnect_attempts = 0; // Reset on successful message
            }
            Some(Err(e)) =&gt; {
                log::error!("WebSocket error: {}", e);
                if reconnect_attempts &lt; MAX_RECONNECT_ATTEMPTS {
                    let delay = Duration::from_secs(2_u64.pow(reconnect_attempts));
                    tokio::time::sleep(delay).await;
                    ws = reconnect_websocket().await?;
                    reconnect_attempts += 1;
                } else {
                    return Err(e.into());
                }
            }
            None =&gt; {
                // Connection closed
                break;
            }
        }
    }
    Ok(())
}</code></pre></pre>
<h3 id="authentication-timeout"><a class="header" href="#authentication-timeout">Authentication Timeout</a></h3>
<p><strong>Problem</strong>: WebSocket authentication times out.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Token validation</strong>: Ensure tokens are valid before connecting</li>
<li><strong>Authentication timing</strong>: Send auth message immediately after connection</li>
<li><strong>Connection timeout</strong>: Increase authentication timeout</li>
<li><strong>Session management</strong>: Maintain valid session tokens</li>
</ol>
<h3 id="message-processing-delays"><a class="header" href="#message-processing-delays">Message Processing Delays</a></h3>
<p><strong>Problem</strong>: WebSocket messages arrive with delays or out of order.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Message buffering</strong>: Implement proper message buffering</li>
<li><strong>Sequence numbers</strong>: Use sequence numbers for message ordering</li>
<li><strong>Timestamp validation</strong>: Validate message timestamps</li>
<li><strong>Processing optimization</strong>: Optimize message processing speed</li>
</ol>
<h2 id="environment-configuration-problems"><a class="header" href="#environment-configuration-problems">Environment Configuration Problems</a></h2>
<h3 id="missing-environment-variables"><a class="header" href="#missing-environment-variables">Missing Environment Variables</a></h3>
<p><strong>Problem</strong>: Application fails to start due to missing configuration.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Environment file</strong>: Create <code>.env</code> file with required variables</li>
<li><strong>Variable validation</strong>: Check all required variables at startup</li>
<li><strong>Default values</strong>: Provide sensible defaults where possible</li>
<li><strong>Configuration templates</strong>: Use configuration templates</li>
</ol>
<pre><code class="language-bash"># Required environment variables
AXIOM_EMAIL=your_email@example.com
AXIOM_PASSWORD=your_password
INBOX_LV_EMAIL=your_email@inbox.lv
INBOX_LV_PASSWORD=your_imap_password
RUST_LOG=info
</code></pre>
<h3 id="incorrect-api-endpoints"><a class="header" href="#incorrect-api-endpoints">Incorrect API Endpoints</a></h3>
<p><strong>Problem</strong>: API calls fail due to wrong endpoint URLs.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Environment configuration</strong>: Use environment variables for endpoints</li>
<li><strong>Endpoint validation</strong>: Validate endpoints at startup</li>
<li><strong>Version compatibility</strong>: Ensure using correct API version</li>
<li><strong>Documentation reference</strong>: Check latest API documentation</li>
</ol>
<h3 id="permission-issues"><a class="header" href="#permission-issues">Permission Issues</a></h3>
<p><strong>Problem</strong>: File system permission errors.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>File permissions</strong>: Set correct permissions for config files</li>
<li><strong>Directory access</strong>: Ensure application has access to required directories</li>
<li><strong>User privileges</strong>: Run with appropriate user privileges</li>
<li><strong>Security contexts</strong>: Configure security contexts properly</li>
</ol>
<h3 id="configuration-file-issues"><a class="header" href="#configuration-file-issues">Configuration File Issues</a></h3>
<p><strong>Problem</strong>: Configuration files not loading or parsing errors.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>File format</strong>: Verify correct TOML/JSON/YAML format</li>
<li><strong>File location</strong>: Check configuration file paths</li>
<li><strong>Encoding</strong>: Ensure files are UTF-8 encoded</li>
<li><strong>Syntax validation</strong>: Validate configuration syntax</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configuration validation example
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
struct Config {
    #[serde(default = "default_timeout")]
    timeout: u64,
    #[serde(default = "default_retries")]
    max_retries: u32,
    api_endpoint: String,
}

fn default_timeout() -&gt; u64 { 30 }
fn default_retries() -&gt; u32 { 3 }

impl Config {
    fn validate(&amp;self) -&gt; Result&lt;(), ConfigError&gt; {
        if self.api_endpoint.is_empty() {
            return Err(ConfigError::MissingApiEndpoint);
        }
        if self.timeout == 0 {
            return Err(ConfigError::InvalidTimeout);
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="general-troubleshooting-tips"><a class="header" href="#general-troubleshooting-tips">General Troubleshooting Tips</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<p>Set the <code>RUST_LOG</code> environment variable to get detailed logs:</p>
<pre><code class="language-bash">export RUST_LOG=debug
# or for specific modules
export RUST_LOG=axiomtrade_rs=debug,reqwest=info
</code></pre>
<h3 id="check-system-requirements"><a class="header" href="#check-system-requirements">Check System Requirements</a></h3>
<p>Ensure your system meets the minimum requirements:</p>
<ul>
<li>Rust 1.70 or higher</li>
<li>OpenSSL development libraries</li>
<li>Stable internet connection</li>
<li>Sufficient disk space for logs and cache</li>
</ul>
<h3 id="update-dependencies"><a class="header" href="#update-dependencies">Update Dependencies</a></h3>
<p>Keep dependencies updated to the latest compatible versions:</p>
<pre><code class="language-bash">cargo update
cargo audit
</code></pre>
<h3 id="monitor-resource-usage"><a class="header" href="#monitor-resource-usage">Monitor Resource Usage</a></h3>
<p>Monitor system resources during operation:</p>
<ul>
<li>Memory usage</li>
<li>CPU utilization</li>
<li>Network bandwidth</li>
<li>Disk I/O</li>
</ul>
<h3 id="contact-support"><a class="header" href="#contact-support">Contact Support</a></h3>
<p>If issues persist after following this guide:</p>
<ol>
<li>Collect relevant logs with debug level enabled</li>
<li>Document exact error messages and reproduction steps</li>
<li>Include system information and version details</li>
<li>Contact support through official channels</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-guide"><a class="header" href="#debugging-guide">Debugging Guide</a></h1>
<p>This guide provides comprehensive debugging techniques for axiomtrade-rs, covering logging configuration, network inspection, WebSocket debugging, and common error pattern identification.</p>
<h2 id="enable-debug-logging-1"><a class="header" href="#enable-debug-logging-1">Enable Debug Logging</a></h2>
<h3 id="basic-logging-setup"><a class="header" href="#basic-logging-setup">Basic Logging Setup</a></h3>
<p>The axiomtrade-rs library uses the <code>tracing</code> crate for structured logging. To enable debug logging in your application:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use tracing::{info, debug, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "axiomtrade_rs=debug,info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

fn main() {
    init_logging();
    // Your application code here
}</code></pre></pre>
<h3 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h3>
<p>Configure different log levels for different components:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Maximum verbosity - shows all internal operations
tracing_subscriber::EnvFilter::new("axiomtrade_rs=trace,debug")

// Standard debugging - shows important operations and errors
tracing_subscriber::EnvFilter::new("axiomtrade_rs=debug,info")

// Production logging - errors and warnings only
tracing_subscriber::EnvFilter::new("axiomtrade_rs=warn,error")
<span class="boring">}</span></code></pre></pre>
<h3 id="structured-logging-1"><a class="header" href="#structured-logging-1">Structured Logging</a></h3>
<p>Use structured logging to capture context:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, error, Span, span, Level};

let span = span!(Level::INFO, "trading_operation", 
    operation = "buy", 
    token = "SOL", 
    amount = 1.0
);
let _enter = span.enter();

info!("Starting trade execution");
// Trading logic here
<span class="boring">}</span></code></pre></pre>
<h2 id="using-rust_log-environment-variable"><a class="header" href="#using-rust_log-environment-variable">Using RUST_LOG Environment Variable</a></h2>
<h3 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h3>
<p>Set the <code>RUST_LOG</code> environment variable to control logging verbosity:</p>
<pre><code class="language-bash"># Windows Command Prompt
set RUST_LOG=axiomtrade_rs=debug
cargo run --example trading_demo

# Windows PowerShell
$env:RUST_LOG="axiomtrade_rs=debug"
cargo run --example trading_demo

# Linux/macOS
export RUST_LOG=axiomtrade_rs=debug
cargo run --example trading_demo
</code></pre>
<h3 id="advanced-rust_log-patterns"><a class="header" href="#advanced-rust_log-patterns">Advanced RUST_LOG Patterns</a></h3>
<pre><code class="language-bash"># Enable debug logging for all modules
RUST_LOG=debug

# Enable specific module logging
RUST_LOG=axiomtrade_rs::auth=debug,axiomtrade_rs::websocket=trace

# Enable reqwest HTTP client debugging
RUST_LOG=axiomtrade_rs=debug,reqwest=debug,hyper=debug

# Filter by specific operations
RUST_LOG=axiomtrade_rs::trading=debug,axiomtrade_rs::portfolio=info

# Exclude noisy modules
RUST_LOG=debug,h2=off,rustls=off
</code></pre>
<h3 id="environment-specific-configurations"><a class="header" href="#environment-specific-configurations">Environment-Specific Configurations</a></h3>
<p>Create different logging configurations for different environments:</p>
<pre><code class="language-bash"># Development
RUST_LOG=axiomtrade_rs=debug,reqwest=debug

# Testing
RUST_LOG=axiomtrade_rs=trace,test

# Production
RUST_LOG=axiomtrade_rs=warn,error
</code></pre>
<h2 id="inspecting-network-requests"><a class="header" href="#inspecting-network-requests">Inspecting Network Requests</a></h2>
<h3 id="http-request-debugging"><a class="header" href="#http-request-debugging">HTTP Request Debugging</a></h3>
<p>Enable detailed HTTP request/response logging:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Client;
use tracing::{debug, info};

// In your client configuration
let client = Client::builder()
    .connection_verbose(true)  // Enable connection debugging
    .build()?;

// Log requests manually
debug!(
    method = %request.method(),
    url = %request.url(),
    headers = ?request.headers(),
    "Sending HTTP request"
);

let response = client.execute(request).await?;

debug!(
    status = %response.status(),
    headers = ?response.headers(),
    "Received HTTP response"
);
<span class="boring">}</span></code></pre></pre>
<h3 id="requestresponse-interception"><a class="header" href="#requestresponse-interception">Request/Response Interception</a></h3>
<p>Create a middleware to log all API calls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::{Request, Response};
use tracing::{debug, error};

pub async fn log_request_response(
    request: Request,
    client: &amp;Client,
) -&gt; Result&lt;Response, reqwest::Error&gt; {
    let url = request.url().clone();
    let method = request.method().clone();
    
    debug!(
        method = %method,
        url = %url,
        "Sending request to Axiom API"
    );
    
    let start_time = std::time::Instant::now();
    let response = client.execute(request).await;
    let duration = start_time.elapsed();
    
    match &amp;response {
        Ok(resp) =&gt; {
            debug!(
                status = %resp.status(),
                duration_ms = duration.as_millis(),
                "Received response from Axiom API"
            );
        }
        Err(e) =&gt; {
            error!(
                error = %e,
                duration_ms = duration.as_millis(),
                "Request failed"
            );
        }
    }
    
    response
}
<span class="boring">}</span></code></pre></pre>
<h3 id="capture-full-requestresponse-bodies"><a class="header" href="#capture-full-requestresponse-bodies">Capture Full Request/Response Bodies</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::debug;

// For debugging authentication issues
let body = response.text().await?;
debug!(
    response_body = %body,
    "Full response body received"
);

// For request body debugging
let request_body = serde_json::to_string(&amp;payload)?;
debug!(
    request_body = %request_body,
    "Sending request body"
);
<span class="boring">}</span></code></pre></pre>
<h3 id="network-level-debugging"><a class="header" href="#network-level-debugging">Network-Level Debugging</a></h3>
<p>For deeper network inspection, use external tools:</p>
<pre><code class="language-bash"># Using curl to replicate requests
curl -X POST "https://api.axiom.trade/auth/login" \
     -H "Content-Type: application/json" \
     -H "User-Agent: axiomtrade-rs/1.0.0" \
     -d '{"email":"user@example.com","password_hash":"..."}' \
     -v

# Using tcpdump to capture network traffic (Linux/macOS)
sudo tcpdump -i any -A -s 0 host api.axiom.trade

# Using Wireshark for GUI network analysis
# Filter: host api.axiom.trade
</code></pre>
<h2 id="debugging-websocket-connections"><a class="header" href="#debugging-websocket-connections">Debugging WebSocket Connections</a></h2>
<h3 id="websocket-connection-logging"><a class="header" href="#websocket-connection-logging">WebSocket Connection Logging</a></h3>
<p>Enable comprehensive WebSocket debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{debug, info, warn, error};
use tokio_tungstenite::{connect_async, tungstenite::Message};

async fn debug_websocket_connection(url: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    info!(url = %url, "Attempting WebSocket connection");
    
    let (ws_stream, response) = connect_async(url).await
        .map_err(|e| {
            error!(error = %e, "WebSocket connection failed");
            e
        })?;
    
    info!(
        status = response.status().as_u16(),
        "WebSocket handshake completed"
    );
    
    let (mut write, mut read) = ws_stream.split();
    
    // Log all incoming messages
    while let Some(message) = read.next().await {
        match message {
            Ok(Message::Text(text)) =&gt; {
                debug!(message = %text, "Received WebSocket text message");
            }
            Ok(Message::Binary(data)) =&gt; {
                debug!(
                    size = data.len(),
                    "Received WebSocket binary message"
                );
            }
            Ok(Message::Close(frame)) =&gt; {
                info!(frame = ?frame, "WebSocket connection closed");
                break;
            }
            Err(e) =&gt; {
                error!(error = %e, "WebSocket message error");
                break;
            }
            _ =&gt; {}
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-message-tracing"><a class="header" href="#websocket-message-tracing">WebSocket Message Tracing</a></h3>
<p>Track message flow and timing:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use tracing::{debug, span, Level};

pub struct WebSocketMessageTracer {
    sent_messages: HashMap&lt;String, Instant&gt;,
}

impl WebSocketMessageTracer {
    pub fn track_sent_message(&amp;mut self, message_id: &amp;str) {
        let span = span!(Level::DEBUG, "ws_message_sent", message_id = message_id);
        let _enter = span.enter();
        
        self.sent_messages.insert(message_id.to_string(), Instant::now());
        debug!(message_id = message_id, "WebSocket message sent");
    }
    
    pub fn track_received_response(&amp;mut self, message_id: &amp;str) {
        if let Some(sent_time) = self.sent_messages.remove(message_id) {
            let duration = sent_time.elapsed();
            debug!(
                message_id = message_id,
                response_time_ms = duration.as_millis(),
                "WebSocket response received"
            );
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-state-monitoring"><a class="header" href="#connection-state-monitoring">Connection State Monitoring</a></h3>
<p>Monitor WebSocket connection health:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use tokio::time::{interval, timeout};

pub struct ConnectionMonitor {
    last_message: Instant,
    ping_interval: Duration,
}

impl ConnectionMonitor {
    pub fn new() -&gt; Self {
        Self {
            last_message: Instant::now(),
            ping_interval: Duration::from_secs(30),
        }
    }
    
    pub async fn monitor_connection(&amp;mut self, ws_sender: &amp;mut SplitSink&lt;WebSocketStream&lt;MaybeTlsStream&lt;TcpStream&gt;&gt;, Message&gt;) {
        let mut ping_timer = interval(self.ping_interval);
        
        loop {
            ping_timer.tick().await;
            
            if self.last_message.elapsed() &gt; Duration::from_secs(60) {
                warn!("No messages received for 60 seconds, sending ping");
                
                if let Err(e) = ws_sender.send(Message::Ping(vec![])).await {
                    error!(error = %e, "Failed to send ping");
                    break;
                }
            }
        }
    }
    
    pub fn update_last_message_time(&amp;mut self) {
        self.last_message = Instant::now();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-debugging-tools"><a class="header" href="#websocket-debugging-tools">WebSocket Debugging Tools</a></h3>
<p>External tools for WebSocket debugging:</p>
<pre><code class="language-bash"># Using websocat to test WebSocket connections
websocat wss://ws.axiom.trade/v1/stream -v

# Using wscat (Node.js)
npm install -g wscat
wscat -c wss://ws.axiom.trade/v1/stream

# Browser WebSocket debugging
# Open Chrome DevTools → Network → WS tab
# Shows all WebSocket frames and timing
</code></pre>
<h2 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common Error Patterns</a></h2>
<h3 id="authentication-errors-1"><a class="header" href="#authentication-errors-1">Authentication Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Invalid credentials
match error {
    AxiomError::AuthenticationFailed { message } =&gt; {
        error!(
            error_type = "authentication_failed",
            message = %message,
            "Check email/password combination"
        );
        // Check: email format, password hashing, OTP requirements
    }
    AxiomError::TokenExpired =&gt; {
        warn!("Access token expired, attempting refresh");
        // Implement automatic token refresh
    }
    AxiomError::InvalidOtp =&gt; {
        error!("OTP verification failed");
        // Check: OTP format, timing, auto-fetcher configuration
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting-issues"><a class="header" href="#rate-limiting-issues">Rate Limiting Issues</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Rate limit exceeded
match error {
    AxiomError::RateLimitExceeded { retry_after } =&gt; {
        warn!(
            retry_after_seconds = retry_after,
            "Rate limit exceeded, backing off"
        );
        tokio::time::sleep(Duration::from_secs(retry_after as u64)).await;
        // Implement exponential backoff
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-connectivity-problems"><a class="header" href="#network-connectivity-problems">Network Connectivity Problems</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Network timeouts and connection issues
match error {
    AxiomError::NetworkError { source } =&gt; {
        error!(error = %source, "Network connectivity issue");
        // Check: internet connection, DNS resolution, firewall
    }
    AxiomError::TimeoutError =&gt; {
        warn!("Request timeout, retrying with longer timeout");
        // Increase timeout values or implement retry logic
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-connection-issues"><a class="header" href="#websocket-connection-issues">WebSocket Connection Issues</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: WebSocket disconnections
match ws_error {
    AxiomError::WebSocketConnectionLost =&gt; {
        warn!("WebSocket connection lost, attempting reconnection");
        // Implement automatic reconnection with exponential backoff
    }
    AxiomError::WebSocketAuthenticationFailed =&gt; {
        error!("WebSocket authentication failed");
        // Check: token validity, subscription format
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="api-response-parsing-errors"><a class="header" href="#api-response-parsing-errors">API Response Parsing Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Malformed API responses
match error {
    AxiomError::ParseError { response, source } =&gt; {
        error!(
            response_body = %response,
            parse_error = %source,
            "Failed to parse API response"
        );
        // Check: API version compatibility, response format changes
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trading-operation-errors"><a class="header" href="#trading-operation-errors">Trading Operation Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Trading execution failures
match error {
    AxiomError::InsufficientBalance { required, available } =&gt; {
        error!(
            required_amount = %required,
            available_amount = %available,
            "Insufficient balance for trade"
        );
    }
    AxiomError::InvalidTokenAddress { address } =&gt; {
        error!(
            token_address = %address,
            "Invalid or unsupported token address"
        );
    }
    AxiomError::SlippageExceeded { expected, actual } =&gt; {
        warn!(
            expected_slippage = %expected,
            actual_slippage = %actual,
            "Trade slippage exceeded tolerance"
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debugging-strategies"><a class="header" href="#debugging-strategies">Debugging Strategies</a></h3>
<ol>
<li><strong>Start with Basic Logging</strong>: Enable <code>RUST_LOG=debug</code> to see general operation flow</li>
<li><strong>Isolate Components</strong>: Test authentication, WebSocket, and trading separately</li>
<li><strong>Check Network Layer</strong>: Use external tools to verify API endpoints</li>
<li><strong>Monitor Resource Usage</strong>: Check memory and CPU usage during operations</li>
<li><strong>Test with Minimal Examples</strong>: Create simple reproduction cases</li>
<li><strong>Compare with Python Implementation</strong>: Use the <code>oldstuff/axiompy</code> reference</li>
</ol>
<h3 id="performance-debugging"><a class="header" href="#performance-debugging">Performance Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use tracing::{debug, warn};

// Measure operation performance
let start = Instant::now();
let result = some_expensive_operation().await;
let duration = start.elapsed();

if duration &gt; Duration::from_millis(1000) {
    warn!(
        operation = "expensive_operation",
        duration_ms = duration.as_millis(),
        "Slow operation detected"
    );
} else {
    debug!(
        operation = "expensive_operation",
        duration_ms = duration.as_millis(),
        "Operation completed"
    );
}
<span class="boring">}</span></code></pre></pre>
<p>This debugging guide provides comprehensive tools and techniques for troubleshooting issues in axiomtrade-rs. Use these patterns to identify and resolve problems efficiently during development and production use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>This section covers the most common questions and issues encountered when using axiomtrade-rs.</p>
<h2 id="authentication--otp"><a class="header" href="#authentication--otp">Authentication &amp; OTP</a></h2>
<h3 id="how-to-handle-otp-timeouts"><a class="header" href="#how-to-handle-otp-timeouts">How to handle OTP timeouts?</a></h3>
<p><strong>Q: My OTP codes are expiring before I can use them. What should I do?</strong></p>
<p>OTP codes from Axiom Trade typically expire within 5 minutes. Here are solutions:</p>
<ol>
<li>
<p><strong>Enable automatic OTP fetching</strong> (recommended):</p>
<pre><code class="language-bash"># Set up inbox.lv credentials
export INBOX_LV_EMAIL="your_username@inbox.lv"
export INBOX_LV_PASSWORD="your_special_imap_password"
</code></pre>
</li>
<li>
<p><strong>Reduce manual entry time</strong>:</p>
<ul>
<li>Have your email client open and ready</li>
<li>Use email forwarding to a fast email provider</li>
<li>Consider using a mobile app for quicker access</li>
</ul>
</li>
<li>
<p><strong>Request new OTP if expired</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The client will automatically request a new OTP if the previous one expired
let result = client.login_with_credentials("username", "password").await;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Configure timeout settings</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = EnhancedAxiomClient::new()
    .with_otp_timeout(Duration::from_secs(300)) // 5 minutes
    .build();
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="why-are-my-tokens-expiring"><a class="header" href="#why-are-my-tokens-expiring">Why are my tokens expiring?</a></h3>
<p><strong>Q: I keep getting authentication errors even though I just logged in.</strong></p>
<p>Token expiration can occur for several reasons:</p>
<ol>
<li>
<p><strong>Access tokens expire quickly</strong> (typically 1 hour):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable automatic token refresh
let client = EnhancedAxiomClient::new()
    .with_auto_refresh(true)
    .build();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Server-side session invalidation</strong>:</p>
<ul>
<li>Multiple logins from different locations</li>
<li>Security policy changes</li>
<li>Server maintenance</li>
</ul>
</li>
<li>
<p><strong>Clock synchronization issues</strong>:</p>
<pre><code class="language-bash"># Ensure system time is synchronized
ntpdate -s pool.ntp.org  # Linux/macOS
w32tm /resync            # Windows
</code></pre>
</li>
<li>
<p><strong>Check token status</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if client.is_token_expired().await {
    client.refresh_token().await?;
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="rate-limiting--performance"><a class="header" href="#rate-limiting--performance">Rate Limiting &amp; Performance</a></h2>
<h3 id="how-to-increase-rate-limits"><a class="header" href="#how-to-increase-rate-limits">How to increase rate limits?</a></h3>
<p><strong>Q: I'm getting rate limited. How can I handle more requests?</strong></p>
<p>Rate limiting is enforced by Axiom Trade's servers. Here's how to optimize:</p>
<ol>
<li>
<p><strong>Use built-in rate limiting</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = EnhancedAxiomClient::new()
    .with_rate_limit(10, Duration::from_secs(1)) // 10 requests per second
    .build();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Implement exponential backoff</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let retry_config = RetryConfig::new()
    .with_max_attempts(3)
    .with_exponential_backoff(Duration::from_millis(100));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Batch operations when possible</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of individual balance calls
let balances = client.get_batch_balances(&amp;wallet_addresses).await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use WebSocket for real-time data</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reduces HTTP request load
let ws_client = client.create_websocket_connection().await?;
ws_client.subscribe_to_price_updates().await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Contact Axiom Trade for increased limits</strong>:</p>
<ul>
<li>Premium accounts may have higher rate limits</li>
<li>Business partnerships can provide dedicated endpoints</li>
</ul>
</li>
</ol>
<h2 id="websocket-issues"><a class="header" href="#websocket-issues">WebSocket Issues</a></h2>
<h3 id="websocket-reconnection-strategies"><a class="header" href="#websocket-reconnection-strategies">WebSocket reconnection strategies</a></h3>
<p><strong>Q: My WebSocket connections keep dropping. How do I handle reconnections?</strong></p>
<p>WebSocket connections can be unstable due to network issues or server maintenance:</p>
<ol>
<li>
<p><strong>Enable automatic reconnection</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ws_client = client
    .websocket()
    .with_auto_reconnect(true)
    .with_ping_interval(Duration::from_secs(30))
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Implement custom reconnection logic</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_websocket_connection() -&gt; Result&lt;(), AxiomError&gt; {
    let mut retry_count = 0;
    const MAX_RETRIES: u32 = 5;
    
    loop {
        match client.connect_websocket().await {
            Ok(ws) =&gt; {
                retry_count = 0; // Reset on successful connection
                handle_messages(ws).await?;
            }
            Err(e) if retry_count &lt; MAX_RETRIES =&gt; {
                retry_count += 1;
                let delay = Duration::from_secs(2_u64.pow(retry_count));
                tokio::time::sleep(delay).await;
            }
            Err(e) =&gt; return Err(e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Monitor connection health</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ws_client.on_disconnect(|reason| {
    log::warn!("WebSocket disconnected: {}", reason);
    // Trigger reconnection
});
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Handle message queuing during disconnection</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (tx, rx) = tokio::sync::mpsc::channel(1000);
// Queue messages when disconnected
// Replay when reconnected
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="platform-specific-issues"><a class="header" href="#platform-specific-issues">Platform-Specific Issues</a></h2>
<h3 id="windows-specific-problems"><a class="header" href="#windows-specific-problems">Windows-specific problems</a></h3>
<p><strong>Q: I'm having issues on Windows. What should I check?</strong></p>
<ol>
<li>
<p><strong>TLS/SSL certificate issues</strong>:</p>
<pre><code class="language-toml"># In Cargo.toml, ensure native-tls feature
[dependencies]
reqwest = { version = "0.11", features = ["native-tls"] }
</code></pre>
</li>
<li>
<p><strong>Firewall and antivirus</strong>:</p>
<ul>
<li>Add axiomtrade-rs to firewall exceptions</li>
<li>Whitelist in antivirus software</li>
<li>Check Windows Defender settings</li>
</ul>
</li>
<li>
<p><strong>Path and environment variables</strong>:</p>
<pre><code class="language-cmd"># Use double quotes for paths with spaces
set AXIOM_CONFIG_PATH="C:\Users\Username\My Documents\axiom"
</code></pre>
</li>
<li>
<p><strong>Line ending issues</strong>:</p>
<pre><code class="language-bash">git config core.autocrlf true
</code></pre>
</li>
</ol>
<h3 id="macos-specific-problems"><a class="header" href="#macos-specific-problems">macOS-specific problems</a></h3>
<p><strong>Q: Having trouble on macOS. Any known issues?</strong></p>
<ol>
<li>
<p><strong>Keychain access for credentials</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use keychain-rs for secure credential storage
use keychain::Keychain;
let keychain = Keychain::new();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Certificate validation</strong>:</p>
<pre><code class="language-bash"># Update certificates
brew install ca-certificates
</code></pre>
</li>
<li>
<p><strong>Permission issues</strong>:</p>
<pre><code class="language-bash"># Ensure proper permissions
sudo chown -R $(whoami) ~/.axiom
</code></pre>
</li>
</ol>
<h3 id="linux-specific-problems"><a class="header" href="#linux-specific-problems">Linux-specific problems</a></h3>
<p><strong>Q: Issues running on Linux distributions. What to check?</strong></p>
<ol>
<li>
<p><strong>Missing dependencies</strong>:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install pkg-config libssl-dev

# CentOS/RHEL
sudo yum install openssl-devel

# Arch Linux
sudo pacman -S openssl pkg-config
</code></pre>
</li>
<li>
<p><strong>glibc version compatibility</strong>:</p>
<pre><code class="language-bash"># Check glibc version
ldd --version
# May need to compile with older glibc target
</code></pre>
</li>
<li>
<p><strong>SELinux or AppArmor restrictions</strong>:</p>
<pre><code class="language-bash"># Check SELinux status
sestatus
# Configure policies if needed
</code></pre>
</li>
</ol>
<h2 id="environment--configuration"><a class="header" href="#environment--configuration">Environment &amp; Configuration</a></h2>
<h3 id="environment-setup-issues"><a class="header" href="#environment-setup-issues">Environment setup issues</a></h3>
<p><strong>Q: My environment variables aren't being loaded correctly.</strong></p>
<ol>
<li>
<p><strong>Verify .env file location</strong>:</p>
<pre><code class="language-bash"># Should be in project root or specify path
AXIOM_CONFIG_PATH=/path/to/config/.env
</code></pre>
</li>
<li>
<p><strong>Check .env file format</strong>:</p>
<pre><code class="language-bash"># Correct format (no spaces around =)
AXIOM_API_KEY=your_key_here
INBOX_LV_EMAIL=user@inbox.lv

# Incorrect format
AXIOM_API_KEY = your_key_here  # Spaces cause issues
</code></pre>
</li>
<li>
<p><strong>Environment variable precedence</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Order of precedence:
// 1. System environment variables
// 2. .env file in current directory
// 3. .env file in project root
// 4. Default values
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Permission issues</strong>:</p>
<pre><code class="language-bash">chmod 600 .env  # Secure permissions
</code></pre>
</li>
</ol>
<h2 id="trading--portfolio"><a class="header" href="#trading--portfolio">Trading &amp; Portfolio</a></h2>
<h3 id="portfolio-balance-discrepancies"><a class="header" href="#portfolio-balance-discrepancies">Portfolio balance discrepancies</a></h3>
<p><strong>Q: The balance I see doesn't match what's in my wallet.</strong></p>
<ol>
<li>
<p><strong>Check for pending transactions</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let portfolio = client.get_portfolio_with_pending().await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Network synchronization delays</strong>:</p>
<ul>
<li>Solana transactions can take 30-60 seconds to confirm</li>
<li>Check transaction status on Solana explorer</li>
</ul>
</li>
<li>
<p><strong>Multiple token account addresses</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get all token accounts for a wallet
let token_accounts = client.get_token_accounts(&amp;wallet_address).await?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Cache invalidation</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Force refresh from blockchain
let fresh_balance = client.get_balance_fresh(&amp;wallet_address).await?;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="trading-execution-failures"><a class="header" href="#trading-execution-failures">Trading execution failures</a></h3>
<p><strong>Q: My trades are failing to execute. What could be wrong?</strong></p>
<ol>
<li>
<p><strong>Insufficient balance or slippage</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trade_params = TradeParams {
    slippage_tolerance: 0.05, // 5% slippage tolerance
    max_gas_fee: Some(0.01),  // Maximum gas fee in SOL
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Network congestion</strong>:</p>
<ul>
<li>Increase gas fees during high congestion</li>
<li>Use priority fee estimation</li>
</ul>
</li>
<li>
<p><strong>Market conditions</strong>:</p>
<ul>
<li>High volatility periods</li>
<li>Low liquidity for specific tokens</li>
</ul>
</li>
<li>
<p><strong>Wallet connectivity</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify wallet connection
let wallet_status = client.check_wallet_connection(&amp;wallet_address).await?;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="debugging--diagnostics"><a class="header" href="#debugging--diagnostics">Debugging &amp; Diagnostics</a></h2>
<h3 id="enable-debug-logging-2"><a class="header" href="#enable-debug-logging-2">Enable debug logging</a></h3>
<p><strong>Q: How do I get more detailed error information?</strong></p>
<ol>
<li>
<p><strong>Set logging level</strong>:</p>
<pre><code class="language-bash">export RUST_LOG=axiomtrade_rs=debug,reqwest=debug
</code></pre>
</li>
<li>
<p><strong>Custom logging configuration</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing_subscriber;

tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .init();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Network request logging</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = EnhancedAxiomClient::new()
    .with_debug_requests(true)
    .build();
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="performance-profiling"><a class="header" href="#performance-profiling">Performance profiling</a></h3>
<p><strong>Q: My application is running slowly. How do I identify bottlenecks?</strong></p>
<ol>
<li>
<p><strong>Enable performance metrics</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = EnhancedAxiomClient::new()
    .with_metrics(true)
    .build();

// Get performance statistics
let stats = client.get_performance_stats().await;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use async profiling tools</strong>:</p>
<pre><code class="language-bash">cargo install tokio-console
# Run with console subscriber
</code></pre>
</li>
<li>
<p><strong>Monitor resource usage</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check memory usage
let memory_usage = client.get_memory_usage();

// Check connection pool status
let pool_stats = client.get_connection_pool_stats();
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<h3 id="community-support"><a class="header" href="#community-support">Community support</a></h3>
<ul>
<li><strong>GitHub Issues</strong>: Report bugs and feature requests</li>
<li><strong>Discord</strong>: Join the Axiom Trade community for real-time help</li>
<li><strong>Documentation</strong>: Check the latest docs for API changes</li>
</ul>
<h3 id="professional-support"><a class="header" href="#professional-support">Professional support</a></h3>
<p>For business-critical applications:</p>
<ul>
<li>Contact Axiom Trade directly for premium support</li>
<li>Consider professional services for custom integrations</li>
<li>Enterprise SLA options available for high-volume traders</li>
</ul>
<h3 id="contributing"><a class="header" href="#contributing">Contributing</a></h3>
<p>Found a bug or have a feature request?</p>
<ol>
<li>Check existing GitHub issues</li>
<li>Create a detailed issue with reproduction steps</li>
<li>Consider submitting a pull request with fixes</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<p>This document provides a comprehensive reference for all configuration options available in the axiomtrade-rs library.</p>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<h3 id="authentication-configuration"><a class="header" href="#authentication-configuration">Authentication Configuration</a></h3>
<h4 id="required-variables"><a class="header" href="#required-variables">Required Variables</a></h4>
<ul>
<li><strong><code>AXIOM_EMAIL</code></strong> - Your Axiom Trade account email address</li>
<li><strong><code>AXIOM_PASSWORD</code></strong> - Your Axiom Trade account password (will be hashed automatically)</li>
</ul>
<h4 id="optional-otp-automation"><a class="header" href="#optional-otp-automation">Optional OTP Automation</a></h4>
<p>For automated OTP fetching via IMAP:</p>
<ul>
<li><strong><code>INBOX_LV_EMAIL</code></strong> - Your inbox.lv email address (e.g., <code>username@inbox.lv</code>)</li>
<li><strong><code>INBOX_LV_PASSWORD</code></strong> - Your inbox.lv IMAP password (not your web login password)</li>
</ul>
<p><strong>Note</strong>: The OTP automation requires setting up email forwarding from your Axiom Trade account to your inbox.lv address. See the <a href="reference/../automatic-otp.html">Automatic OTP Guide</a> for detailed setup instructions.</p>
<h3 id="turnkey-integration-1"><a class="header" href="#turnkey-integration-1">Turnkey Integration</a></h3>
<p>Optional variables for Turnkey wallet integration:</p>
<ul>
<li><strong><code>TURNKEY_ORGANIZATION_ID</code></strong> - Your Turnkey organization ID</li>
<li><strong><code>TURNKEY_USER_ID</code></strong> - Your Turnkey user ID</li>
<li><strong><code>TURNKEY_CLIENT_SECRET</code></strong> - Your Turnkey client secret</li>
</ul>
<h3 id="token-storage-1"><a class="header" href="#token-storage-1">Token Storage</a></h3>
<ul>
<li><strong><code>AXIOM_TOKEN_FILE</code></strong> - Path to store authentication tokens (default: <code>.axiom_tokens.json</code>)</li>
</ul>
<h3 id="logging-configuration"><a class="header" href="#logging-configuration">Logging Configuration</a></h3>
<ul>
<li><strong><code>RUST_LOG</code></strong> - Logging level configuration (e.g., <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>)</li>
</ul>
<h2 id="api-endpoints"><a class="header" href="#api-endpoints">API Endpoints</a></h2>
<p>The library uses multiple API endpoints for redundancy and load balancing:</p>
<h3 id="primary-endpoints"><a class="header" href="#primary-endpoints">Primary Endpoints</a></h3>
<pre><code>https://api2.axiom.trade
https://api3.axiom.trade
https://api6.axiom.trade
https://api7.axiom.trade
https://api8.axiom.trade
https://api9.axiom.trade
https://api10.axiom.trade
</code></pre>
<h3 id="endpoint-selection"><a class="header" href="#endpoint-selection">Endpoint Selection</a></h3>
<ul>
<li>The client automatically selects endpoints randomly for load distribution</li>
<li>Failed endpoints are automatically excluded from subsequent requests</li>
<li>No manual endpoint configuration is required</li>
</ul>
<h3 id="websocket-endpoints"><a class="header" href="#websocket-endpoints">WebSocket Endpoints</a></h3>
<h4 id="market-data-websocket-regions"><a class="header" href="#market-data-websocket-regions">Market Data WebSocket Regions</a></h4>
<ul>
<li><strong>US West</strong>: <code>socket8.axiom.trade</code>, <code>cluster-usw2.axiom.trade</code></li>
<li><strong>US Central</strong>: <code>cluster3.axiom.trade</code>, <code>cluster-usc2.axiom.trade</code></li>
<li><strong>US East</strong>: <code>cluster5.axiom.trade</code>, <code>cluster-use2.axiom.trade</code></li>
<li><strong>EU West</strong>: <code>cluster6.axiom.trade</code>, <code>cluster-euw2.axiom.trade</code></li>
<li><strong>EU Central</strong>: <code>cluster2.axiom.trade</code>, <code>cluster-euc2.axiom.trade</code></li>
<li><strong>EU East</strong>: <code>cluster8.axiom.trade</code></li>
<li><strong>Asia</strong>: <code>cluster4.axiom.trade</code></li>
<li><strong>Australia</strong>: <code>cluster7.axiom.trade</code></li>
<li><strong>Global</strong>: <code>cluster9.axiom.trade</code></li>
</ul>
<h4 id="token-price-websocket-1"><a class="header" href="#token-price-websocket-1">Token Price WebSocket</a></h4>
<ul>
<li><strong>Primary</strong>: <code>socket8.axiom.trade</code></li>
</ul>
<h2 id="timeout-settings"><a class="header" href="#timeout-settings">Timeout Settings</a></h2>
<h3 id="http-client-timeouts"><a class="header" href="#http-client-timeouts">HTTP Client Timeouts</a></h3>
<ul>
<li><strong>Request Timeout</strong>: 30 seconds (authentication requests)</li>
<li><strong>Infrastructure Health Check</strong>: 5 seconds</li>
<li><strong>Turnkey API Requests</strong>: 5 seconds</li>
</ul>
<h3 id="websocket-timeouts"><a class="header" href="#websocket-timeouts">WebSocket Timeouts</a></h3>
<ul>
<li><strong>Connection Timeout</strong>: 30 seconds</li>
<li><strong>Token Refresh Interval</strong>: 600 seconds (10 minutes)</li>
<li><strong>Reconnection Delay</strong>: 1 second</li>
</ul>
<h3 id="otp-fetching-timeouts"><a class="header" href="#otp-fetching-timeouts">OTP Fetching Timeouts</a></h3>
<ul>
<li><strong>Default OTP Wait</strong>: 120 seconds</li>
<li><strong>Email Check Interval</strong>: 5 seconds</li>
</ul>
<h3 id="custom-timeout-configuration"><a class="header" href="#custom-timeout-configuration">Custom Timeout Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::client::enhanced_client::EnhancedClient;
use std::time::Duration;

// Create client with custom timeout
let mut client = EnhancedClient::builder()
    .with_timeout(Duration::from_secs(60))
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="retry-configuration"><a class="header" href="#retry-configuration">Retry Configuration</a></h2>
<h3 id="default-retry-settings"><a class="header" href="#default-retry-settings">Default Retry Settings</a></h3>
<ul>
<li><strong>Maximum Retries</strong>: 3 attempts</li>
<li><strong>Initial Delay</strong>: 100 milliseconds</li>
<li><strong>Maximum Delay</strong>: 30 seconds</li>
<li><strong>Backoff Strategy</strong>: Exponential with jitter</li>
</ul>
<h3 id="retry-conditions"><a class="header" href="#retry-conditions">Retry Conditions</a></h3>
<p>The following errors trigger automatic retries:</p>
<ul>
<li>Network timeouts</li>
<li>Connection errors</li>
<li>HTTP 5xx status codes</li>
<li>Rate limit errors (429)</li>
<li>Temporary authentication failures</li>
</ul>
<h3 id="custom-retry-configuration"><a class="header" href="#custom-retry-configuration">Custom Retry Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::retry::RetryConfig;
use std::time::Duration;

let retry_config = RetryConfig::builder()
    .with_max_attempts(5)
    .with_initial_delay(Duration::from_millis(200))
    .with_max_delay(Duration::from_secs(60))
    .build();
<span class="boring">}</span></code></pre></pre>
<h2 id="rate-limiting-configuration"><a class="header" href="#rate-limiting-configuration">Rate Limiting Configuration</a></h2>
<h3 id="global-rate-limits"><a class="header" href="#global-rate-limits">Global Rate Limits</a></h3>
<ul>
<li><strong>Default</strong>: 300 requests per 60 seconds</li>
<li><strong>Sliding Window</strong>: 60-second window</li>
<li><strong>Per-Endpoint</strong>: Individual rate limiters can be configured</li>
</ul>
<h3 id="rate-limiting-implementation"><a class="header" href="#rate-limiting-implementation">Rate Limiting Implementation</a></h3>
<p>The library uses a token bucket algorithm with the following characteristics:</p>
<ul>
<li><strong>Token Refill Rate</strong>: Configurable tokens per second</li>
<li><strong>Bucket Size</strong>: Maximum burst capacity</li>
<li><strong>Automatic Backoff</strong>: Waits when rate limit is exceeded</li>
</ul>
<h3 id="custom-rate-limiting"><a class="header" href="#custom-rate-limiting">Custom Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::rate_limiter::RateLimiter;
use std::time::Duration;

// Create custom rate limiter: 100 requests per minute
let rate_limiter = RateLimiter::new(100, Duration::from_secs(60));

// Or use bucket rate limiter
use axiomtrade_rs::utils::rate_limiter::BucketRateLimiter;
let bucket_limiter = BucketRateLimiter::new(100.0, 10.0); // 100 tokens, 10/sec refill
<span class="boring">}</span></code></pre></pre>
<h3 id="endpoint-specific-rate-limits"><a class="header" href="#endpoint-specific-rate-limits">Endpoint-Specific Rate Limits</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::rate_limiter::EndpointRateLimiter;

let endpoint_limiter = EndpointRateLimiter::new();

// Add specific limits for trading endpoints
endpoint_limiter.add_endpoint_limit(
    "/trade/buy".to_string(),
    10,
    Duration::from_secs(60)
).await;
<span class="boring">}</span></code></pre></pre>
<h2 id="websocket-parameters"><a class="header" href="#websocket-parameters">WebSocket Parameters</a></h2>
<h3 id="connection-parameters"><a class="header" href="#connection-parameters">Connection Parameters</a></h3>
<ul>
<li><strong>Protocol</strong>: WSS (WebSocket Secure)</li>
<li><strong>Headers</strong>: Authentication cookies, origin validation</li>
<li><strong>Reconnection</strong>: Automatic on token expiry</li>
<li><strong>Heartbeat</strong>: Automatic ping/pong handling</li>
</ul>
<h3 id="subscription-types-1"><a class="header" href="#subscription-types-1">Subscription Types</a></h3>
<ul>
<li><strong>Market Data</strong>: New token pairs (<code>new_pairs</code> room)</li>
<li><strong>Price Alerts</strong>: Token-specific price updates</li>
<li><strong>Portfolio</strong>: Wallet transaction monitoring</li>
<li><strong>Trading</strong>: Order status updates</li>
</ul>
<h3 id="websocket-configuration"><a class="header" href="#websocket-configuration">WebSocket Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::websocket::client::{WebSocketClient, Region};

// Create client with specific region
let client = WebSocketClient::with_region(handler, Region::USWest)?;

// Configure auto-reconnect
client.set_auto_reconnect(true);
<span class="boring">}</span></code></pre></pre>
<h3 id="message-format"><a class="header" href="#message-format">Message Format</a></h3>
<p>WebSocket messages follow this general structure:</p>
<pre><code class="language-json">{
  "action": "join|leave",
  "room": "room_name",
  "data": { /* optional payload */ }
}
</code></pre>
<h2 id="password-hashing-configuration"><a class="header" href="#password-hashing-configuration">Password Hashing Configuration</a></h2>
<h3 id="pbkdf2-parameters"><a class="header" href="#pbkdf2-parameters">PBKDF2 Parameters</a></h3>
<ul>
<li><strong>Algorithm</strong>: SHA256</li>
<li><strong>Iterations</strong>: 600,000</li>
<li><strong>Salt Length</strong>: 32 bytes (random)</li>
<li><strong>Output Length</strong>: 32 bytes</li>
<li><strong>Encoding</strong>: Base64</li>
</ul>
<h3 id="security-settings"><a class="header" href="#security-settings">Security Settings</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::password::hashpassword;

// Hash a password (uses secure defaults)
let hashed = hashpassword("your_password");
<span class="boring">}</span></code></pre></pre>
<h2 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h2>
<h3 id="certificate-validation"><a class="header" href="#certificate-validation">Certificate Validation</a></h3>
<ul>
<li><strong>Certificate Verification</strong>: Enabled by default</li>
<li><strong>Protocol</strong>: TLS 1.2 minimum</li>
<li><strong>Cipher Suites</strong>: Modern secure ciphers only</li>
</ul>
<h3 id="custom-tls-configuration"><a class="header" href="#custom-tls-configuration">Custom TLS Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::ClientBuilder;

let client = ClientBuilder::new()
    .min_tls_version(reqwest::tls::Version::TLS_1_2)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-configuration"><a class="header" href="#error-handling-configuration">Error Handling Configuration</a></h2>
<h3 id="error-categories"><a class="header" href="#error-categories">Error Categories</a></h3>
<ul>
<li><strong>Authentication Errors</strong>: Login, token management</li>
<li><strong>Network Errors</strong>: Timeouts, connection failures</li>
<li><strong>API Errors</strong>: Invalid requests, rate limits</li>
<li><strong>Parsing Errors</strong>: JSON deserialization issues</li>
</ul>
<h3 id="error-retry-logic"><a class="header" href="#error-retry-logic">Error Retry Logic</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::errors::AxiomError;

match error {
    AxiomError::NetworkError(_) =&gt; {
        // Automatically retried
    },
    AxiomError::AuthenticationError(_) =&gt; {
        // Token refresh attempted
    },
    AxiomError::RateLimitError(_) =&gt; {
        // Automatic backoff applied
    },
    _ =&gt; {
        // Manual handling required
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h2>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<ul>
<li><strong>Keep-Alive</strong>: Enabled by default</li>
<li><strong>Pool Size</strong>: Automatically managed</li>
<li><strong>Connection Reuse</strong>: Aggressive reuse for efficiency</li>
</ul>
<h3 id="memory-management-4"><a class="header" href="#memory-management-4">Memory Management</a></h3>
<ul>
<li><strong>Token Caching</strong>: In-memory with file persistence</li>
<li><strong>Response Buffering</strong>: Streamed for large responses</li>
<li><strong>JSON Parsing</strong>: Zero-copy where possible</li>
</ul>
<h3 id="optimization-settings"><a class="header" href="#optimization-settings">Optimization Settings</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::client::enhanced_client::EnhancedClient;

let client = EnhancedClient::builder()
    .with_max_requests_per_minute(500)  // Higher rate limit
    .with_connection_pool_size(20)      // More concurrent connections
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="security-configuration"><a class="header" href="#security-configuration">Security Configuration</a></h2>
<h3 id="api-security"><a class="header" href="#api-security">API Security</a></h3>
<ul>
<li><strong>Request Signing</strong>: Automatic where required</li>
<li><strong>Token Rotation</strong>: Automatic refresh</li>
<li><strong>Secure Storage</strong>: OS keychain integration (planned)</li>
</ul>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<ul>
<li><strong>Parameter Sanitization</strong>: Automatic</li>
<li><strong>SQL Injection Prevention</strong>: Not applicable (REST API)</li>
<li><strong>XSS Prevention</strong>: JSON-only communication</li>
</ul>
<h3 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h3>
<p>Configure audit logging for security compliance:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error};

// Enable security event logging
info!("Authentication successful for user: {}", email);
warn!("Rate limit exceeded for endpoint: {}", endpoint);
error!("Authentication failed: {}", error);
<span class="boring">}</span></code></pre></pre>
<h2 id="example-configuration-file"><a class="header" href="#example-configuration-file">Example Configuration File</a></h2>
<p>Create a <code>.env</code> file in your project root:</p>
<pre><code class="language-env"># Required authentication
AXIOM_EMAIL=your-email@example.com
AXIOM_PASSWORD=your-secure-password

# Optional OTP automation
INBOX_LV_EMAIL=username@inbox.lv
INBOX_LV_PASSWORD=your-imap-password

# Optional Turnkey integration
TURNKEY_ORGANIZATION_ID=your-org-id
TURNKEY_USER_ID=your-user-id
TURNKEY_CLIENT_SECRET=your-client-secret

# Optional token storage path
AXIOM_TOKEN_FILE=./tokens/axiom_tokens.json

# Logging configuration
RUST_LOG=axiomtrade_rs=info,reqwest=warn
</code></pre>
<h2 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced Configuration</a></h2>
<h3 id="custom-http-headers"><a class="header" href="#custom-http-headers">Custom HTTP Headers</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::header::{HeaderMap, HeaderValue};

let mut headers = HeaderMap::new();
headers.insert("X-Custom-Header", HeaderValue::from_static("value"));

let client = ClientBuilder::new()
    .default_headers(headers)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="proxy-configuration"><a class="header" href="#proxy-configuration">Proxy Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = ClientBuilder::new()
    .proxy(reqwest::Proxy::http("http://proxy:8080")?)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-user-agents"><a class="header" href="#custom-user-agents">Custom User Agents</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axiomtrade_rs::utils::user_agents::get_random_desktop_user_agent;

let user_agent = get_random_desktop_user_agent();
let client = AuthClient::new_with_user_agent(&amp;user_agent)?;
<span class="boring">}</span></code></pre></pre>
<p>This configuration reference covers all the major configuration options available in the axiomtrade-rs library. For specific implementation examples, refer to the examples in the <a href="reference/../examples/">Examples</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-codes-reference"><a class="header" href="#error-codes-reference">Error Codes Reference</a></h1>
<p>This document provides a comprehensive reference for all error types, HTTP status codes, and error handling patterns in the Axiom Trade Rust SDK. Use this reference for debugging and implementing robust error handling in your applications.</p>
<h2 id="error-type-hierarchy-1"><a class="header" href="#error-type-hierarchy-1">Error Type Hierarchy</a></h2>
<h3 id="core-error-types-1"><a class="header" href="#core-error-types-1">Core Error Types</a></h3>
<h4 id="axiomerror-primary-error-type"><a class="header" href="#axiomerror-primary-error-type"><code>AxiomError</code> (Primary Error Type)</a></h4>
<p>The main error type that encompasses all possible errors in the SDK.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AxiomError {
    Auth(AuthError),                    // Authentication-related errors
    Network(reqwest::Error),            // HTTP network errors
    Serialization(serde_json::Error),   // JSON serialization/deserialization
    Io(std::io::Error),                 // File system I/O errors
    Api { message: String },            // General API errors
    InvalidResponse,                    // Malformed API responses
    RateLimit,                          // Rate limiting exceeded
    ServiceUnavailable,                 // Service temporarily unavailable
    Timeout,                            // Request timeout
    Config(String),                     // Configuration errors
    WebSocket(String),                  // WebSocket connection errors
    Hyperliquid(String),                // Hyperliquid API errors
    Infrastructure(String),             // Infrastructure health check failures
    Social(String),                     // Social API errors
    Notifications(String),              // Notifications system errors
    Crypto { message: String },         // Cryptographic operation errors
    Authentication { message: String }, // Authentication state errors
    Unknown(String),                    // Catch-all for unexpected errors
}
<span class="boring">}</span></code></pre></pre>
<h4 id="autherror-authentication-errors"><a class="header" href="#autherror-authentication-errors"><code>AuthError</code> (Authentication Errors)</a></h4>
<p>Specific to authentication operations including login, OTP, and token management.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AuthError {
    NetworkError(reqwest::Error),       // Network failures during auth
    InvalidCredentials,                 // Wrong email/password
    OtpRequired,                        // OTP verification needed
    InvalidOtp,                         // Incorrect OTP code
    TokenExpired,                       // Access token has expired
    TokenNotFound,                      // Token missing from storage
    SerializationError(serde_json::Error), // Token serialization issues
    IoError(std::io::Error),            // Token file I/O errors
    EmailError(String),                 // Email OTP fetching errors
    ApiError { message: String },       // API-specific auth errors
    Unauthorized,                       // HTTP 401 - invalid token
    NotAuthenticated,                   // No valid authentication present
}
<span class="boring">}</span></code></pre></pre>
<h4 id="module-specific-error-types"><a class="header" href="#module-specific-error-types">Module-Specific Error Types</a></h4>
<p><strong>Trading Errors (<code>TradingError</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TradingError {
    AuthError(AuthError),               // Authentication failures
    NetworkError(reqwest::Error),       // Network issues
    InvalidTokenMint(String),           // Invalid token address
    InsufficientBalance(String),        // Not enough funds
    SlippageExceeded(String),           // Price slippage too high
    TransactionFailed(String),          // Transaction execution failed
    ApiError(String),                   // General API errors
    ParsingError(String),               // Response parsing errors
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Market Data Errors (<code>MarketDataError</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MarketDataError {
    AuthError(AuthError),               // Authentication failures
    NetworkError(reqwest::Error),       // Network issues
    InvalidTokenMint(String),           // Invalid token address
    TokenNotFound(String),              // Token doesn't exist
    ApiError(String),                   // General API errors
    ParsingError(String),               // Response parsing errors
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Portfolio Errors (<code>PortfolioError</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum PortfolioError {
    AuthError(AuthError),               // Authentication failures
    NetworkError(reqwest::Error),       // Network issues
    InvalidWalletAddress(String),       // Invalid Solana address
    ApiError(String),                   // General API errors
    ParsingError(String),               // Response parsing errors
}
<span class="boring">}</span></code></pre></pre>
<h2 id="http-status-codes"><a class="header" href="#http-status-codes">HTTP Status Codes</a></h2>
<h3 id="success-codes-2xx"><a class="header" href="#success-codes-2xx">Success Codes (2xx)</a></h3>
<ul>
<li><strong>200 OK</strong>: Request successful, response contains data</li>
<li><strong>201 Created</strong>: Resource created successfully (orders, subscriptions)</li>
<li><strong>204 No Content</strong>: Request successful, no response body</li>
</ul>
<h3 id="client-error-codes-4xx"><a class="header" href="#client-error-codes-4xx">Client Error Codes (4xx)</a></h3>
<h4 id="400-bad-request"><a class="header" href="#400-bad-request"><strong>400 Bad Request</strong></a></h4>
<p>Invalid request parameters or malformed data.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Invalid token mint addresses</li>
<li>Malformed wallet addresses</li>
<li>Missing required parameters</li>
<li>Invalid parameter types or ranges</li>
</ul>
<p><strong>Example Response:</strong></p>
<pre><code class="language-json">{
  "error": "Invalid token mint address",
  "code": 400,
  "details": "Token mint must be a valid Solana address"
}
</code></pre>
<p><strong>Handling Pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatusCode::BAD_REQUEST =&gt; {
    let error_text = response.text().await?;
    Err(TradingError::ApiError(format!("Bad request: {}", error_text)))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="401-unauthorized"><a class="header" href="#401-unauthorized"><strong>401 Unauthorized</strong></a></h4>
<p>Authentication token missing, expired, or invalid.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Access token expired</li>
<li>Invalid access token</li>
<li>Missing Authorization header</li>
<li>Revoked token</li>
</ul>
<p><strong>Example Response:</strong></p>
<pre><code class="language-json">{
  "error": "Token expired",
  "code": 401,
  "message": "Access token has expired. Please refresh or re-authenticate."
}
</code></pre>
<p><strong>Handling Pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatusCode::UNAUTHORIZED =&gt; {
    Err(TradingError::AuthError(AuthError::Unauthorized))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="403-forbidden"><a class="header" href="#403-forbidden"><strong>403 Forbidden</strong></a></h4>
<p>Valid authentication but insufficient permissions.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Account suspended</li>
<li>Feature not enabled for account</li>
<li>Trading limits exceeded</li>
<li>Geographic restrictions</li>
</ul>
<h4 id="404-not-found"><a class="header" href="#404-not-found"><strong>404 Not Found</strong></a></h4>
<p>Requested resource doesn't exist.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Invalid token mint address</li>
<li>Non-existent wallet address</li>
<li>Deleted or unavailable endpoint</li>
</ul>
<p><strong>Example Handling:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatusCode::NOT_FOUND =&gt; {
    Err(MarketDataError::TokenNotFound(token_symbol.to_string()))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="429-too-many-requests"><a class="header" href="#429-too-many-requests"><strong>429 Too Many Requests</strong></a></h4>
<p>Rate limit exceeded.</p>
<p><strong>Response Headers:</strong></p>
<ul>
<li><code>Retry-After</code>: Seconds to wait before retrying</li>
<li><code>X-RateLimit-Limit</code>: Maximum requests per window</li>
<li><code>X-RateLimit-Remaining</code>: Remaining requests in current window</li>
<li><code>X-RateLimit-Reset</code>: Timestamp when limit resets</li>
</ul>
<p><strong>Handling Pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Retryable status codes include 429
matches!(status.as_u16(), 429 | 500 | 502 | 503 | 504)
<span class="boring">}</span></code></pre></pre>
<h3 id="server-error-codes-5xx"><a class="header" href="#server-error-codes-5xx">Server Error Codes (5xx)</a></h3>
<h4 id="500-internal-server-error"><a class="header" href="#500-internal-server-error"><strong>500 Internal Server Error</strong></a></h4>
<p>Unexpected server-side error.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Database connectivity issues</li>
<li>Internal service failures</li>
<li>Unhandled exceptions</li>
</ul>
<h4 id="502-bad-gateway"><a class="header" href="#502-bad-gateway"><strong>502 Bad Gateway</strong></a></h4>
<p>Upstream service unavailable.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Solana RPC node failures</li>
<li>Third-party API timeouts</li>
<li>Load balancer issues</li>
</ul>
<h4 id="503-service-unavailable"><a class="header" href="#503-service-unavailable"><strong>503 Service Unavailable</strong></a></h4>
<p>Service temporarily overloaded or under maintenance.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Scheduled maintenance</li>
<li>High traffic overload</li>
<li>Infrastructure scaling</li>
</ul>
<h4 id="504-gateway-timeout"><a class="header" href="#504-gateway-timeout"><strong>504 Gateway Timeout</strong></a></h4>
<p>Request timeout to upstream services.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Solana network congestion</li>
<li>Slow blockchain confirmations</li>
<li>Database query timeouts</li>
</ul>
<h2 id="api-specific-error-codes"><a class="header" href="#api-specific-error-codes">API-Specific Error Codes</a></h2>
<h3 id="authentication-api-errors"><a class="header" href="#authentication-api-errors">Authentication API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>AUTH_001</code></td><td><code>InvalidCredentials</code></td><td>Wrong email or password</td><td>Re-enter credentials</td></tr>
<tr><td><code>AUTH_002</code></td><td><code>OtpRequired</code></td><td>OTP verification needed</td><td>Provide OTP code</td></tr>
<tr><td><code>AUTH_003</code></td><td><code>InvalidOtp</code></td><td>Incorrect OTP code</td><td>Re-enter correct OTP</td></tr>
<tr><td><code>AUTH_004</code></td><td><code>TokenExpired</code></td><td>Access token expired</td><td>Refresh token or re-login</td></tr>
<tr><td><code>AUTH_005</code></td><td><code>TokenNotFound</code></td><td>No stored tokens</td><td>Perform fresh login</td></tr>
<tr><td><code>AUTH_006</code></td><td><code>EmailError</code></td><td>OTP email fetch failed</td><td>Check email configuration</td></tr>
</tbody></table>
</div>
<h3 id="trading-api-errors"><a class="header" href="#trading-api-errors">Trading API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>TRADE_001</code></td><td><code>InvalidTokenMint</code></td><td>Invalid token address</td><td>Verify token mint address</td></tr>
<tr><td><code>TRADE_002</code></td><td><code>InsufficientBalance</code></td><td>Not enough funds</td><td>Add funds or reduce amount</td></tr>
<tr><td><code>TRADE_003</code></td><td><code>SlippageExceeded</code></td><td>Price moved too much</td><td>Increase slippage tolerance</td></tr>
<tr><td><code>TRADE_004</code></td><td><code>TransactionFailed</code></td><td>Blockchain transaction failed</td><td>Check network status, retry</td></tr>
<tr><td><code>TRADE_005</code></td><td><code>InvalidAmount</code></td><td>Amount outside valid range</td><td>Check min/max trading limits</td></tr>
</tbody></table>
</div>
<h3 id="market-data-api-errors"><a class="header" href="#market-data-api-errors">Market Data API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>MARKET_001</code></td><td><code>TokenNotFound</code></td><td>Token doesn't exist</td><td>Verify token address/symbol</td></tr>
<tr><td><code>MARKET_002</code></td><td><code>InvalidTokenMint</code></td><td>Malformed token address</td><td>Use valid Solana address</td></tr>
<tr><td><code>MARKET_003</code></td><td><code>DataUnavailable</code></td><td>Price data not available</td><td>Try different token or wait</td></tr>
</tbody></table>
</div>
<h3 id="portfolio-api-errors"><a class="header" href="#portfolio-api-errors">Portfolio API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>PORTFOLIO_001</code></td><td><code>InvalidWalletAddress</code></td><td>Invalid Solana address</td><td>Use valid wallet address</td></tr>
<tr><td><code>PORTFOLIO_002</code></td><td><code>WalletNotFound</code></td><td>Wallet has no activity</td><td>Verify address or check different wallet</td></tr>
</tbody></table>
</div>
<h2 id="error-message-formats"><a class="header" href="#error-message-formats">Error Message Formats</a></h2>
<h3 id="standard-error-response"><a class="header" href="#standard-error-response">Standard Error Response</a></h3>
<pre><code class="language-json">{
  "error": "Human-readable error message",
  "code": "ERROR_CODE",
  "details": "Additional context or debugging information",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_123456789"
}
</code></pre>
<h3 id="validation-error-response"><a class="header" href="#validation-error-response">Validation Error Response</a></h3>
<pre><code class="language-json">{
  "error": "Validation failed",
  "code": "VALIDATION_ERROR",
  "field_errors": {
    "token_mint": ["Invalid Solana address format"],
    "amount": ["Must be greater than 0.001"]
  }
}
</code></pre>
<h3 id="rate-limit-error-response"><a class="header" href="#rate-limit-error-response">Rate Limit Error Response</a></h3>
<pre><code class="language-json">{
  "error": "Rate limit exceeded",
  "code": "RATE_LIMIT_EXCEEDED",
  "retry_after": 60,
  "limit": 100,
  "remaining": 0,
  "reset_time": "2024-01-15T10:31:00Z"
}
</code></pre>
<h2 id="common-error-scenarios-and-solutions"><a class="header" href="#common-error-scenarios-and-solutions">Common Error Scenarios and Solutions</a></h2>
<h3 id="authentication-issues"><a class="header" href="#authentication-issues">Authentication Issues</a></h3>
<p><strong>Scenario: Login fails with invalid credentials</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match auth_client.login(&amp;email, &amp;password, None).await {
    Err(AxiomError::Auth(AuthError::InvalidCredentials)) =&gt; {
        println!("Invalid email or password. Please check your credentials.");
        // Guide user to re-enter credentials or password reset
    }
    Err(e) =&gt; println!("Login failed: {}", e),
    Ok(tokens) =&gt; println!("Login successful!"),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Scenario: OTP required but auto-fetch fails</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match auth_client.login(&amp;email, &amp;password, None).await {
    Err(AxiomError::Auth(AuthError::EmailError(msg))) =&gt; {
        println!("OTP auto-fetch failed: {}", msg);
        println!("Please configure inbox.lv integration or enter OTP manually");
        // Fall back to manual OTP entry
    }
    Ok(tokens) =&gt; println!("Login successful with auto-OTP!"),
    Err(e) =&gt; println!("Login failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trading-issues"><a class="header" href="#trading-issues">Trading Issues</a></h3>
<p><strong>Scenario: Insufficient balance for trade</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match trading_client.buy_token(token_mint, amount, slippage).await {
    Err(AxiomError::Trading(TradingError::InsufficientBalance(msg))) =&gt; {
        println!("Insufficient balance: {}", msg);
        // Show current balance and suggest funding wallet
        let balance = portfolio_client.get_balance(&amp;wallet_address).await?;
        println!("Current SOL balance: {:.6}", balance.sol_balance);
        println!("Add more SOL to your wallet to complete this trade");
    }
    Ok(response) =&gt; println!("Trade successful: {}", response.transaction_signature),
    Err(e) =&gt; println!("Trade failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Scenario: Slippage exceeded during volatile market</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match trading_client.buy_token(token_mint, amount, Some(1.0)).await {
    Err(AxiomError::Trading(TradingError::SlippageExceeded(msg))) =&gt; {
        println!("Slippage exceeded: {}", msg);
        println!("Market is volatile. Try:");
        println!("1. Increase slippage tolerance to 2-5%");
        println!("2. Reduce trade amount");
        println!("3. Wait for market to stabilize");
        
        // Retry with higher slippage
        let retry_result = trading_client.buy_token(token_mint, amount, Some(3.0)).await;
        match retry_result {
            Ok(response) =&gt; println!("Retry successful with higher slippage"),
            Err(e) =&gt; println!("Retry also failed: {}", e),
        }
    }
    Ok(response) =&gt; println!("Trade successful"),
    Err(e) =&gt; println!("Trade failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-and-rate-limiting-issues"><a class="header" href="#network-and-rate-limiting-issues">Network and Rate Limiting Issues</a></h3>
<p><strong>Scenario: Rate limit exceeded</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match market_client.get_trending_tokens().await {
    Err(AxiomError::RateLimit) =&gt; {
        println!("Rate limit exceeded. Waiting before retry...");
        tokio::time::sleep(Duration::from_secs(60)).await;
        
        // Retry the request
        match market_client.get_trending_tokens().await {
            Ok(tokens) =&gt; println!("Retry successful"),
            Err(e) =&gt; println!("Retry failed: {}", e),
        }
    }
    Ok(tokens) =&gt; println!("Found {} trending tokens", tokens.len()),
    Err(e) =&gt; println!("Request failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-connection-issues-1"><a class="header" href="#websocket-connection-issues-1">WebSocket Connection Issues</a></h3>
<p><strong>Scenario: WebSocket disconnection with reconnection</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MessageHandler for MyHandler {
    async fn on_disconnected(&amp;self, reason: String) {
        println!("WebSocket disconnected: {}", reason);
        
        // Implement exponential backoff for reconnection
        let mut backoff = Duration::from_secs(1);
        let max_backoff = Duration::from_secs(60);
        
        loop {
            tokio::time::sleep(backoff).await;
            
            match self.ws_client.reconnect().await {
                Ok(()) =&gt; {
                    println!("Reconnection successful");
                    break;
                }
                Err(e) =&gt; {
                    println!("Reconnection failed: {}", e);
                    backoff = std::cmp::min(backoff * 2, max_backoff);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-best-practices-2"><a class="header" href="#error-handling-best-practices-2">Error Handling Best Practices</a></h2>
<h3 id="1-use-result-types-consistently"><a class="header" href="#1-use-result-types-consistently">1. Use Result Types Consistently</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Explicit error handling
pub async fn get_portfolio(&amp;self) -&gt; Result&lt;Portfolio, AxiomError&gt; {
    match self.make_request().await {
        Ok(response) =&gt; Ok(response.json().await?),
        Err(e) =&gt; Err(AxiomError::Network(e)),
    }
}

// Avoid: Panicking on errors
pub async fn get_portfolio_bad(&amp;self) -&gt; Portfolio {
    self.make_request().await.unwrap().json().await.unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-implement-retry-logic-for-transient-errors"><a class="header" href="#2-implement-retry-logic-for-transient-errors">2. Implement Retry Logic for Transient Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::utils::retry::{RetryConfig, retry_with_backoff};

let config = RetryConfig {
    max_attempts: 3,
    initial_delay: Duration::from_millis(500),
    max_delay: Duration::from_secs(10),
    backoff_multiplier: 2.0,
};

let result = retry_with_backoff(config, || async {
    market_client.get_trending_tokens().await
}).await;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-provide-context-in-error-messages"><a class="header" href="#3-provide-context-in-error-messages">3. Provide Context in Error Messages</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Contextual error messages
match trading_client.buy_token(mint, amount, slippage).await {
    Err(e) =&gt; return Err(AxiomError::Api {
        message: format!("Failed to buy {} tokens of {}: {}", amount, mint, e)
    }),
    Ok(response) =&gt; response,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-handle-authentication-errors-gracefully"><a class="header" href="#4-handle-authentication-errors-gracefully">4. Handle Authentication Errors Gracefully</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_auth_error(error: AuthError) -&gt; Result&lt;(), AxiomError&gt; {
    match error {
        AuthError::TokenExpired =&gt; {
            println!("Token expired, attempting refresh...");
            // Attempt token refresh
            let token_manager = TokenManager::new(None);
            token_manager.refresh_token().await?;
            Ok(())
        }
        AuthError::Unauthorized =&gt; {
            println!("Authentication invalid, please log in again");
            // Clear stored tokens and prompt for re-authentication
            let token_manager = TokenManager::new(None);
            token_manager.clear_tokens().await?;
            Err(AxiomError::Authentication {
                message: "Re-authentication required".to_string()
            })
        }
        _ =&gt; Err(AxiomError::Auth(error)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-validate-input-parameters-early"><a class="header" href="#5-validate-input-parameters-early">5. Validate Input Parameters Early</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_token_mint(mint: &amp;str) -&gt; Result&lt;(), AxiomError&gt; {
    if mint.is_empty() {
        return Err(AxiomError::Api {
            message: "Token mint cannot be empty".to_string(),
        });
    }
    
    if mint.len() &lt; 32 || mint.len() &gt; 44 {
        return Err(AxiomError::Api {
            message: format!("Invalid mint address length: {}", mint),
        });
    }
    
    if !mint.chars().all(|c| c.is_ascii_alphanumeric()) {
        return Err(AxiomError::Api {
            message: format!("Invalid characters in mint address: {}", mint),
        });
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-use-structured-logging-for-error-tracking"><a class="header" href="#6-use-structured-logging-for-error-tracking">6. Use Structured Logging for Error Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{error, warn, info};

match trading_client.execute_trade(&amp;order).await {
    Ok(result) =&gt; {
        info!(
            transaction_signature = %result.signature,
            amount = %order.amount,
            token = %order.token_mint,
            "Trade executed successfully"
        );
    }
    Err(e) =&gt; {
        error!(
            error = %e,
            order_id = %order.id,
            token = %order.token_mint,
            "Trade execution failed"
        );
        
        // Log additional context for debugging
        warn!(
            user_balance = %current_balance,
            required_amount = %order.amount,
            "Insufficient balance detected"
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-error-scenarios"><a class="header" href="#debugging-error-scenarios">Debugging Error Scenarios</a></h2>
<h3 id="enable-debug-logging-3"><a class="header" href="#enable-debug-logging-3">Enable Debug Logging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your application initialization
use tracing_subscriber;

tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .init();
<span class="boring">}</span></code></pre></pre>
<h3 id="common-debugging-commands"><a class="header" href="#common-debugging-commands">Common Debugging Commands</a></h3>
<pre><code class="language-bash"># Run with debug output
RUST_LOG=debug cargo run --example basic_login

# Run specific test with detailed errors
cargo test test_authentication -- --nocapture

# Check network connectivity
curl -v https://api6.axiom.trade/health
</code></pre>
<h3 id="error-investigation-checklist"><a class="header" href="#error-investigation-checklist">Error Investigation Checklist</a></h3>
<ol>
<li>
<p><strong>Check Network Connectivity</strong></p>
<ul>
<li>Verify internet connection</li>
<li>Test API endpoint accessibility</li>
<li>Check firewall settings</li>
</ul>
</li>
<li>
<p><strong>Validate Authentication</strong></p>
<ul>
<li>Verify credentials are correct</li>
<li>Check token expiration</li>
<li>Confirm OTP configuration</li>
</ul>
</li>
<li>
<p><strong>Review Request Parameters</strong></p>
<ul>
<li>Validate token addresses</li>
<li>Check amount ranges</li>
<li>Verify wallet addresses</li>
</ul>
</li>
<li>
<p><strong>Monitor Rate Limits</strong></p>
<ul>
<li>Check request frequency</li>
<li>Review response headers</li>
<li>Implement backoff strategies</li>
</ul>
</li>
<li>
<p><strong>Examine Server Status</strong></p>
<ul>
<li>Check Axiom Trade status page</li>
<li>Monitor Solana network health</li>
<li>Review infrastructure alerts</li>
</ul>
</li>
</ol>
<p>This reference should help developers quickly identify, understand, and resolve errors when working with the Axiom Trade Rust SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-endpoints-reference"><a class="header" href="#api-endpoints-reference">API Endpoints Reference</a></h1>
<p>This document provides a comprehensive reference of all REST API endpoints and WebSocket connections used by the axiomtrade-rs SDK. The Axiom Trade platform uses multiple redundant API servers for load balancing and high availability.</p>
<h2 id="base-urls-and-load-balancing"><a class="header" href="#base-urls-and-load-balancing">Base URLs and Load Balancing</a></h2>
<h3 id="primary-api-servers"><a class="header" href="#primary-api-servers">Primary API Servers</a></h3>
<pre><code>https://api2.axiom.trade
https://api3.axiom.trade
https://api6.axiom.trade
https://api7.axiom.trade
https://api8.axiom.trade
https://api9.axiom.trade
https://api10.axiom.trade
</code></pre>
<p>The SDK automatically rotates between these endpoints for load balancing and fault tolerance. Authentication and most trading operations work across all servers.</p>
<h3 id="specialized-endpoints"><a class="header" href="#specialized-endpoints">Specialized Endpoints</a></h3>
<ul>
<li><strong>Main Domain</strong>: <code>https://axiom.trade</code> - Used for certain portfolio operations</li>
<li><strong>WebSocket Clusters</strong>: Various regional endpoints for real-time data</li>
<li><strong>External Services</strong>: MEV protection and infrastructure monitoring</li>
</ul>
<h2 id="authentication-endpoints"><a class="header" href="#authentication-endpoints">Authentication Endpoints</a></h2>
<h3 id="login-flow"><a class="header" href="#login-flow">Login Flow</a></h3>
<h4 id="post-login-password-v2"><a class="header" href="#post-login-password-v2">POST <code>/login-password-v2</code></a></h4>
<p><strong>Description</strong>: First step of two-factor authentication process</p>
<p><strong>Authentication</strong>: None required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "email": "user@example.com",
  "b64_password": "base64_encoded_pbkdf2_hash"
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "otp_jwt_token": "jwt_token_for_otp_step"
}
</code></pre>
<p><strong>Rate Limiting</strong>: 5 requests per minute per IP</p>
<hr />
<h4 id="post-login-otp"><a class="header" href="#post-login-otp">POST <code>/login-otp</code></a></h4>
<p><strong>Description</strong>: Second step of authentication using OTP code</p>
<p><strong>Authentication</strong>: Requires <code>auth-otp-login-token</code> cookie from step 1</p>
<p><strong>Headers</strong>:</p>
<pre><code>Cookie: auth-otp-login-token={otp_jwt_token}
</code></pre>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "code": "123456",
  "email": "user@example.com",
  "b64_password": "base64_encoded_pbkdf2_hash"
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "access_token": "jwt_access_token",
  "refresh_token": "jwt_refresh_token",
  "user": {
    "id": "user_id",
    "email": "user@example.com"
  },
  "org_id": "turnkey_organization_id",
  "user_id": "turnkey_user_id",
  "client_secret": "turnkey_client_secret"
}
</code></pre>
<p><strong>Cookies Set</strong>:</p>
<ul>
<li><code>auth-access-token</code>: JWT access token (15 minutes)</li>
<li><code>auth-refresh-token</code>: JWT refresh token (30 days)</li>
</ul>
<hr />
<h4 id="post-refresh-access-token"><a class="header" href="#post-refresh-access-token">POST <code>/refresh-access-token</code></a></h4>
<p><strong>Description</strong>: Refresh expired access token using refresh token</p>
<p><strong>Authentication</strong>: Requires <code>auth-refresh-token</code> cookie</p>
<p><strong>Headers</strong>:</p>
<pre><code>Cookie: auth-refresh-token={refresh_token}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "access_token": "new_jwt_access_token"
}
</code></pre>
<p><strong>Cookies Set</strong>:</p>
<ul>
<li><code>auth-access-token</code>: New JWT access token (15 minutes)</li>
</ul>
<h2 id="trading-endpoints"><a class="header" href="#trading-endpoints">Trading Endpoints</a></h2>
<p>All trading endpoints require authentication via <code>auth-access-token</code> cookie.</p>
<h3 id="post-batched-send-tx-v2"><a class="header" href="#post-batched-send-tx-v2">POST <code>/batched-send-tx-v2</code></a></h3>
<p><strong>Description</strong>: Execute buy, sell, or swap orders</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Headers</strong>:</p>
<pre><code>Cookie: auth-access-token={access_token}
Content-Type: application/json
</code></pre>
<p><strong>Request Body (Buy Order)</strong>:</p>
<pre><code class="language-json">{
  "token_mint": "token_mint_address",
  "amount_sol": 1.5,
  "slippage_percent": 5.0,
  "priority_fee": 5000
}
</code></pre>
<p><strong>Request Body (Sell Order)</strong>:</p>
<pre><code class="language-json">{
  "token_mint": "token_mint_address",
  "amount_tokens": 1000.0,
  "slippage_percent": 5.0,
  "priority_fee": 5000
}
</code></pre>
<p><strong>Request Body (Swap Order)</strong>:</p>
<pre><code class="language-json">{
  "from_mint": "source_token_mint",
  "to_mint": "destination_token_mint",
  "amount": 1000.0,
  "slippage_percent": 5.0,
  "priority_fee": 5000
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "status": "Success",
  "signature": "transaction_signature",
  "transaction_id": "tx_id"
}
</code></pre>
<p><strong>Error Responses</strong>:</p>
<ul>
<li><code>400</code>: Invalid parameters, insufficient balance, slippage exceeded</li>
<li><code>401</code>: Authentication required</li>
<li><code>429</code>: Rate limit exceeded</li>
</ul>
<hr />
<h3 id="post-quote"><a class="header" href="#post-quote">POST <code>/quote</code></a></h3>
<p><strong>Description</strong>: Get pricing quote for token swaps</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "input_mint": "input_token_mint",
  "output_mint": "output_token_mint",
  "amount": 1000.0,
  "slippage_percent": 5.0
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "input_amount": 1000.0,
  "output_amount": 950.0,
  "price_impact": 2.5,
  "estimated_gas": 5000
}
</code></pre>
<hr />
<h3 id="post-simulate"><a class="header" href="#post-simulate">POST <code>/simulate</code></a></h3>
<p><strong>Description</strong>: Simulate transaction before execution</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "transaction": "base64_encoded_transaction"
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "success": true,
  "estimated_gas": 5000,
  "error": null
}
</code></pre>
<h2 id="portfolio-endpoints"><a class="header" href="#portfolio-endpoints">Portfolio Endpoints</a></h2>
<h3 id="post-batched-sol-balance-main-domain-only"><a class="header" href="#post-batched-sol-balance-main-domain-only">POST <code>/batched-sol-balance</code> (Main Domain Only)</a></h3>
<p><strong>Description</strong>: Get SOL and token balances for multiple wallets</p>
<p><strong>Base URL</strong>: <code>https://axiom.trade/api</code> (Main domain only)</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "public_keys": [
    "wallet_address_1",
    "wallet_address_2"
  ]
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "wallet_address_1": {
    "sol_balance": 2.5,
    "tokens": [
      {
        "mint_address": "token_mint",
        "balance": 1000.0,
        "balance_usd": 150.0
      }
    ],
    "total_value_usd": 400.0
  }
}
</code></pre>
<hr />
<h3 id="post-portfolio-v5"><a class="header" href="#post-portfolio-v5">POST <code>/portfolio-v5</code></a></h3>
<p><strong>Description</strong>: Get comprehensive portfolio summary</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "walletAddressRaw": "address1,address2",
  "isOtherWallet": false,
  "totalSolBalance": 5.0,
  "tokenAddressToAmountMap": {},
  "timeOffset": -480
}
</code></pre>
<p><strong>Note</strong>: Wallet addresses must be sorted alphabetically before joining with commas.</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "total_value_usd": 1500.0,
  "pnl_24h": 50.0,
  "positions": []
}
</code></pre>
<h2 id="market-data-endpoints"><a class="header" href="#market-data-endpoints">Market Data Endpoints</a></h2>
<p>Market data endpoints use specialized API servers (typically <code>api6.axiom.trade</code>).</p>
<h3 id="get-meme-trending"><a class="header" href="#get-meme-trending">GET <code>/meme-trending</code></a></h3>
<p><strong>Description</strong>: Get trending meme tokens</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>timePeriod</code>: <code>1h</code>, <code>24h</code>, <code>7d</code>, <code>30d</code></li>
</ul>
<p><strong>Example</strong>: <code>GET /meme-trending?timePeriod=24h</code></p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "tokenAddress": "token_mint_address",
    "tokenTicker": "BONK",
    "tokenName": "Bonk Token",
    "priceUsd": 0.00001,
    "marketCapPercentChange": 15.5,
    "volumeSol": 1000.0,
    "marketCapSol": 50000.0,
    "top10Holders": 25.5,
    "tokenImage": "https://image_url"
  }
]
</code></pre>
<hr />
<h3 id="get-token-analysis-1"><a class="header" href="#get-token-analysis-1">GET <code>/token-analysis</code></a></h3>
<p><strong>Description</strong>: Get detailed token information and creator analysis</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>tokenTicker</code>: Token symbol (e.g., "BONK", "SOL")</li>
</ul>
<p><strong>Example</strong>: <code>GET /token-analysis?tokenTicker=BONK</code></p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "symbol": "BONK",
  "name": "Bonk Token",
  "mint_address": "token_mint_address",
  "price_usd": 0.00001,
  "market_cap": 50000000,
  "volume_24h": 1000000,
  "creator_analysis": {}
}
</code></pre>
<hr />
<h3 id="get-clipboard-pair-info"><a class="header" href="#get-clipboard-pair-info">GET <code>/clipboard-pair-info</code></a></h3>
<p><strong>Description</strong>: Get quick token info by mint or pair address</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>address</code>: Token mint address or pair address</li>
</ul>
<p><strong>Example</strong>: <code>GET /clipboard-pair-info?address={mint_address}</code></p>
<hr />
<h3 id="get-pricetoken_mint"><a class="header" href="#get-pricetoken_mint">GET <code>/price/{token_mint}</code></a></h3>
<p><strong>Description</strong>: Get current price data for a token</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "price_usd": 0.00001,
  "price_sol": 0.000001,
  "price_change_24h": 5.5,
  "volume_24h": 1000.0,
  "timestamp": 1640995200
}
</code></pre>
<hr />
<h3 id="get-price-feedtoken_mint"><a class="header" href="#get-price-feedtoken_mint">GET <code>/price-feed/{token_mint}</code></a></h3>
<p><strong>Description</strong>: Get historical price feed</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>period</code>: <code>1h</code>, <code>24h</code>, <code>7d</code>, <code>30d</code></li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "prices": [
    {
      "timestamp": 1640995200,
      "price_usd": 0.00001,
      "volume": 1000.0
    }
  ]
}
</code></pre>
<hr />
<h3 id="get-charttoken_mint"><a class="header" href="#get-charttoken_mint">GET <code>/chart/{token_mint}</code></a></h3>
<p><strong>Description</strong>: Get chart data with candles</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>timeframe</code>: <code>1m</code>, <code>5m</code>, <code>15m</code>, <code>1h</code>, <code>4h</code>, <code>1d</code>, <code>1w</code></li>
<li><code>limit</code>: Maximum number of candles (optional)</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "candles": [
    {
      "timestamp": 1640995200,
      "open": 0.00001,
      "high": 0.000012,
      "low": 0.000009,
      "close": 0.000011,
      "volume": 1000.0
    }
  ]
}
</code></pre>
<hr />
<h3 id="get-search-v3"><a class="header" href="#get-search-v3">GET <code>/search-v3</code></a></h3>
<p><strong>Description</strong>: Search for tokens by name or symbol</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>searchQuery</code>: Search term (URL encoded)</li>
<li><code>limit</code>: Maximum results (optional)</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "symbol": "BONK",
    "name": "Bonk Token",
    "mint_address": "token_mint_address",
    "price_usd": 0.00001,
    "logo_uri": "https://image_url"
  }
]
</code></pre>
<hr />
<h3 id="post-batch-prices"><a class="header" href="#post-batch-prices">POST <code>/batch-prices</code></a></h3>
<p><strong>Description</strong>: Get batch price data for multiple tokens</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "mints": [
    "token_mint_1",
    "token_mint_2"
  ]
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "mint_address": "token_mint_1",
    "price_usd": 0.00001,
    "price_change_24h": 5.5
  }
]
</code></pre>
<h2 id="social-trading-endpoints"><a class="header" href="#social-trading-endpoints">Social Trading Endpoints</a></h2>
<p>Social features use <code>api8.axiom.trade</code> base URL.</p>
<h3 id="get-tracked-wallets-v2"><a class="header" href="#get-tracked-wallets-v2">GET <code>/tracked-wallets-v2</code></a></h3>
<p><strong>Description</strong>: Get user's tracked wallets</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "address": "wallet_address",
    "name": "Wallet Name",
    "added_at": "2024-01-01T00:00:00Z",
    "performance": {
      "pnl_24h": 150.0,
      "win_rate": 75.5
    }
  }
]
</code></pre>
<hr />
<h3 id="post-tracked-wallets-v2"><a class="header" href="#post-tracked-wallets-v2">POST <code>/tracked-wallets-v2</code></a></h3>
<p><strong>Description</strong>: Add or remove tracked wallets</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body (Add)</strong>:</p>
<pre><code class="language-json">{
  "address": "wallet_address",
  "name": "Optional Name",
  "action": "add"
}
</code></pre>
<p><strong>Request Body (Remove)</strong>:</p>
<pre><code class="language-json">{
  "address": "wallet_address",
  "action": "remove"
}
</code></pre>
<hr />
<h3 id="post-tracked-wallet-transactions-v2"><a class="header" href="#post-tracked-wallet-transactions-v2">POST <code>/tracked-wallet-transactions-v2</code></a></h3>
<p><strong>Description</strong>: Get transactions from tracked wallets</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "wallet_addresses": ["address1", "address2"],
  "limit": 50,
  "offset": 0,
  "time_range": "24h"
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "signature": "tx_signature",
    "wallet_address": "wallet_address",
    "token_mint": "token_mint",
    "action": "buy",
    "amount_sol": 1.0,
    "timestamp": "2024-01-01T00:00:00Z"
  }
]
</code></pre>
<hr />
<h3 id="get-watchlist"><a class="header" href="#get-watchlist">GET <code>/watchlist</code></a></h3>
<p><strong>Description</strong>: Get user's token watchlist</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "token_address": "token_mint",
    "symbol": "BONK",
    "added_at": "2024-01-01T00:00:00Z",
    "current_price": 0.00001
  }
]
</code></pre>
<hr />
<h3 id="post-watchlist"><a class="header" href="#post-watchlist">POST <code>/watchlist</code></a></h3>
<p><strong>Description</strong>: Add or remove tokens from watchlist</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body (Add)</strong>:</p>
<pre><code class="language-json">{
  "tokenAddress": "token_mint",
  "symbol": "BONK",
  "action": "add"
}
</code></pre>
<p><strong>Request Body (Remove)</strong>:</p>
<pre><code class="language-json">{
  "tokenAddress": "token_mint",
  "action": "remove"
}
</code></pre>
<hr />
<h3 id="get-twitter-feed-new-2"><a class="header" href="#get-twitter-feed-new-2">GET <code>/twitter-feed-new-2</code></a></h3>
<p><strong>Description</strong>: Get Twitter/X feed with trading content</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>includeTruthSocial</code>: <code>true</code> or <code>false</code></li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "id": "tweet_id",
    "author": "username",
    "content": "tweet content",
    "timestamp": "2024-01-01T00:00:00Z",
    "mentions": ["$BONK"],
    "engagement": {
      "likes": 100,
      "retweets": 50
    }
  }
]
</code></pre>
<hr />
<h3 id="get-twitter-settings"><a class="header" href="#get-twitter-settings">GET <code>/twitter-settings</code></a></h3>
<p><strong>Description</strong>: Get user's Twitter feed settings</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "enabled": true,
  "keywords": ["solana", "meme"],
  "min_followers": 1000,
  "include_truth_social": false
}
</code></pre>
<h2 id="notifications-endpoints"><a class="header" href="#notifications-endpoints">Notifications Endpoints</a></h2>
<h3 id="get-get-notifications"><a class="header" href="#get-get-notifications">GET <code>/get-notifications</code></a></h3>
<p><strong>Description</strong>: Get user notifications</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "id": "notification_id",
    "type": "price_alert",
    "title": "Price Alert",
    "message": "BONK reached $0.00002",
    "timestamp": "2024-01-01T00:00:00Z",
    "read": false
  }
]
</code></pre>
<hr />
<h3 id="get-get-announcement"><a class="header" href="#get-get-announcement">GET <code>/get-announcement</code></a></h3>
<p><strong>Description</strong>: Get system announcements</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">[
  {
    "id": "announcement_id",
    "title": "System Maintenance",
    "content": "Scheduled maintenance...",
    "timestamp": "2024-01-01T00:00:00Z",
    "priority": "medium"
  }
]
</code></pre>
<hr />
<h3 id="post-notificationsidread"><a class="header" href="#post-notificationsidread">POST <code>/notifications/{id}/read</code></a></h3>
<p><strong>Description</strong>: Mark notification as read</p>
<p><strong>Authentication</strong>: Required</p>
<hr />
<h3 id="post-notificationsread-all"><a class="header" href="#post-notificationsread-all">POST <code>/notifications/read-all</code></a></h3>
<p><strong>Description</strong>: Mark all notifications as read</p>
<p><strong>Authentication</strong>: Required</p>
<hr />
<h3 id="post-alertsprice"><a class="header" href="#post-alertsprice">POST <code>/alerts/price</code></a></h3>
<p><strong>Description</strong>: Create price alert</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "token_address": "token_mint",
  "condition": "above",
  "price": 0.00002,
  "notification_method": "email"
}
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "alertId": "alert_id"
}
</code></pre>
<hr />
<h3 id="delete-alertspricealert_id"><a class="header" href="#delete-alertspricealert_id">DELETE <code>/alerts/price/{alert_id}</code></a></h3>
<p><strong>Description</strong>: Delete price alert</p>
<p><strong>Authentication</strong>: Required</p>
<hr />
<h3 id="post-alertswallet"><a class="header" href="#post-alertswallet">POST <code>/alerts/wallet</code></a></h3>
<p><strong>Description</strong>: Create wallet activity alert</p>
<p><strong>Authentication</strong>: Required</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "wallet_address": "wallet_address",
  "min_amount_sol": 1.0,
  "notification_method": "email"
}
</code></pre>
<hr />
<h3 id="get-notificationssettings"><a class="header" href="#get-notificationssettings">GET <code>/notifications/settings</code></a></h3>
<p><strong>Description</strong>: Get notification settings</p>
<p><strong>Authentication</strong>: Required</p>
<hr />
<h3 id="put-notificationssettings"><a class="header" href="#put-notificationssettings">PUT <code>/notifications/settings</code></a></h3>
<p><strong>Description</strong>: Update notification settings</p>
<p><strong>Authentication</strong>: Required</p>
<h2 id="external-integrations"><a class="header" href="#external-integrations">External Integrations</a></h2>
<h3 id="hyperliquid-api"><a class="header" href="#hyperliquid-api">Hyperliquid API</a></h3>
<p><strong>Base URL</strong>: <code>https://api.hyperliquid.xyz</code></p>
<p><strong>Authentication</strong>: None (public API)</p>
<h4 id="post-info"><a class="header" href="#post-info">POST <code>/info</code></a></h4>
<p><strong>Description</strong>: Get various Hyperliquid data</p>
<p><strong>Request Body Examples</strong>:</p>
<p><strong>Clearinghouse State</strong>:</p>
<pre><code class="language-json">{
  "type": "clearinghouseState",
  "user": "ethereum_address"
}
</code></pre>
<p><strong>Market Metadata</strong>:</p>
<pre><code class="language-json">{
  "type": "meta"
}
</code></pre>
<p><strong>All Mid Prices</strong>:</p>
<pre><code class="language-json">{
  "type": "allMids"
}
</code></pre>
<p><strong>Open Orders</strong>:</p>
<pre><code class="language-json">{
  "type": "openOrders",
  "user": "ethereum_address"
}
</code></pre>
<p><strong>User Fills</strong>:</p>
<pre><code class="language-json">{
  "type": "userFills",
  "user": "ethereum_address"
}
</code></pre>
<p><strong>L2 Orderbook</strong>:</p>
<pre><code class="language-json">{
  "type": "l2Book",
  "coin": "BTC"
}
</code></pre>
<p><strong>Recent Trades</strong>:</p>
<pre><code class="language-json">{
  "type": "recentTrades",
  "coin": "BTC"
}
</code></pre>
<p><strong>24hr Stats</strong>:</p>
<pre><code class="language-json">{
  "type": "24hrStats"
}
</code></pre>
<p><strong>User Funding</strong>:</p>
<pre><code class="language-json">{
  "type": "userFunding",
  "user": "ethereum_address",
  "startTime": 1640995200000,
  "endTime": 1641081600000
}
</code></pre>
<h3 id="turnkey-api"><a class="header" href="#turnkey-api">Turnkey API</a></h3>
<p><strong>Base URL</strong>: <code>https://api.turnkey.com</code></p>
<p><strong>Authentication</strong>: P256 signature in X-Stamp header</p>
<h4 id="post-publicv1querywhoami"><a class="header" href="#post-publicv1querywhoami">POST <code>/public/v1/query/whoami</code></a></h4>
<p><strong>Description</strong>: Get user identity information</p>
<p><strong>Headers</strong>:</p>
<pre><code>Content-Type: text/plain;charset=UTF-8
X-Stamp: base64_encoded_signature
x-client-version: @turnkey/sdk-server@1.7.3
</code></pre>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "organization_id": "turnkey_org_id"
}
</code></pre>
<hr />
<h4 id="post-publicv1queryget_api_keys"><a class="header" href="#post-publicv1queryget_api_keys">POST <code>/public/v1/query/get_api_keys</code></a></h4>
<p><strong>Description</strong>: Get API keys for a user</p>
<p><strong>Headers</strong>: Same as whoami</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "user_id": "turnkey_user_id",
  "organization_id": "turnkey_org_id"
}
</code></pre>
<hr />
<h4 id="post-publicv1submitcreate_read_write_session"><a class="header" href="#post-publicv1submitcreate_read_write_session">POST <code>/public/v1/submit/create_read_write_session</code></a></h4>
<p><strong>Description</strong>: Create read/write session</p>
<p><strong>Headers</strong>: Same as whoami</p>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "parameters": {
    "api_key_name": "session_key_name",
    "target_public_key": "p256_public_key",
    "user_id": "turnkey_user_id",
    "expiration_seconds": "2592000"
  },
  "organization_id": "turnkey_org_id",
  "timestamp_ms": "1640995200000",
  "activity_type": "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
}
</code></pre>
<hr />
<h4 id="get-publicv1health"><a class="header" href="#get-publicv1health">GET <code>/public/v1/health</code></a></h4>
<p><strong>Description</strong>: Health check endpoint</p>
<p><strong>Authentication</strong>: None</p>
<h2 id="websocket-endpoints-1"><a class="header" href="#websocket-endpoints-1">WebSocket Endpoints</a></h2>
<h3 id="regional-websocket-clusters"><a class="header" href="#regional-websocket-clusters">Regional WebSocket Clusters</a></h3>
<p><strong>Connection URLs</strong>:</p>
<pre><code>wss://socket8.axiom.trade/          (US West, Global)
wss://cluster3.axiom.trade/         (US Central)
wss://cluster5.axiom.trade/         (US East)
wss://cluster6.axiom.trade/         (EU West)
wss://cluster2.axiom.trade/         (EU Central)
wss://cluster8.axiom.trade/         (EU East)
wss://cluster4.axiom.trade/         (Asia)
wss://cluster7.axiom.trade/         (Australia)
wss://cluster9.axiom.trade/         (Global)
</code></pre>
<h3 id="connection-headers"><a class="header" href="#connection-headers">Connection Headers</a></h3>
<pre><code>Cookie: auth-access-token={access_token}; auth-refresh-token={refresh_token}
Origin: https://axiom.trade
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
</code></pre>
<h3 id="subscription-messages"><a class="header" href="#subscription-messages">Subscription Messages</a></h3>
<h4 id="subscribe-to-new-token-pairs"><a class="header" href="#subscribe-to-new-token-pairs">Subscribe to New Token Pairs</a></h4>
<pre><code class="language-json">{
  "action": "join",
  "room": "new_pairs"
}
</code></pre>
<p><strong>Response Format</strong>:</p>
<pre><code class="language-json">{
  "room": "new_pairs",
  "content": {
    "token_address": "token_mint",
    "token_ticker": "SYMBOL",
    "token_name": "Token Name",
    "initial_liquidity_sol": 10.0,
    "supply": 1000000000
  }
}
</code></pre>
<h4 id="subscribe-to-token-price-updates"><a class="header" href="#subscribe-to-token-price-updates">Subscribe to Token Price Updates</a></h4>
<pre><code class="language-json">{
  "action": "join",
  "room": "token_mint_address"
}
</code></pre>
<h4 id="subscribe-to-wallet-transactions"><a class="header" href="#subscribe-to-wallet-transactions">Subscribe to Wallet Transactions</a></h4>
<pre><code class="language-json">{
  "action": "join",
  "room": "v:wallet_address"
}
</code></pre>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<p><strong>Connection Established</strong>:</p>
<pre><code class="language-json">{
  "type": "connected",
  "session_id": "session_id"
}
</code></pre>
<p><strong>Connection Lost</strong>:</p>
<pre><code class="language-json">{
  "type": "disconnected",
  "reason": "token_expired"
}
</code></pre>
<p><strong>Market Update</strong>:</p>
<pre><code class="language-json">{
  "type": "market_update",
  "data": {
    "token_mint": "token_address",
    "symbol": "BONK",
    "price_usd": 0.00001,
    "price_change_24h": 5.5,
    "volume_24h": 1000.0,
    "timestamp": 1640995200
  }
}
</code></pre>
<h2 id="infrastructure-monitoring"><a class="header" href="#infrastructure-monitoring">Infrastructure Monitoring</a></h2>
<h3 id="lighthouse-service"><a class="header" href="#lighthouse-service">Lighthouse Service</a></h3>
<p><strong>URL</strong>: <code>https://api8.axiom.trade/lighthouse</code>
<strong>Method</strong>: GET
<strong>Authentication</strong>: None</p>
<h3 id="mev-protection-services"><a class="header" href="#mev-protection-services">MEV Protection Services</a></h3>
<h4 id="0slot-network"><a class="header" href="#0slot-network">0slot Network</a></h4>
<pre><code>https://la1.0slot.trade/health      (Los Angeles)
https://ny3.0slot.trade/health      (New York)
https://de1.0slot.trade/health      (Germany)
https://ams1.0slot.trade/health     (Amsterdam)
https://jp1.0slot.trade/health      (Japan)
</code></pre>
<h4 id="nozomi-temporal-network"><a class="header" href="#nozomi-temporal-network">Nozomi Temporal Network</a></h4>
<pre><code>https://lax1.secure.nozomi.temporal.xyz/ping    (LAX)
https://ewr1.secure.nozomi.temporal.xyz/ping    (EWR)
https://ams1.secure.nozomi.temporal.xyz/ping    (AMS)
https://fra2.secure.nozomi.temporal.xyz/ping    (FRA)
https://ash1.secure.nozomi.temporal.xyz/ping    (ASH)
https://sgp1.secure.nozomi.temporal.xyz/ping    (SGP)
https://tyo1.secure.nozomi.temporal.xyz/ping    (TYO)
https://pit1.secure.nozomi.temporal.xyz/ping    (PIT)
https://nozomi.temporal.xyz/ping                (Main)
</code></pre>
<h4 id="external-mev-protection"><a class="header" href="#external-mev-protection">External MEV Protection</a></h4>
<p><strong>URL</strong>: <code>https://tx.axiomext.net/ping</code></p>
<h4 id="jito-block-engine"><a class="header" href="#jito-block-engine">Jito Block Engine</a></h4>
<pre><code>https://slc.mainnet.block-engine.jito.wtf/api/v1/getTipAccounts      (Salt Lake City)
https://london.mainnet.block-engine.jito.wtf/api/v1/getTipAccounts   (London)
https://frankfurt.mainnet.block-engine.jito.wtf/api/v1/getTipAccounts (Frankfurt)
https://ny.mainnet.block-engine.jito.wtf/api/v1/getTipAccounts       (New York)
https://tokyo.mainnet.block-engine.jito.wtf/api/v1/getTipAccounts    (Tokyo)
</code></pre>
<h4 id="astralane-gateway"><a class="header" href="#astralane-gateway">Astralane Gateway</a></h4>
<pre><code>https://axiom-fra.gateway.astralane.io/gethealth?api-key={api_key}   (Frankfurt)
https://axiom-ca.gateway.astralane.io/gethealth?api-key={api_key}    (Canada)
</code></pre>
<p><strong>API Key</strong>: <code>AxiomozyNSTbBlP88VY35BvSdDVS3du1be8Q1VMmconPgpWFVWnpmfnpUrhRj97F</code></p>
<h4 id="arbitrum-rpc"><a class="header" href="#arbitrum-rpc">Arbitrum RPC</a></h4>
<p><strong>URL</strong>: <code>https://arb1.arbitrum.io/rpc</code>
<strong>Method</strong>: POST
<strong>Body</strong>:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "eth_blockNumber",
  "params": [],
  "id": 1
}
</code></pre>
<h2 id="rate-limiting-4"><a class="header" href="#rate-limiting-4">Rate Limiting</a></h2>
<h3 id="global-limits"><a class="header" href="#global-limits">Global Limits</a></h3>
<ul>
<li><strong>Authentication</strong>: 5 requests per minute per IP</li>
<li><strong>Trading</strong>: 10 requests per minute per user</li>
<li><strong>Market Data</strong>: 100 requests per minute per user</li>
<li><strong>WebSocket</strong>: 1 connection per user per region</li>
</ul>
<h3 id="error-responses"><a class="header" href="#error-responses">Error Responses</a></h3>
<p><strong>429 Too Many Requests</strong>:</p>
<pre><code class="language-json">{
  "error": "Rate limit exceeded",
  "retry_after": 60,
  "limit": 100,
  "remaining": 0
}
</code></pre>
<h2 id="error-handling-13"><a class="header" href="#error-handling-13">Error Handling</a></h2>
<h3 id="http-status-codes-1"><a class="header" href="#http-status-codes-1">HTTP Status Codes</a></h3>
<ul>
<li><code>200</code>: Success</li>
<li><code>400</code>: Bad Request (invalid parameters)</li>
<li><code>401</code>: Unauthorized (invalid or expired token)</li>
<li><code>403</code>: Forbidden (insufficient permissions)</li>
<li><code>404</code>: Not Found (resource not found)</li>
<li><code>429</code>: Too Many Requests (rate limit exceeded)</li>
<li><code>500</code>: Internal Server Error</li>
<li><code>503</code>: Service Unavailable</li>
</ul>
<h3 id="error-response-format"><a class="header" href="#error-response-format">Error Response Format</a></h3>
<pre><code class="language-json">{
  "error": "error_code",
  "message": "Human readable error message",
  "details": {
    "field": "Additional error details"
  }
}
</code></pre>
<h2 id="security-considerations-8"><a class="header" href="#security-considerations-8">Security Considerations</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<ul>
<li>All authenticated endpoints require valid JWT access tokens</li>
<li>Tokens expire after 15 minutes and must be refreshed</li>
<li>Refresh tokens are valid for 30 days</li>
<li>Failed authentication attempts are rate limited</li>
</ul>
<h3 id="request-signing"><a class="header" href="#request-signing">Request Signing</a></h3>
<ul>
<li>Turnkey API requests require P256 ECDSA signatures</li>
<li>Signatures include request timestamp to prevent replay attacks</li>
<li>Public keys are verified against registered credentials</li>
</ul>
<h3 id="mev-protection-1"><a class="header" href="#mev-protection-1">MEV Protection</a></h3>
<ul>
<li>Transactions are routed through MEV protection services</li>
<li>Multiple providers ensure redundancy and optimal routing</li>
<li>Real-time monitoring of service health and performance</li>
</ul>
<h3 id="data-privacy"><a class="header" href="#data-privacy">Data Privacy</a></h3>
<ul>
<li>All API communication uses TLS 1.3</li>
<li>Sensitive data is encrypted at rest</li>
<li>API logs exclude personally identifiable information</li>
<li>Rate limiting prevents abuse and DoS attacks</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to axiomtrade-rs will be documented in this file.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>,
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="010---2025-01-14"><a class="header" href="#010---2025-01-14">[0.1.0] - 2025-01-14</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<h4 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h4>
<ul>
<li><strong>High-performance Rust SDK</strong> for Axiom Trade - fastest decentralized exchange aggregator on Solana and Hyperliquid</li>
<li><strong>Cross-platform compatibility</strong> (Windows, Linux, macOS) with native performance optimizations</li>
<li><strong>Type-safe API interactions</strong> with comprehensive error handling using Rust's Result types</li>
<li><strong>Async/await networking</strong> powered by Tokio runtime for maximum throughput</li>
</ul>
<h4 id="authentication-system"><a class="header" href="#authentication-system">Authentication System</a></h4>
<ul>
<li><strong>Enhanced authentication client</strong> with automatic session management and token refresh</li>
<li><strong>PBKDF2 password hashing</strong> with SHA256 (600,000 iterations) for superior security</li>
<li><strong>P256 cryptographic support</strong> for Turnkey integration with ECDSA signing</li>
<li><strong>Automatic OTP fetching</strong> via IMAP from inbox.lv accounts (optional feature)</li>
<li><strong>Session persistence</strong> with secure cookie handling and automatic renewal</li>
<li><strong>Token management</strong> with automatic refresh and expiration handling</li>
</ul>
<h4 id="trading-operations-1"><a class="header" href="#trading-operations-1">Trading Operations</a></h4>
<ul>
<li><strong>Portfolio management</strong> with real-time balance queries and position tracking</li>
<li><strong>Batch operations</strong> for handling 1000+ wallet queries efficiently</li>
<li><strong>Market data retrieval</strong> with trending tokens and price feed subscriptions</li>
<li><strong>Trading execution</strong> with buy, sell, and swap operations</li>
<li><strong>Multi-chain support</strong> for Solana and Hyperliquid networks</li>
</ul>
<h4 id="websocket-streaming-1"><a class="header" href="#websocket-streaming-1">WebSocket Streaming</a></h4>
<ul>
<li><strong>Real-time data streaming</strong> with automatic reconnection and error recovery</li>
<li><strong>Price subscriptions</strong> for live market data feeds</li>
<li><strong>Event-driven architecture</strong> with customizable message handlers</li>
<li><strong>Connection pooling</strong> for handling multiple simultaneous streams</li>
</ul>
<h4 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h4>
<ul>
<li><strong>Rate limiting</strong> with intelligent backoff strategies</li>
<li><strong>Retry logic</strong> for network failures with exponential backoff</li>
<li><strong>Health checks</strong> for monitoring system status and connectivity</li>
<li><strong>Comprehensive logging</strong> with structured error reporting</li>
<li><strong>User agent rotation</strong> with realistic browser fingerprinting</li>
</ul>
<h4 id="developer-experience-1"><a class="header" href="#developer-experience-1">Developer Experience</a></h4>
<ul>
<li><strong>Extensive documentation</strong> with mdBook-powered reference guide</li>
<li><strong>30+ code examples</strong> covering all major use cases</li>
<li><strong>Complete API reference</strong> with endpoint documentation</li>
<li><strong>Authentication examples</strong> including OTP and session management</li>
<li><strong>Trading bot templates</strong> for automated trading strategies</li>
<li><strong>Setup utilities</strong> for environment configuration</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<h4 id="api-modules"><a class="header" href="#api-modules">API Modules</a></h4>
<ul>
<li><code>auth</code> - Authentication and session management</li>
<li><code>portfolio</code> - Balance queries and position tracking</li>
<li><code>market_data</code> - Price feeds and trending token data</li>
<li><code>trading</code> - Buy, sell, and swap operations</li>
<li><code>websocket</code> - Real-time streaming connections</li>
<li><code>notifications</code> - Price alerts and system notifications</li>
<li><code>hyperliquid</code> - Hyperliquid-specific integration</li>
<li><code>turnkey</code> - Turnkey custody integration</li>
<li><code>infrastructure</code> - Health monitoring and system status</li>
</ul>
<h4 id="utility-features"><a class="header" href="#utility-features">Utility Features</a></h4>
<ul>
<li>Password hashing with industry-standard PBKDF2</li>
<li>Environment variable loading with special character support</li>
<li>P256 cryptographic operations for secure signing</li>
<li>Rate limiting to respect API constraints</li>
<li>Automatic retry with intelligent backoff</li>
<li>Cross-platform user agent generation</li>
</ul>
<h4 id="email-integration"><a class="header" href="#email-integration">Email Integration</a></h4>
<ul>
<li>IMAP-based OTP fetching from inbox.lv accounts</li>
<li>Automatic email parsing for security codes</li>
<li>Configurable polling intervals and timeouts</li>
<li>Robust error handling for email connectivity issues</li>
</ul>
<h3 id="technical-specifications"><a class="header" href="#technical-specifications">Technical Specifications</a></h3>
<h4 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h4>
<ul>
<li>Sub-50ms API response times achieved</li>
<li>Support for 1000+ concurrent WebSocket connections</li>
<li>Batch processing for 1000+ wallet operations</li>
<li>Memory usage under 50MB for typical operations</li>
<li>Zero-copy deserialization where possible</li>
</ul>
<h4 id="security-features"><a class="header" href="#security-features">Security Features</a></h4>
<ul>
<li>No plain text password storage</li>
<li>Secure PBKDF2 hashing with 600,000 iterations</li>
<li>TLS encryption for all network communications</li>
<li>Request signing for authenticated endpoints</li>
<li>Input sanitization and validation</li>
<li>OS keychain integration for token storage</li>
</ul>
<h4 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h4>
<ul>
<li><code>tokio</code> - Async runtime with full feature set</li>
<li><code>reqwest</code> - HTTP client with JSON and cookie support</li>
<li><code>serde</code> - Serialization framework with derive macros</li>
<li><code>fastwebsockets</code> - High-performance WebSocket client</li>
<li><code>p256</code> - Elliptic curve cryptography for Turnkey</li>
<li><code>pbkdf2</code> - Password-based key derivation function</li>
<li><code>imap</code> - Email protocol for OTP automation</li>
</ul>
<h3 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking Changes</a></h3>
<p>This is the initial release, so no breaking changes apply.</p>
<h3 id="migration-notes"><a class="header" href="#migration-notes">Migration Notes</a></h3>
<h4 id="from-python-axiompy"><a class="header" href="#from-python-axiompy">From Python axiompy</a></h4>
<p>This Rust implementation provides significant improvements over the Python version:</p>
<ol>
<li><strong>Performance</strong>: 10-100x faster execution times</li>
<li><strong>Memory Safety</strong>: Zero-cost abstractions with compile-time guarantees</li>
<li><strong>Type Safety</strong>: Strong typing prevents runtime errors</li>
<li><strong>Concurrency</strong>: Native async/await support for high-throughput operations</li>
<li><strong>Cross-platform</strong>: Single binary deployment without runtime dependencies</li>
</ol>
<h4 id="migration-steps"><a class="header" href="#migration-steps">Migration Steps</a></h4>
<ol>
<li>Install Rust toolkit (rustc 1.70+)</li>
<li>Add <code>axiomtrade-rs = "0.1.0"</code> to Cargo.toml</li>
<li>Update import statements to use Rust module system</li>
<li>Convert callback-based code to async/await pattern</li>
<li>Update error handling to use Result types</li>
<li>Configure environment variables for OTP automation</li>
</ol>
<h4 id="api-compatibility"><a class="header" href="#api-compatibility">API Compatibility</a></h4>
<p>The Rust API maintains functional compatibility with the Python version while providing:</p>
<ul>
<li>Improved error messages with detailed context</li>
<li>Better type safety with compile-time validation</li>
<li>Enhanced performance with zero-cost abstractions</li>
<li>Native async support without callback complexity</li>
</ul>
<h3 id="future-roadmap"><a class="header" href="#future-roadmap">Future Roadmap</a></h3>
<h4 id="version-020-q1-2025"><a class="header" href="#version-020-q1-2025">Version 0.2.0 (Q1 2025)</a></h4>
<ul>
<li>GraphQL API integration for enhanced data queries</li>
<li>Advanced order types (limit, stop-loss, take-profit)</li>
<li>Portfolio analytics and performance metrics</li>
<li>Risk management tools and position sizing</li>
<li>Enhanced WebSocket reconnection strategies</li>
</ul>
<h4 id="version-030-q2-2025"><a class="header" href="#version-030-q2-2025">Version 0.3.0 (Q2 2025)</a></h4>
<ul>
<li>Mobile SDK compilation targets (iOS/Android)</li>
<li>Advanced trading strategies and backtesting</li>
<li>Machine learning integration for price prediction</li>
<li>Cross-chain bridge operations</li>
<li>Advanced notification system with multiple channels</li>
</ul>
<h4 id="version-100-q3-2025"><a class="header" href="#version-100-q3-2025">Version 1.0.0 (Q3 2025)</a></h4>
<ul>
<li>Production-ready stability guarantees</li>
<li>Complete API coverage for all Axiom Trade features</li>
<li>Advanced security features and audit compliance</li>
<li>Performance optimizations for institutional use</li>
<li>Comprehensive testing and validation suite</li>
</ul>
<h3 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h3>
<ol>
<li><strong>OTP Automation</strong>: Requires manual setup of inbox.lv account and IMAP configuration</li>
<li><strong>WebSocket Reconnection</strong>: Occasional delays during network transitions (will be improved in 0.2.0)</li>
<li><strong>Windows Compatibility</strong>: Some examples require WSL for optimal performance</li>
<li><strong>Documentation</strong>: Some advanced features need additional code examples</li>
</ol>
<h3 id="contributors"><a class="header" href="#contributors">Contributors</a></h3>
<ul>
<li><strong>Vibhek Soni</strong> - Primary developer and maintainer</li>
<li><strong>Axiom Trade Team</strong> - API specification and testing support</li>
<li><strong>Rust Community</strong> - Libraries and best practices guidance</li>
</ul>
<h3 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h3>
<p>This project builds upon the foundation laid by the Python axiompy library while leveraging Rust's performance and safety guarantees. Special thanks to the Axiom Trade team for providing comprehensive API documentation and testing support.</p>
<p>The automated OTP system was inspired by the need for seamless authentication in trading environments where manual intervention can cause missed opportunities.</p>
<hr />
<p>For detailed upgrade instructions and migration guides, see the <a href="reference/../installation.html">Installation</a> and <a href="reference/../quick-start.html">Quick Start</a> documentation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
