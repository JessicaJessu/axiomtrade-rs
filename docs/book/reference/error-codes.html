<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error Codes - axiomtrade-rs Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using the axiomtrade-rs Solana trading SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">axiomtrade-rs Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs/edit/master/docs/src/reference/error-codes.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="error-codes-reference"><a class="header" href="#error-codes-reference">Error Codes Reference</a></h1>
<p>This document provides a comprehensive reference for all error types, HTTP status codes, and error handling patterns in the Axiom Trade Rust SDK. Use this reference for debugging and implementing robust error handling in your applications.</p>
<h2 id="error-type-hierarchy"><a class="header" href="#error-type-hierarchy">Error Type Hierarchy</a></h2>
<h3 id="core-error-types"><a class="header" href="#core-error-types">Core Error Types</a></h3>
<h4 id="axiomerror-primary-error-type"><a class="header" href="#axiomerror-primary-error-type"><code>AxiomError</code> (Primary Error Type)</a></h4>
<p>The main error type that encompasses all possible errors in the SDK.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AxiomError {
    Auth(AuthError),                    // Authentication-related errors
    Network(reqwest::Error),            // HTTP network errors
    Serialization(serde_json::Error),   // JSON serialization/deserialization
    Io(std::io::Error),                 // File system I/O errors
    Api { message: String },            // General API errors
    InvalidResponse,                    // Malformed API responses
    RateLimit,                          // Rate limiting exceeded
    ServiceUnavailable,                 // Service temporarily unavailable
    Timeout,                            // Request timeout
    Config(String),                     // Configuration errors
    WebSocket(String),                  // WebSocket connection errors
    Hyperliquid(String),                // Hyperliquid API errors
    Infrastructure(String),             // Infrastructure health check failures
    Social(String),                     // Social API errors
    Notifications(String),              // Notifications system errors
    Crypto { message: String },         // Cryptographic operation errors
    Authentication { message: String }, // Authentication state errors
    Unknown(String),                    // Catch-all for unexpected errors
}
<span class="boring">}</span></code></pre></pre>
<h4 id="autherror-authentication-errors"><a class="header" href="#autherror-authentication-errors"><code>AuthError</code> (Authentication Errors)</a></h4>
<p>Specific to authentication operations including login, OTP, and token management.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AuthError {
    NetworkError(reqwest::Error),       // Network failures during auth
    InvalidCredentials,                 // Wrong email/password
    OtpRequired,                        // OTP verification needed
    InvalidOtp,                         // Incorrect OTP code
    TokenExpired,                       // Access token has expired
    TokenNotFound,                      // Token missing from storage
    SerializationError(serde_json::Error), // Token serialization issues
    IoError(std::io::Error),            // Token file I/O errors
    EmailError(String),                 // Email OTP fetching errors
    ApiError { message: String },       // API-specific auth errors
    Unauthorized,                       // HTTP 401 - invalid token
    NotAuthenticated,                   // No valid authentication present
}
<span class="boring">}</span></code></pre></pre>
<h4 id="module-specific-error-types"><a class="header" href="#module-specific-error-types">Module-Specific Error Types</a></h4>
<p><strong>Trading Errors (<code>TradingError</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TradingError {
    AuthError(AuthError),               // Authentication failures
    NetworkError(reqwest::Error),       // Network issues
    InvalidTokenMint(String),           // Invalid token address
    InsufficientBalance(String),        // Not enough funds
    SlippageExceeded(String),           // Price slippage too high
    TransactionFailed(String),          // Transaction execution failed
    ApiError(String),                   // General API errors
    ParsingError(String),               // Response parsing errors
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Market Data Errors (<code>MarketDataError</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MarketDataError {
    AuthError(AuthError),               // Authentication failures
    NetworkError(reqwest::Error),       // Network issues
    InvalidTokenMint(String),           // Invalid token address
    TokenNotFound(String),              // Token doesn't exist
    ApiError(String),                   // General API errors
    ParsingError(String),               // Response parsing errors
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Portfolio Errors (<code>PortfolioError</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum PortfolioError {
    AuthError(AuthError),               // Authentication failures
    NetworkError(reqwest::Error),       // Network issues
    InvalidWalletAddress(String),       // Invalid Solana address
    ApiError(String),                   // General API errors
    ParsingError(String),               // Response parsing errors
}
<span class="boring">}</span></code></pre></pre>
<h2 id="http-status-codes"><a class="header" href="#http-status-codes">HTTP Status Codes</a></h2>
<h3 id="success-codes-2xx"><a class="header" href="#success-codes-2xx">Success Codes (2xx)</a></h3>
<ul>
<li><strong>200 OK</strong>: Request successful, response contains data</li>
<li><strong>201 Created</strong>: Resource created successfully (orders, subscriptions)</li>
<li><strong>204 No Content</strong>: Request successful, no response body</li>
</ul>
<h3 id="client-error-codes-4xx"><a class="header" href="#client-error-codes-4xx">Client Error Codes (4xx)</a></h3>
<h4 id="400-bad-request"><a class="header" href="#400-bad-request"><strong>400 Bad Request</strong></a></h4>
<p>Invalid request parameters or malformed data.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Invalid token mint addresses</li>
<li>Malformed wallet addresses</li>
<li>Missing required parameters</li>
<li>Invalid parameter types or ranges</li>
</ul>
<p><strong>Example Response:</strong></p>
<pre><code class="language-json">{
  "error": "Invalid token mint address",
  "code": 400,
  "details": "Token mint must be a valid Solana address"
}
</code></pre>
<p><strong>Handling Pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatusCode::BAD_REQUEST =&gt; {
    let error_text = response.text().await?;
    Err(TradingError::ApiError(format!("Bad request: {}", error_text)))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="401-unauthorized"><a class="header" href="#401-unauthorized"><strong>401 Unauthorized</strong></a></h4>
<p>Authentication token missing, expired, or invalid.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Access token expired</li>
<li>Invalid access token</li>
<li>Missing Authorization header</li>
<li>Revoked token</li>
</ul>
<p><strong>Example Response:</strong></p>
<pre><code class="language-json">{
  "error": "Token expired",
  "code": 401,
  "message": "Access token has expired. Please refresh or re-authenticate."
}
</code></pre>
<p><strong>Handling Pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatusCode::UNAUTHORIZED =&gt; {
    Err(TradingError::AuthError(AuthError::Unauthorized))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="403-forbidden"><a class="header" href="#403-forbidden"><strong>403 Forbidden</strong></a></h4>
<p>Valid authentication but insufficient permissions.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Account suspended</li>
<li>Feature not enabled for account</li>
<li>Trading limits exceeded</li>
<li>Geographic restrictions</li>
</ul>
<h4 id="404-not-found"><a class="header" href="#404-not-found"><strong>404 Not Found</strong></a></h4>
<p>Requested resource doesn't exist.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Invalid token mint address</li>
<li>Non-existent wallet address</li>
<li>Deleted or unavailable endpoint</li>
</ul>
<p><strong>Example Handling:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatusCode::NOT_FOUND =&gt; {
    Err(MarketDataError::TokenNotFound(token_symbol.to_string()))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="429-too-many-requests"><a class="header" href="#429-too-many-requests"><strong>429 Too Many Requests</strong></a></h4>
<p>Rate limit exceeded.</p>
<p><strong>Response Headers:</strong></p>
<ul>
<li><code>Retry-After</code>: Seconds to wait before retrying</li>
<li><code>X-RateLimit-Limit</code>: Maximum requests per window</li>
<li><code>X-RateLimit-Remaining</code>: Remaining requests in current window</li>
<li><code>X-RateLimit-Reset</code>: Timestamp when limit resets</li>
</ul>
<p><strong>Handling Pattern:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Retryable status codes include 429
matches!(status.as_u16(), 429 | 500 | 502 | 503 | 504)
<span class="boring">}</span></code></pre></pre>
<h3 id="server-error-codes-5xx"><a class="header" href="#server-error-codes-5xx">Server Error Codes (5xx)</a></h3>
<h4 id="500-internal-server-error"><a class="header" href="#500-internal-server-error"><strong>500 Internal Server Error</strong></a></h4>
<p>Unexpected server-side error.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Database connectivity issues</li>
<li>Internal service failures</li>
<li>Unhandled exceptions</li>
</ul>
<h4 id="502-bad-gateway"><a class="header" href="#502-bad-gateway"><strong>502 Bad Gateway</strong></a></h4>
<p>Upstream service unavailable.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Solana RPC node failures</li>
<li>Third-party API timeouts</li>
<li>Load balancer issues</li>
</ul>
<h4 id="503-service-unavailable"><a class="header" href="#503-service-unavailable"><strong>503 Service Unavailable</strong></a></h4>
<p>Service temporarily overloaded or under maintenance.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Scheduled maintenance</li>
<li>High traffic overload</li>
<li>Infrastructure scaling</li>
</ul>
<h4 id="504-gateway-timeout"><a class="header" href="#504-gateway-timeout"><strong>504 Gateway Timeout</strong></a></h4>
<p>Request timeout to upstream services.</p>
<p><strong>Common Causes:</strong></p>
<ul>
<li>Solana network congestion</li>
<li>Slow blockchain confirmations</li>
<li>Database query timeouts</li>
</ul>
<h2 id="api-specific-error-codes"><a class="header" href="#api-specific-error-codes">API-Specific Error Codes</a></h2>
<h3 id="authentication-api-errors"><a class="header" href="#authentication-api-errors">Authentication API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>AUTH_001</code></td><td><code>InvalidCredentials</code></td><td>Wrong email or password</td><td>Re-enter credentials</td></tr>
<tr><td><code>AUTH_002</code></td><td><code>OtpRequired</code></td><td>OTP verification needed</td><td>Provide OTP code</td></tr>
<tr><td><code>AUTH_003</code></td><td><code>InvalidOtp</code></td><td>Incorrect OTP code</td><td>Re-enter correct OTP</td></tr>
<tr><td><code>AUTH_004</code></td><td><code>TokenExpired</code></td><td>Access token expired</td><td>Refresh token or re-login</td></tr>
<tr><td><code>AUTH_005</code></td><td><code>TokenNotFound</code></td><td>No stored tokens</td><td>Perform fresh login</td></tr>
<tr><td><code>AUTH_006</code></td><td><code>EmailError</code></td><td>OTP email fetch failed</td><td>Check email configuration</td></tr>
</tbody></table>
</div>
<h3 id="trading-api-errors"><a class="header" href="#trading-api-errors">Trading API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>TRADE_001</code></td><td><code>InvalidTokenMint</code></td><td>Invalid token address</td><td>Verify token mint address</td></tr>
<tr><td><code>TRADE_002</code></td><td><code>InsufficientBalance</code></td><td>Not enough funds</td><td>Add funds or reduce amount</td></tr>
<tr><td><code>TRADE_003</code></td><td><code>SlippageExceeded</code></td><td>Price moved too much</td><td>Increase slippage tolerance</td></tr>
<tr><td><code>TRADE_004</code></td><td><code>TransactionFailed</code></td><td>Blockchain transaction failed</td><td>Check network status, retry</td></tr>
<tr><td><code>TRADE_005</code></td><td><code>InvalidAmount</code></td><td>Amount outside valid range</td><td>Check min/max trading limits</td></tr>
</tbody></table>
</div>
<h3 id="market-data-api-errors"><a class="header" href="#market-data-api-errors">Market Data API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>MARKET_001</code></td><td><code>TokenNotFound</code></td><td>Token doesn't exist</td><td>Verify token address/symbol</td></tr>
<tr><td><code>MARKET_002</code></td><td><code>InvalidTokenMint</code></td><td>Malformed token address</td><td>Use valid Solana address</td></tr>
<tr><td><code>MARKET_003</code></td><td><code>DataUnavailable</code></td><td>Price data not available</td><td>Try different token or wait</td></tr>
</tbody></table>
</div>
<h3 id="portfolio-api-errors"><a class="header" href="#portfolio-api-errors">Portfolio API Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th><th>Description</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>PORTFOLIO_001</code></td><td><code>InvalidWalletAddress</code></td><td>Invalid Solana address</td><td>Use valid wallet address</td></tr>
<tr><td><code>PORTFOLIO_002</code></td><td><code>WalletNotFound</code></td><td>Wallet has no activity</td><td>Verify address or check different wallet</td></tr>
</tbody></table>
</div>
<h2 id="error-message-formats"><a class="header" href="#error-message-formats">Error Message Formats</a></h2>
<h3 id="standard-error-response"><a class="header" href="#standard-error-response">Standard Error Response</a></h3>
<pre><code class="language-json">{
  "error": "Human-readable error message",
  "code": "ERROR_CODE",
  "details": "Additional context or debugging information",
  "timestamp": "2024-01-15T10:30:00Z",
  "request_id": "req_123456789"
}
</code></pre>
<h3 id="validation-error-response"><a class="header" href="#validation-error-response">Validation Error Response</a></h3>
<pre><code class="language-json">{
  "error": "Validation failed",
  "code": "VALIDATION_ERROR",
  "field_errors": {
    "token_mint": ["Invalid Solana address format"],
    "amount": ["Must be greater than 0.001"]
  }
}
</code></pre>
<h3 id="rate-limit-error-response"><a class="header" href="#rate-limit-error-response">Rate Limit Error Response</a></h3>
<pre><code class="language-json">{
  "error": "Rate limit exceeded",
  "code": "RATE_LIMIT_EXCEEDED",
  "retry_after": 60,
  "limit": 100,
  "remaining": 0,
  "reset_time": "2024-01-15T10:31:00Z"
}
</code></pre>
<h2 id="common-error-scenarios-and-solutions"><a class="header" href="#common-error-scenarios-and-solutions">Common Error Scenarios and Solutions</a></h2>
<h3 id="authentication-issues"><a class="header" href="#authentication-issues">Authentication Issues</a></h3>
<p><strong>Scenario: Login fails with invalid credentials</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match auth_client.login(&amp;email, &amp;password, None).await {
    Err(AxiomError::Auth(AuthError::InvalidCredentials)) =&gt; {
        println!("Invalid email or password. Please check your credentials.");
        // Guide user to re-enter credentials or password reset
    }
    Err(e) =&gt; println!("Login failed: {}", e),
    Ok(tokens) =&gt; println!("Login successful!"),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Scenario: OTP required but auto-fetch fails</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match auth_client.login(&amp;email, &amp;password, None).await {
    Err(AxiomError::Auth(AuthError::EmailError(msg))) =&gt; {
        println!("OTP auto-fetch failed: {}", msg);
        println!("Please configure inbox.lv integration or enter OTP manually");
        // Fall back to manual OTP entry
    }
    Ok(tokens) =&gt; println!("Login successful with auto-OTP!"),
    Err(e) =&gt; println!("Login failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trading-issues"><a class="header" href="#trading-issues">Trading Issues</a></h3>
<p><strong>Scenario: Insufficient balance for trade</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match trading_client.buy_token(token_mint, amount, slippage).await {
    Err(AxiomError::Trading(TradingError::InsufficientBalance(msg))) =&gt; {
        println!("Insufficient balance: {}", msg);
        // Show current balance and suggest funding wallet
        let balance = portfolio_client.get_balance(&amp;wallet_address).await?;
        println!("Current SOL balance: {:.6}", balance.sol_balance);
        println!("Add more SOL to your wallet to complete this trade");
    }
    Ok(response) =&gt; println!("Trade successful: {}", response.transaction_signature),
    Err(e) =&gt; println!("Trade failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Scenario: Slippage exceeded during volatile market</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match trading_client.buy_token(token_mint, amount, Some(1.0)).await {
    Err(AxiomError::Trading(TradingError::SlippageExceeded(msg))) =&gt; {
        println!("Slippage exceeded: {}", msg);
        println!("Market is volatile. Try:");
        println!("1. Increase slippage tolerance to 2-5%");
        println!("2. Reduce trade amount");
        println!("3. Wait for market to stabilize");
        
        // Retry with higher slippage
        let retry_result = trading_client.buy_token(token_mint, amount, Some(3.0)).await;
        match retry_result {
            Ok(response) =&gt; println!("Retry successful with higher slippage"),
            Err(e) =&gt; println!("Retry also failed: {}", e),
        }
    }
    Ok(response) =&gt; println!("Trade successful"),
    Err(e) =&gt; println!("Trade failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-and-rate-limiting-issues"><a class="header" href="#network-and-rate-limiting-issues">Network and Rate Limiting Issues</a></h3>
<p><strong>Scenario: Rate limit exceeded</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match market_client.get_trending_tokens().await {
    Err(AxiomError::RateLimit) =&gt; {
        println!("Rate limit exceeded. Waiting before retry...");
        tokio::time::sleep(Duration::from_secs(60)).await;
        
        // Retry the request
        match market_client.get_trending_tokens().await {
            Ok(tokens) =&gt; println!("Retry successful"),
            Err(e) =&gt; println!("Retry failed: {}", e),
        }
    }
    Ok(tokens) =&gt; println!("Found {} trending tokens", tokens.len()),
    Err(e) =&gt; println!("Request failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-connection-issues"><a class="header" href="#websocket-connection-issues">WebSocket Connection Issues</a></h3>
<p><strong>Scenario: WebSocket disconnection with reconnection</strong></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MessageHandler for MyHandler {
    async fn on_disconnected(&amp;self, reason: String) {
        println!("WebSocket disconnected: {}", reason);
        
        // Implement exponential backoff for reconnection
        let mut backoff = Duration::from_secs(1);
        let max_backoff = Duration::from_secs(60);
        
        loop {
            tokio::time::sleep(backoff).await;
            
            match self.ws_client.reconnect().await {
                Ok(()) =&gt; {
                    println!("Reconnection successful");
                    break;
                }
                Err(e) =&gt; {
                    println!("Reconnection failed: {}", e);
                    backoff = std::cmp::min(backoff * 2, max_backoff);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-best-practices"><a class="header" href="#error-handling-best-practices">Error Handling Best Practices</a></h2>
<h3 id="1-use-result-types-consistently"><a class="header" href="#1-use-result-types-consistently">1. Use Result Types Consistently</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Explicit error handling
pub async fn get_portfolio(&amp;self) -&gt; Result&lt;Portfolio, AxiomError&gt; {
    match self.make_request().await {
        Ok(response) =&gt; Ok(response.json().await?),
        Err(e) =&gt; Err(AxiomError::Network(e)),
    }
}

// Avoid: Panicking on errors
pub async fn get_portfolio_bad(&amp;self) -&gt; Portfolio {
    self.make_request().await.unwrap().json().await.unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-implement-retry-logic-for-transient-errors"><a class="header" href="#2-implement-retry-logic-for-transient-errors">2. Implement Retry Logic for Transient Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::utils::retry::{RetryConfig, retry_with_backoff};

let config = RetryConfig {
    max_attempts: 3,
    initial_delay: Duration::from_millis(500),
    max_delay: Duration::from_secs(10),
    backoff_multiplier: 2.0,
};

let result = retry_with_backoff(config, || async {
    market_client.get_trending_tokens().await
}).await;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-provide-context-in-error-messages"><a class="header" href="#3-provide-context-in-error-messages">3. Provide Context in Error Messages</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Contextual error messages
match trading_client.buy_token(mint, amount, slippage).await {
    Err(e) =&gt; return Err(AxiomError::Api {
        message: format!("Failed to buy {} tokens of {}: {}", amount, mint, e)
    }),
    Ok(response) =&gt; response,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-handle-authentication-errors-gracefully"><a class="header" href="#4-handle-authentication-errors-gracefully">4. Handle Authentication Errors Gracefully</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_auth_error(error: AuthError) -&gt; Result&lt;(), AxiomError&gt; {
    match error {
        AuthError::TokenExpired =&gt; {
            println!("Token expired, attempting refresh...");
            // Attempt token refresh
            let token_manager = TokenManager::new(None);
            token_manager.refresh_token().await?;
            Ok(())
        }
        AuthError::Unauthorized =&gt; {
            println!("Authentication invalid, please log in again");
            // Clear stored tokens and prompt for re-authentication
            let token_manager = TokenManager::new(None);
            token_manager.clear_tokens().await?;
            Err(AxiomError::Authentication {
                message: "Re-authentication required".to_string()
            })
        }
        _ =&gt; Err(AxiomError::Auth(error)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-validate-input-parameters-early"><a class="header" href="#5-validate-input-parameters-early">5. Validate Input Parameters Early</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_token_mint(mint: &amp;str) -&gt; Result&lt;(), AxiomError&gt; {
    if mint.is_empty() {
        return Err(AxiomError::Api {
            message: "Token mint cannot be empty".to_string(),
        });
    }
    
    if mint.len() &lt; 32 || mint.len() &gt; 44 {
        return Err(AxiomError::Api {
            message: format!("Invalid mint address length: {}", mint),
        });
    }
    
    if !mint.chars().all(|c| c.is_ascii_alphanumeric()) {
        return Err(AxiomError::Api {
            message: format!("Invalid characters in mint address: {}", mint),
        });
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-use-structured-logging-for-error-tracking"><a class="header" href="#6-use-structured-logging-for-error-tracking">6. Use Structured Logging for Error Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{error, warn, info};

match trading_client.execute_trade(&amp;order).await {
    Ok(result) =&gt; {
        info!(
            transaction_signature = %result.signature,
            amount = %order.amount,
            token = %order.token_mint,
            "Trade executed successfully"
        );
    }
    Err(e) =&gt; {
        error!(
            error = %e,
            order_id = %order.id,
            token = %order.token_mint,
            "Trade execution failed"
        );
        
        // Log additional context for debugging
        warn!(
            user_balance = %current_balance,
            required_amount = %order.amount,
            "Insufficient balance detected"
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-error-scenarios"><a class="header" href="#debugging-error-scenarios">Debugging Error Scenarios</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your application initialization
use tracing_subscriber;

tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .init();
<span class="boring">}</span></code></pre></pre>
<h3 id="common-debugging-commands"><a class="header" href="#common-debugging-commands">Common Debugging Commands</a></h3>
<pre><code class="language-bash"># Run with debug output
RUST_LOG=debug cargo run --example basic_login

# Run specific test with detailed errors
cargo test test_authentication -- --nocapture

# Check network connectivity
curl -v https://api6.axiom.trade/health
</code></pre>
<h3 id="error-investigation-checklist"><a class="header" href="#error-investigation-checklist">Error Investigation Checklist</a></h3>
<ol>
<li>
<p><strong>Check Network Connectivity</strong></p>
<ul>
<li>Verify internet connection</li>
<li>Test API endpoint accessibility</li>
<li>Check firewall settings</li>
</ul>
</li>
<li>
<p><strong>Validate Authentication</strong></p>
<ul>
<li>Verify credentials are correct</li>
<li>Check token expiration</li>
<li>Confirm OTP configuration</li>
</ul>
</li>
<li>
<p><strong>Review Request Parameters</strong></p>
<ul>
<li>Validate token addresses</li>
<li>Check amount ranges</li>
<li>Verify wallet addresses</li>
</ul>
</li>
<li>
<p><strong>Monitor Rate Limits</strong></p>
<ul>
<li>Check request frequency</li>
<li>Review response headers</li>
<li>Implement backoff strategies</li>
</ul>
</li>
<li>
<p><strong>Examine Server Status</strong></p>
<ul>
<li>Check Axiom Trade status page</li>
<li>Monitor Solana network health</li>
<li>Review infrastructure alerts</li>
</ul>
</li>
</ol>
<p>This reference should help developers quickly identify, understand, and resolve errors when working with the Axiom Trade Rust SDK.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/configuration.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/endpoints.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/configuration.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/endpoints.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/custom.js"></script>



    </div>
    </body>
</html>
