<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Debug Guide - axiomtrade-rs Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using the axiomtrade-rs Solana trading SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">axiomtrade-rs Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs/edit/master/docs/src/troubleshooting/debugging.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="debugging-guide"><a class="header" href="#debugging-guide">Debugging Guide</a></h1>
<p>This guide provides comprehensive debugging techniques for axiomtrade-rs, covering logging configuration, network inspection, WebSocket debugging, and common error pattern identification.</p>
<h2 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h2>
<h3 id="basic-logging-setup"><a class="header" href="#basic-logging-setup">Basic Logging Setup</a></h3>
<p>The axiomtrade-rs library uses the <code>tracing</code> crate for structured logging. To enable debug logging in your application:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use tracing::{info, debug, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "axiomtrade_rs=debug,info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

fn main() {
    init_logging();
    // Your application code here
}</code></pre></pre>
<h3 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h3>
<p>Configure different log levels for different components:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Maximum verbosity - shows all internal operations
tracing_subscriber::EnvFilter::new("axiomtrade_rs=trace,debug")

// Standard debugging - shows important operations and errors
tracing_subscriber::EnvFilter::new("axiomtrade_rs=debug,info")

// Production logging - errors and warnings only
tracing_subscriber::EnvFilter::new("axiomtrade_rs=warn,error")
<span class="boring">}</span></code></pre></pre>
<h3 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h3>
<p>Use structured logging to capture context:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, error, Span, span, Level};

let span = span!(Level::INFO, "trading_operation", 
    operation = "buy", 
    token = "SOL", 
    amount = 1.0
);
let _enter = span.enter();

info!("Starting trade execution");
// Trading logic here
<span class="boring">}</span></code></pre></pre>
<h2 id="using-rust_log-environment-variable"><a class="header" href="#using-rust_log-environment-variable">Using RUST_LOG Environment Variable</a></h2>
<h3 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h3>
<p>Set the <code>RUST_LOG</code> environment variable to control logging verbosity:</p>
<pre><code class="language-bash"># Windows Command Prompt
set RUST_LOG=axiomtrade_rs=debug
cargo run --example trading_demo

# Windows PowerShell
$env:RUST_LOG="axiomtrade_rs=debug"
cargo run --example trading_demo

# Linux/macOS
export RUST_LOG=axiomtrade_rs=debug
cargo run --example trading_demo
</code></pre>
<h3 id="advanced-rust_log-patterns"><a class="header" href="#advanced-rust_log-patterns">Advanced RUST_LOG Patterns</a></h3>
<pre><code class="language-bash"># Enable debug logging for all modules
RUST_LOG=debug

# Enable specific module logging
RUST_LOG=axiomtrade_rs::auth=debug,axiomtrade_rs::websocket=trace

# Enable reqwest HTTP client debugging
RUST_LOG=axiomtrade_rs=debug,reqwest=debug,hyper=debug

# Filter by specific operations
RUST_LOG=axiomtrade_rs::trading=debug,axiomtrade_rs::portfolio=info

# Exclude noisy modules
RUST_LOG=debug,h2=off,rustls=off
</code></pre>
<h3 id="environment-specific-configurations"><a class="header" href="#environment-specific-configurations">Environment-Specific Configurations</a></h3>
<p>Create different logging configurations for different environments:</p>
<pre><code class="language-bash"># Development
RUST_LOG=axiomtrade_rs=debug,reqwest=debug

# Testing
RUST_LOG=axiomtrade_rs=trace,test

# Production
RUST_LOG=axiomtrade_rs=warn,error
</code></pre>
<h2 id="inspecting-network-requests"><a class="header" href="#inspecting-network-requests">Inspecting Network Requests</a></h2>
<h3 id="http-request-debugging"><a class="header" href="#http-request-debugging">HTTP Request Debugging</a></h3>
<p>Enable detailed HTTP request/response logging:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Client;
use tracing::{debug, info};

// In your client configuration
let client = Client::builder()
    .connection_verbose(true)  // Enable connection debugging
    .build()?;

// Log requests manually
debug!(
    method = %request.method(),
    url = %request.url(),
    headers = ?request.headers(),
    "Sending HTTP request"
);

let response = client.execute(request).await?;

debug!(
    status = %response.status(),
    headers = ?response.headers(),
    "Received HTTP response"
);
<span class="boring">}</span></code></pre></pre>
<h3 id="requestresponse-interception"><a class="header" href="#requestresponse-interception">Request/Response Interception</a></h3>
<p>Create a middleware to log all API calls:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::{Request, Response};
use tracing::{debug, error};

pub async fn log_request_response(
    request: Request,
    client: &amp;Client,
) -&gt; Result&lt;Response, reqwest::Error&gt; {
    let url = request.url().clone();
    let method = request.method().clone();
    
    debug!(
        method = %method,
        url = %url,
        "Sending request to Axiom API"
    );
    
    let start_time = std::time::Instant::now();
    let response = client.execute(request).await;
    let duration = start_time.elapsed();
    
    match &amp;response {
        Ok(resp) =&gt; {
            debug!(
                status = %resp.status(),
                duration_ms = duration.as_millis(),
                "Received response from Axiom API"
            );
        }
        Err(e) =&gt; {
            error!(
                error = %e,
                duration_ms = duration.as_millis(),
                "Request failed"
            );
        }
    }
    
    response
}
<span class="boring">}</span></code></pre></pre>
<h3 id="capture-full-requestresponse-bodies"><a class="header" href="#capture-full-requestresponse-bodies">Capture Full Request/Response Bodies</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::debug;

// For debugging authentication issues
let body = response.text().await?;
debug!(
    response_body = %body,
    "Full response body received"
);

// For request body debugging
let request_body = serde_json::to_string(&amp;payload)?;
debug!(
    request_body = %request_body,
    "Sending request body"
);
<span class="boring">}</span></code></pre></pre>
<h3 id="network-level-debugging"><a class="header" href="#network-level-debugging">Network-Level Debugging</a></h3>
<p>For deeper network inspection, use external tools:</p>
<pre><code class="language-bash"># Using curl to replicate requests
curl -X POST "https://api.axiom.trade/auth/login" \
     -H "Content-Type: application/json" \
     -H "User-Agent: axiomtrade-rs/1.0.0" \
     -d '{"email":"user@example.com","password_hash":"..."}' \
     -v

# Using tcpdump to capture network traffic (Linux/macOS)
sudo tcpdump -i any -A -s 0 host api.axiom.trade

# Using Wireshark for GUI network analysis
# Filter: host api.axiom.trade
</code></pre>
<h2 id="debugging-websocket-connections"><a class="header" href="#debugging-websocket-connections">Debugging WebSocket Connections</a></h2>
<h3 id="websocket-connection-logging"><a class="header" href="#websocket-connection-logging">WebSocket Connection Logging</a></h3>
<p>Enable comprehensive WebSocket debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{debug, info, warn, error};
use tokio_tungstenite::{connect_async, tungstenite::Message};

async fn debug_websocket_connection(url: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    info!(url = %url, "Attempting WebSocket connection");
    
    let (ws_stream, response) = connect_async(url).await
        .map_err(|e| {
            error!(error = %e, "WebSocket connection failed");
            e
        })?;
    
    info!(
        status = response.status().as_u16(),
        "WebSocket handshake completed"
    );
    
    let (mut write, mut read) = ws_stream.split();
    
    // Log all incoming messages
    while let Some(message) = read.next().await {
        match message {
            Ok(Message::Text(text)) =&gt; {
                debug!(message = %text, "Received WebSocket text message");
            }
            Ok(Message::Binary(data)) =&gt; {
                debug!(
                    size = data.len(),
                    "Received WebSocket binary message"
                );
            }
            Ok(Message::Close(frame)) =&gt; {
                info!(frame = ?frame, "WebSocket connection closed");
                break;
            }
            Err(e) =&gt; {
                error!(error = %e, "WebSocket message error");
                break;
            }
            _ =&gt; {}
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-message-tracing"><a class="header" href="#websocket-message-tracing">WebSocket Message Tracing</a></h3>
<p>Track message flow and timing:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use tracing::{debug, span, Level};

pub struct WebSocketMessageTracer {
    sent_messages: HashMap&lt;String, Instant&gt;,
}

impl WebSocketMessageTracer {
    pub fn track_sent_message(&amp;mut self, message_id: &amp;str) {
        let span = span!(Level::DEBUG, "ws_message_sent", message_id = message_id);
        let _enter = span.enter();
        
        self.sent_messages.insert(message_id.to_string(), Instant::now());
        debug!(message_id = message_id, "WebSocket message sent");
    }
    
    pub fn track_received_response(&amp;mut self, message_id: &amp;str) {
        if let Some(sent_time) = self.sent_messages.remove(message_id) {
            let duration = sent_time.elapsed();
            debug!(
                message_id = message_id,
                response_time_ms = duration.as_millis(),
                "WebSocket response received"
            );
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-state-monitoring"><a class="header" href="#connection-state-monitoring">Connection State Monitoring</a></h3>
<p>Monitor WebSocket connection health:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use tokio::time::{interval, timeout};

pub struct ConnectionMonitor {
    last_message: Instant,
    ping_interval: Duration,
}

impl ConnectionMonitor {
    pub fn new() -&gt; Self {
        Self {
            last_message: Instant::now(),
            ping_interval: Duration::from_secs(30),
        }
    }
    
    pub async fn monitor_connection(&amp;mut self, ws_sender: &amp;mut SplitSink&lt;WebSocketStream&lt;MaybeTlsStream&lt;TcpStream&gt;&gt;, Message&gt;) {
        let mut ping_timer = interval(self.ping_interval);
        
        loop {
            ping_timer.tick().await;
            
            if self.last_message.elapsed() &gt; Duration::from_secs(60) {
                warn!("No messages received for 60 seconds, sending ping");
                
                if let Err(e) = ws_sender.send(Message::Ping(vec![])).await {
                    error!(error = %e, "Failed to send ping");
                    break;
                }
            }
        }
    }
    
    pub fn update_last_message_time(&amp;mut self) {
        self.last_message = Instant::now();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-debugging-tools"><a class="header" href="#websocket-debugging-tools">WebSocket Debugging Tools</a></h3>
<p>External tools for WebSocket debugging:</p>
<pre><code class="language-bash"># Using websocat to test WebSocket connections
websocat wss://ws.axiom.trade/v1/stream -v

# Using wscat (Node.js)
npm install -g wscat
wscat -c wss://ws.axiom.trade/v1/stream

# Browser WebSocket debugging
# Open Chrome DevTools → Network → WS tab
# Shows all WebSocket frames and timing
</code></pre>
<h2 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common Error Patterns</a></h2>
<h3 id="authentication-errors"><a class="header" href="#authentication-errors">Authentication Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Invalid credentials
match error {
    AxiomError::AuthenticationFailed { message } =&gt; {
        error!(
            error_type = "authentication_failed",
            message = %message,
            "Check email/password combination"
        );
        // Check: email format, password hashing, OTP requirements
    }
    AxiomError::TokenExpired =&gt; {
        warn!("Access token expired, attempting refresh");
        // Implement automatic token refresh
    }
    AxiomError::InvalidOtp =&gt; {
        error!("OTP verification failed");
        // Check: OTP format, timing, auto-fetcher configuration
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting-issues"><a class="header" href="#rate-limiting-issues">Rate Limiting Issues</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Rate limit exceeded
match error {
    AxiomError::RateLimitExceeded { retry_after } =&gt; {
        warn!(
            retry_after_seconds = retry_after,
            "Rate limit exceeded, backing off"
        );
        tokio::time::sleep(Duration::from_secs(retry_after as u64)).await;
        // Implement exponential backoff
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-connectivity-problems"><a class="header" href="#network-connectivity-problems">Network Connectivity Problems</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Network timeouts and connection issues
match error {
    AxiomError::NetworkError { source } =&gt; {
        error!(error = %source, "Network connectivity issue");
        // Check: internet connection, DNS resolution, firewall
    }
    AxiomError::TimeoutError =&gt; {
        warn!("Request timeout, retrying with longer timeout");
        // Increase timeout values or implement retry logic
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-connection-issues"><a class="header" href="#websocket-connection-issues">WebSocket Connection Issues</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: WebSocket disconnections
match ws_error {
    AxiomError::WebSocketConnectionLost =&gt; {
        warn!("WebSocket connection lost, attempting reconnection");
        // Implement automatic reconnection with exponential backoff
    }
    AxiomError::WebSocketAuthenticationFailed =&gt; {
        error!("WebSocket authentication failed");
        // Check: token validity, subscription format
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="api-response-parsing-errors"><a class="header" href="#api-response-parsing-errors">API Response Parsing Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Malformed API responses
match error {
    AxiomError::ParseError { response, source } =&gt; {
        error!(
            response_body = %response,
            parse_error = %source,
            "Failed to parse API response"
        );
        // Check: API version compatibility, response format changes
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trading-operation-errors"><a class="header" href="#trading-operation-errors">Trading Operation Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern: Trading execution failures
match error {
    AxiomError::InsufficientBalance { required, available } =&gt; {
        error!(
            required_amount = %required,
            available_amount = %available,
            "Insufficient balance for trade"
        );
    }
    AxiomError::InvalidTokenAddress { address } =&gt; {
        error!(
            token_address = %address,
            "Invalid or unsupported token address"
        );
    }
    AxiomError::SlippageExceeded { expected, actual } =&gt; {
        warn!(
            expected_slippage = %expected,
            actual_slippage = %actual,
            "Trade slippage exceeded tolerance"
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debugging-strategies"><a class="header" href="#debugging-strategies">Debugging Strategies</a></h3>
<ol>
<li><strong>Start with Basic Logging</strong>: Enable <code>RUST_LOG=debug</code> to see general operation flow</li>
<li><strong>Isolate Components</strong>: Test authentication, WebSocket, and trading separately</li>
<li><strong>Check Network Layer</strong>: Use external tools to verify API endpoints</li>
<li><strong>Monitor Resource Usage</strong>: Check memory and CPU usage during operations</li>
<li><strong>Test with Minimal Examples</strong>: Create simple reproduction cases</li>
<li><strong>Compare with Python Implementation</strong>: Use the <code>oldstuff/axiompy</code> reference</li>
</ol>
<h3 id="performance-debugging"><a class="header" href="#performance-debugging">Performance Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use tracing::{debug, warn};

// Measure operation performance
let start = Instant::now();
let result = some_expensive_operation().await;
let duration = start.elapsed();

if duration &gt; Duration::from_millis(1000) {
    warn!(
        operation = "expensive_operation",
        duration_ms = duration.as_millis(),
        "Slow operation detected"
    );
} else {
    debug!(
        operation = "expensive_operation",
        duration_ms = duration.as_millis(),
        "Operation completed"
    );
}
<span class="boring">}</span></code></pre></pre>
<p>This debugging guide provides comprehensive tools and techniques for troubleshooting issues in axiomtrade-rs. Use these patterns to identify and resolve problems efficiently during development and production use.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../troubleshooting/common-issues.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../troubleshooting/faq.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../troubleshooting/common-issues.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../troubleshooting/faq.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/custom.js"></script>



    </div>
    </body>
</html>
