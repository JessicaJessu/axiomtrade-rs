<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OTP Verification - axiomtrade-rs Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using the axiomtrade-rs Solana trading SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">axiomtrade-rs Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs/edit/master/docs/src/auth/otp.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="otp-verification"><a class="header" href="#otp-verification">OTP Verification</a></h1>
<p>The OTP (One-Time Password) verification system in axiomtrade-rs provides both manual and automatic OTP handling for secure authentication with Axiom Trade. This system supports automatic OTP retrieval from email via IMAP, eliminating the need for manual intervention in automated trading systems.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The OTP verification flow consists of two main approaches:</p>
<ol>
<li><strong>Manual OTP Entry</strong> - User manually enters the OTP code when prompted</li>
<li><strong>Automatic OTP Fetching</strong> - System automatically retrieves OTP from email via IMAP</li>
</ol>
<p>Both approaches integrate seamlessly with the authentication system and handle retries, timeouts, and error recovery.</p>
<h2 id="manual-otp-entry"><a class="header" href="#manual-otp-entry">Manual OTP Entry</a></h2>
<p>Manual OTP entry is the simplest approach and requires no additional setup beyond basic authentication credentials.</p>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // The None parameter triggers manual OTP entry
    let tokens = auth_client.login(
        "your-email@domain.com",
        "your-password",
        None  // Will prompt for manual OTP entry
    ).await?;
    
    println!("Authentication successful!");
    Ok(())
}</code></pre></pre>
<h3 id="manual-otp-helper-function"><a class="header" href="#manual-otp-helper-function">Manual OTP Helper Function</a></h3>
<p>You can also provide the OTP code directly if you have it from another source:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::io::{self, Write};

fn get_otp_from_user() -&gt; Result&lt;String, io::Error&gt; {
    print!("Enter OTP code: ");
    io::stdout().flush()?;
    
    let mut otp = String::new();
    io::stdin().read_line(&amp;mut otp)?;
    
    Ok(otp.trim().to_string())
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Get OTP from user input
    let otp_code = get_otp_from_user()?;
    
    let tokens = auth_client.login(
        "your-email@domain.com",
        "your-password",
        Some(otp_code)
    ).await?;
    
    println!("Authentication successful!");
    Ok(())
}</code></pre></pre>
<h2 id="automatic-otp-fetching"><a class="header" href="#automatic-otp-fetching">Automatic OTP Fetching</a></h2>
<p>Automatic OTP fetching eliminates manual intervention by retrieving OTP codes directly from your email via IMAP. This feature is essential for automated trading systems and production applications.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>Before enabling automatic OTP fetching, you need:</p>
<ol>
<li>An inbox.lv email account with IMAP enabled</li>
<li>Axiom Trade configured to send OTP emails to your inbox.lv address</li>
<li>Environment variables configured with IMAP credentials</li>
</ol>
<h3 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h3>
<p>Add these variables to your <code>.env</code> file:</p>
<pre><code class="language-env"># Axiom Trade Credentials
AXIOM_EMAIL=your_axiom_email@domain.com
AXIOM_PASSWORD=your_axiom_password

# inbox.lv IMAP Configuration
INBOX_LV_EMAIL=your_username@inbox.lv
INBOX_LV_PASSWORD=your_imap_password
</code></pre>
<h3 id="automatic-otp-usage"><a class="header" href="#automatic-otp-usage">Automatic OTP Usage</a></h3>
<p>When environment variables are configured, the system automatically fetches OTP codes:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::auth::AuthClient;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load environment variables
    dotenvy::dotenv().ok();
    
    let mut auth_client = AuthClient::new()?;
    
    // Automatic OTP fetching when None is passed
    let tokens = auth_client.login(
        &amp;std::env::var("AXIOM_EMAIL")?,
        &amp;std::env::var("AXIOM_PASSWORD")?,
        None  // System will automatically fetch OTP from email
    ).await?;
    
    println!("Authentication successful with automatic OTP!");
    Ok(())
}</code></pre></pre>
<h3 id="advanced-otp-fetching"><a class="header" href="#advanced-otp-fetching">Advanced OTP Fetching</a></h3>
<p>For more control over the OTP fetching process:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::email::otp_fetcher::{OtpFetcher, from_env};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create OTP fetcher from environment variables
    let otp_fetcher = from_env()?
        .ok_or("OTP fetcher not configured")?;
    
    // Wait for OTP with custom timeout and check interval
    if let Some(otp) = otp_fetcher.wait_for_otp(120, 5)? {
        println!("Retrieved OTP: {}", otp);
        
        // Use the OTP for authentication
        let mut auth_client = AuthClient::new()?;
        let tokens = auth_client.login(
            "your-email@domain.com",
            "your-password",
            Some(otp)
        ).await?;
        
        println!("Authentication successful!");
    } else {
        println!("OTP not received within timeout");
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="otp-validation-flow"><a class="header" href="#otp-validation-flow">OTP Validation Flow</a></h2>
<p>The OTP validation process follows this sequence:</p>
<ol>
<li><strong>Initial Login Request</strong> - Send credentials to <code>/login-password-v2</code></li>
<li><strong>OTP JWT Token</strong> - Receive temporary JWT token for OTP verification</li>
<li><strong>OTP Retrieval</strong> - Get OTP code (manual entry or automatic fetch)</li>
<li><strong>OTP Verification</strong> - Send OTP code to <code>/login-otp</code> with JWT token</li>
<li><strong>Token Receipt</strong> - Receive access and refresh tokens on success</li>
</ol>
<h3 id="flow-diagram"><a class="header" href="#flow-diagram">Flow Diagram</a></h3>
<pre><code>[Credentials] → [login-password-v2] → [OTP JWT Token]
                                            ↓
[OTP Code] ← [Manual/Auto Fetch] ← [OTP Required]
     ↓
[login-otp] → [Access/Refresh Tokens]
</code></pre>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h3>
<p>The authentication client handles the complete flow automatically:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal flow (handled automatically by AuthClient)
async fn login_flow_example() -&gt; Result&lt;(), AuthError&gt; {
    let mut client = AuthClient::new()?;
    
    // Step 1: Initial login - gets OTP JWT token
    let otp_jwt_token = client.login_step1(email, hashed_password).await?;
    
    // Step 2: Fetch OTP (automatic or manual)
    let otp_code = client.fetch_otp().await?;
    
    // Step 3: Verify OTP and get tokens
    let tokens = client.login_step2(&amp;otp_jwt_token, &amp;otp_code, email, hashed_password).await?;
    
    // Tokens are automatically saved by TokenManager
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="retry-logic"><a class="header" href="#retry-logic">Retry Logic</a></h2>
<p>The OTP system includes comprehensive retry logic for robust operation:</p>
<h3 id="email-fetching-retries"><a class="header" href="#email-fetching-retries">Email Fetching Retries</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic retry with exponential backoff
pub fn wait_for_otp(&amp;self, timeout_seconds: u64, check_interval_seconds: u64) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn Error&gt;&gt; {
    let start_time = std::time::Instant::now();
    let timeout_duration = std::time::Duration::from_secs(timeout_seconds);
    let check_interval = std::time::Duration::from_secs(check_interval_seconds);
    
    while start_time.elapsed() &lt; timeout_duration {
        // Check for new OTP emails
        if let Some(otp) = self.fetchotp_recent(3)? {
            return Ok(Some(otp));
        }
        
        // Wait before next check
        std::thread::sleep(check_interval);
    }
    
    Ok(None) // Timeout reached
}
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-retries"><a class="header" href="#authentication-retries">Authentication Retries</a></h3>
<p>The authentication client automatically retries failed requests:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Built-in retry logic for authentication requests
impl AuthClient {
    async fn login_with_retry(&amp;mut self, email: &amp;str, password: &amp;str, max_retries: u32) -&gt; Result&lt;AuthTokens, AuthError&gt; {
        let mut retries = 0;
        
        loop {
            match self.login(email, password, None).await {
                Ok(tokens) =&gt; return Ok(tokens),
                Err(AuthError::NetworkError(_)) if retries &lt; max_retries =&gt; {
                    retries += 1;
                    println!("Login attempt {} failed, retrying...", retries);
                    tokio::time::sleep(tokio::time::Duration::from_secs(retries as u64)).await;
                }
                Err(e) =&gt; return Err(e),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multiple-endpoint-fallback"><a class="header" href="#multiple-endpoint-fallback">Multiple Endpoint Fallback</a></h3>
<p>The system automatically tries different API endpoints on failure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic endpoint rotation on failure
let endpoints = [
    "https://api2.axiom.trade",
    "https://api3.axiom.trade", 
    "https://api6.axiom.trade",
    // ... more endpoints
];

// Client automatically selects different endpoint on retry
<span class="boring">}</span></code></pre></pre>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<h3 id="imap-connection-issues"><a class="header" href="#imap-connection-issues">IMAP Connection Issues</a></h3>
<p><strong>Problem</strong>: Connection to inbox.lv IMAP server fails</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"IMAP connection failed" errors</li>
<li>"Authentication failed" messages</li>
<li>Timeout errors connecting to mail.inbox.lv</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Verify IMAP is enabled</strong>: Wait 15 minutes after enabling IMAP in inbox.lv settings</li>
<li><strong>Check credentials</strong>: Use IMAP password, not web login password</li>
<li><strong>Test connection</strong>: Try logging into inbox.lv webmail to verify credentials</li>
<li><strong>Firewall check</strong>: Ensure port 993 (IMAPS) is not blocked</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test IMAP connection manually
use imap::ClientBuilder;

async fn test_imap_connection() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let tls = native_tls::TlsConnector::builder().build()?;
    let client = imap::connect(("mail.inbox.lv", 993), "mail.inbox.lv", &amp;tls)?;
    
    let _session = client.login("your_email@inbox.lv", "your_imap_password")
        .map_err(|e| format!("IMAP login failed: {:?}", e))?;
    
    println!("IMAP connection successful!");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="otp-email-not-found"><a class="header" href="#otp-email-not-found">OTP Email Not Found</a></h3>
<p><strong>Problem</strong>: System cannot find OTP emails in inbox</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"No OTP emails found" errors</li>
<li>"OTP not received within timeout" messages</li>
<li>Empty email search results</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Check email forwarding</strong>: Verify Axiom Trade sends OTP to inbox.lv address</li>
<li><strong>Check spam folder</strong>: OTP emails might be filtered as spam</li>
<li><strong>Verify email format</strong>: Ensure subject contains "Your Axiom security code is XXXXXX"</li>
<li><strong>Test email delivery</strong>: Send test email to inbox.lv to verify delivery</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual email search for debugging
use axiomtrade_rs::email::otp_fetcher::OtpFetcher;

async fn debug_email_search() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fetcher = OtpFetcher::new(
        "your_email@inbox.lv".to_string(),
        "your_imap_password".to_string()
    );
    
    // Check for any recent emails (not just OTP)
    println!("Searching for recent emails...");
    
    // This would require additional methods in the OtpFetcher implementation
    // to help debug email reception issues
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="otp-extraction-failures"><a class="header" href="#otp-extraction-failures">OTP Extraction Failures</a></h3>
<p><strong>Problem</strong>: OTP found in email but extraction fails</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"OTP extraction failed" errors</li>
<li>Retrieved empty or invalid OTP codes</li>
<li>Regex pattern matching failures</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Check email format</strong>: Verify actual email subject and body format</li>
<li><strong>Update patterns</strong>: Add new regex patterns if email format changed</li>
<li><strong>Manual verification</strong>: Check raw email content for OTP code location</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug OTP extraction
fn debug_otp_extraction(email_content: &amp;str) {
    let patterns = vec![
        r"Your Axiom security code is[:\s]+(\d{6})",
        r"Your security code is[:\s]+(\d{6})",
        r"security code[:\s]+(\d{6})",
        r"&lt;span[^&gt;]*&gt;(\d{6})&lt;/span&gt;",
        r"&lt;b&gt;(\d{6})&lt;/b&gt;",
        r"&lt;strong&gt;(\d{6})&lt;/strong&gt;",
    ];
    
    for pattern in patterns {
        if let Ok(re) = regex::Regex::new(pattern) {
            if let Some(captures) = re.captures(email_content) {
                if let Some(otp) = captures.get(1) {
                    println!("Found OTP '{}' using pattern: {}", otp.as_str(), pattern);
                    return;
                }
            }
        }
    }
    
    println!("No OTP found in email content");
    println!("Email content preview: {}", &amp;email_content[..std::cmp::min(200, email_content.len())]);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-timeout-issues"><a class="header" href="#authentication-timeout-issues">Authentication Timeout Issues</a></h3>
<p><strong>Problem</strong>: OTP verification takes too long or times out</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"Authentication timeout" errors</li>
<li>Slow OTP retrieval (&gt;2 minutes)</li>
<li>Connection timeouts during verification</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Increase timeout</strong>: Extend OTP wait time for slow email delivery</li>
<li><strong>Reduce check interval</strong>: Check for emails more frequently</li>
<li><strong>Network check</strong>: Verify stable internet connection</li>
<li><strong>Server selection</strong>: Try different API endpoints</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom timeout configuration
async fn login_with_custom_timeout() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut auth_client = AuthClient::new()?;
    
    // Configure longer timeout for OTP fetching
    if let Some(otp_fetcher) = auth_client.get_otp_fetcher() {
        // Wait up to 5 minutes, check every 10 seconds
        if let Some(otp) = otp_fetcher.wait_for_otp(300, 10)? {
            let tokens = auth_client.login(
                "email@domain.com",
                "password", 
                Some(otp)
            ).await?;
            println!("Authentication successful with extended timeout!");
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="token-management-issues"><a class="header" href="#token-management-issues">Token Management Issues</a></h3>
<p><strong>Problem</strong>: Token storage or refresh failures</p>
<p><strong>Symptoms</strong>:</p>
<ul>
<li>"Token not found" errors</li>
<li>"Token expired" messages</li>
<li>Authentication succeeds but tokens not saved</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Check file permissions</strong>: Ensure write access to token file location</li>
<li><strong>Verify token format</strong>: Check saved token file structure</li>
<li><strong>Manual token refresh</strong>: Implement custom token refresh logic</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual token management
use axiomtrade_rs::auth::{TokenManager, AuthTokens};

async fn manage_tokens_manually() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let token_manager = TokenManager::new(Some(std::path::PathBuf::from(".axiom_tokens.json")));
    
    // Check for existing tokens
    if let Ok(Some(tokens)) = token_manager.get_tokens().await {
        if tokens.is_expired() {
            println!("Tokens expired, refreshing...");
            
            let mut auth_client = AuthClient::new()?;
            let new_access_token = auth_client.refresh_token(&amp;tokens.refresh_token).await?;
            
            let updated_tokens = AuthTokens {
                access_token: new_access_token,
                refresh_token: tokens.refresh_token,
                expires_at: Some(chrono::Utc::now() + chrono::Duration::hours(1)),
            };
            
            token_manager.set_tokens(updated_tokens).await?;
            println!("Tokens refreshed successfully!");
        } else {
            println!("Tokens are still valid");
        }
    } else {
        println!("No existing tokens found, need to login");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li><strong>Dedicated Email</strong>: Use inbox.lv account only for OTP purposes</li>
<li><strong>Environment Variables</strong>: Store credentials in <code>.env</code> file, never in code</li>
<li><strong>File Permissions</strong>: Secure token storage files with appropriate permissions</li>
<li><strong>Credential Rotation</strong>: Regularly update IMAP passwords</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ol>
<li><strong>Connection Pooling</strong>: Reuse IMAP connections when possible</li>
<li><strong>Caching</strong>: Cache successful configurations to reduce setup time</li>
<li><strong>Async Operations</strong>: Use async/await for all network operations</li>
<li><strong>Timeout Tuning</strong>: Optimize timeout values based on email delivery speed</li>
</ol>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<ol>
<li><strong>Graceful Degradation</strong>: Fall back to manual OTP when automatic fails</li>
<li><strong>Detailed Logging</strong>: Log OTP retrieval steps for debugging</li>
<li><strong>User Feedback</strong>: Provide clear status messages during OTP process</li>
<li><strong>Retry Strategies</strong>: Implement exponential backoff for failed requests</li>
</ol>
<h3 id="production-deployment"><a class="header" href="#production-deployment">Production Deployment</a></h3>
<ol>
<li><strong>Health Checks</strong>: Monitor OTP system health and email delivery</li>
<li><strong>Alerting</strong>: Set up alerts for OTP failures or slow delivery</li>
<li><strong>Backup Methods</strong>: Have manual OTP fallback for system maintenance</li>
<li><strong>Documentation</strong>: Maintain setup documentation for team members</li>
</ol>
<h2 id="testing-your-setup"><a class="header" href="#testing-your-setup">Testing Your Setup</a></h2>
<p>Use the provided test example to verify your OTP configuration:</p>
<pre><code class="language-bash">cargo run --example test_auto_otp
</code></pre>
<p>This test will:</p>
<ol>
<li>Verify environment variable configuration</li>
<li>Test IMAP connection to inbox.lv</li>
<li>Attempt full authentication flow with automatic OTP</li>
<li>Provide detailed diagnostic information on failures</li>
</ol>
<p>The test output will guide you through any configuration issues and provide specific troubleshooting steps for your setup.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../auth/sessions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../api/portfolio.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../auth/sessions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../api/portfolio.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/custom.js"></script>



    </div>
    </body>
</html>
