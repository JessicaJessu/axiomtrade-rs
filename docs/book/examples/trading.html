<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Trading Examples - axiomtrade-rs Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Complete guide to using the axiomtrade-rs Solana trading SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">axiomtrade-rs Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/vibheksoni/axiomtrade-rs/edit/master/docs/src/examples/trading.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="trading-examples"><a class="header" href="#trading-examples">Trading Examples</a></h1>
<p>This section provides comprehensive examples for using the Axiom Trade API trading functionality, including simple trades, error handling patterns, and advanced trading strategies.</p>
<h2 id="simple-trade-example"><a class="header" href="#simple-trade-example">Simple Trade Example</a></h2>
<p>The <code>simple_trade.rs</code> example demonstrates the fundamental trading operations available through the Axiom Trade API. This example serves as a starting point for understanding the trading workflow and best practices.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>The simple trade example showcases:</p>
<ul>
<li>Authentication setup for trading</li>
<li>Buy and sell operations simulation</li>
<li>Price quote retrieval</li>
<li>Parameter validation</li>
<li>Error handling patterns</li>
<li>Security best practices</li>
</ul>
<h3 id="example-walkthrough"><a class="header" href="#example-walkthrough">Example Walkthrough</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024">use axiomtrade_rs::{AuthClient, Result, AxiomError};
use axiomtrade_rs::api::trading::TradingClient;
use std::env;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Load credentials and authenticate
    dotenvy::dotenv().ok();
    let mut trading_client = authenticate().await?;

    // Trading parameters
    let token_mint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // USDC
    let amount_sol = 0.001; // Small demonstration amount
    
    // Execute buy operation
    simulate_buy_trade(&amp;mut trading_client, token_mint, amount_sol).await?;
    
    // Execute sell operation  
    let amount_tokens = 1.0; // 1 USDC
    simulate_sell_trade(&amp;mut trading_client, token_mint, amount_tokens).await?;
    
    Ok(())
}</code></pre></pre>
<h3 id="authentication-setup"><a class="header" href="#authentication-setup">Authentication Setup</a></h3>
<p>The example begins with proper authentication using environment variables:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn authenticate() -&gt; Result&lt;TradingClient&gt; {
    let email = env::var("AXIOM_EMAIL")
        .expect("AXIOM_EMAIL must be set in .env file");
    let password = env::var("AXIOM_PASSWORD")
        .expect("AXIOM_PASSWORD must be set in .env file");

    let mut auth_client = AuthClient::new()?;
    
    match auth_client.login_full(&amp;email, &amp;password, None).await {
        Ok(login_result) =&gt; {
            println!("Authentication successful!");
            println!("Access token obtained: {}", &amp;login_result.tokens.access_token[..20]);
        }
        Err(e) =&gt; {
            return Err(AxiomError::Auth(e));
        }
    }

    TradingClient::new().map_err(|e| AxiomError::Api {
        message: format!("Failed to create trading client: {}", e),
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="trade-parameters"><a class="header" href="#trade-parameters">Trade Parameters</a></h2>
<h3 id="essential-parameters"><a class="header" href="#essential-parameters">Essential Parameters</a></h3>
<p>When executing trades, several key parameters must be configured:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>token_mint</code></td><td><code>&amp;str</code></td><td>Target token mint address</td><td><code>"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"</code></td></tr>
<tr><td><code>amount</code></td><td><code>f64</code></td><td>Trade amount in base units</td><td><code>0.001</code> (SOL) or <code>1.0</code> (tokens)</td></tr>
<tr><td><code>slippage</code></td><td><code>Option&lt;f64&gt;</code></td><td>Maximum acceptable slippage percentage</td><td><code>Some(1.0)</code> (1%)</td></tr>
<tr><td><code>priority_fee</code></td><td><code>Option&lt;f64&gt;</code></td><td>Additional priority fee in SOL</td><td><code>Some(0.00001)</code></td></tr>
</tbody></table>
</div>
<h3 id="token-mint-addresses"><a class="header" href="#token-mint-addresses">Token Mint Addresses</a></h3>
<p>Common token mint addresses used in examples:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Native SOL
const SOL_MINT: &amp;str = "So11111111111111111111111111111111111111112";

// USDC
const USDC_MINT: &amp;str = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

// USDT  
const USDT_MINT: &amp;str = "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB";
<span class="boring">}</span></code></pre></pre>
<h3 id="slippage-configuration"><a class="header" href="#slippage-configuration">Slippage Configuration</a></h3>
<p>Slippage tolerance should be set based on token liquidity and market conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slippage_scenarios = vec![0.1, 0.5, 1.0, 2.0, 5.0];

for slippage in slippage_scenarios {
    let estimated_impact = calculate_slippage_impact(amount_sol, slippage);
    println!("{}% slippage tolerance - Max cost: {} SOL", 
        slippage, estimated_impact);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Recommended slippage settings:</strong></p>
<ul>
<li><strong>Liquid tokens (SOL, USDC, USDT)</strong>: 0.1% - 0.5%</li>
<li><strong>Mid-cap tokens</strong>: 0.5% - 1.0%</li>
<li><strong>Low liquidity tokens</strong>: 1.0% - 5.0%</li>
<li><strong>Volatile markets</strong>: 2.0% - 5.0%</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The trading system implements comprehensive error handling patterns to ensure robust operation.</p>
<h3 id="parameter-validation"><a class="header" href="#parameter-validation">Parameter Validation</a></h3>
<p>All trading parameters undergo validation before execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_amount(amount: f64, unit: &amp;str) -&gt; Result&lt;()&gt; {
    if amount &lt;= 0.0 {
        return Err(AxiomError::Api {
            message: format!("Amount must be greater than 0, got {} {}", amount, unit),
        });
    }
    
    if amount.is_nan() || amount.is_infinite() {
        return Err(AxiomError::Api {
            message: format!("Invalid amount: {} {}", amount, unit),
        });
    }
    
    Ok(())
}

fn validate_token_mint(mint: &amp;str) -&gt; Result&lt;()&gt; {
    if mint.is_empty() {
        return Err(AxiomError::Api {
            message: "Token mint cannot be empty".to_string(),
        });
    }
    
    if mint.len() &lt; 32 || mint.len() &gt; 44 {
        return Err(AxiomError::Api {
            message: format!("Invalid mint address length: {}", mint),
        });
    }
    
    if !mint.chars().all(|c| c.is_ascii_alphanumeric()) {
        return Err(AxiomError::Api {
            message: format!("Invalid characters in mint address: {}", mint),
        });
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trading-limits-verification"><a class="header" href="#trading-limits-verification">Trading Limits Verification</a></h3>
<p>Before executing trades, the system checks against trading limits:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.get_trading_limits().await {
    Ok(limits) =&gt; {
        if amount_sol &lt; limits.min_sol_amount {
            return Err(AxiomError::Api {
                message: format!("Amount {} SOL is below minimum {}", 
                    amount_sol, limits.min_sol_amount)
            });
        }
        if amount_sol &gt; limits.max_sol_amount {
            return Err(AxiomError::Api {
                message: format!("Amount {} SOL exceeds maximum {}", 
                    amount_sol, limits.max_sol_amount)
            });
        }
    }
    Err(_) =&gt; println!("Could not verify trading limits"),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="quote-retrieval-error-handling"><a class="header" href="#quote-retrieval-error-handling">Quote Retrieval Error Handling</a></h3>
<p>Price quotes may fail due to network issues or market conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.get_quote(sol_mint, token_mint, amount_sol, Some(1.0)).await {
    Ok(quote) =&gt; {
        println!("Current swap quote:");
        println!("  Input: {} SOL", quote.in_amount);
        println!("  Output: {} tokens", quote.out_amount);
        println!("  Price impact: {:.2}%", quote.price_impact);
        println!("  Fee: {} SOL", quote.fee);
    }
    Err(e) =&gt; {
        println!("Failed to get quote: {}", e);
        // Implement retry logic or fallback strategy
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-pre-trade-validation"><a class="header" href="#1-pre-trade-validation">1. Pre-Trade Validation</a></h3>
<p>Always validate all parameters before executing trades:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate trade parameters
validate_amount(amount_sol, "SOL")?;
validate_token_mint(token_mint)?;

// Check trading limits
let limits = client.get_trading_limits().await?;
ensure_within_limits(amount_sol, &amp;limits)?;

// Get current quote for verification
let quote = client.get_quote(from_mint, to_mint, amount, slippage).await?;
verify_quote_acceptable(&amp;quote)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-liquidity-assessment"><a class="header" href="#2-liquidity-assessment">2. Liquidity Assessment</a></h3>
<p>Check token liquidity before executing large trades:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn assess_liquidity(client: &amp;TradingClient, token_mint: &amp;str) -&gt; Result&lt;bool&gt; {
    match client.get_token_info(token_mint).await {
        Ok(info) =&gt; {
            println!("Token liquidity: {} SOL", info.liquidity_sol);
            println!("24h volume: {} SOL", info.volume_24h);
            
            // Consider liquid if &gt; 100 SOL liquidity and &gt; 10 SOL daily volume
            Ok(info.liquidity_sol &gt; 100.0 &amp;&amp; info.volume_24h &gt; 10.0)
        }
        Err(_) =&gt; {
            println!("Could not assess liquidity for {}", token_mint);
            Ok(false)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-slippage-management"><a class="header" href="#3-slippage-management">3. Slippage Management</a></h3>
<p>Implement dynamic slippage based on market conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_optimal_slippage(
    amount: f64, 
    liquidity: f64, 
    volatility: f64
) -&gt; f64 {
    let base_slippage = 0.5; // 0.5% base
    let liquidity_factor = (amount / liquidity).min(0.1); // Cap at 10%
    let volatility_factor = volatility.min(0.05); // Cap at 5%
    
    base_slippage + liquidity_factor + volatility_factor
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-transaction-monitoring"><a class="header" href="#4-transaction-monitoring">4. Transaction Monitoring</a></h3>
<p>Monitor transaction status after execution:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn monitor_transaction(
    client: &amp;TradingClient, 
    signature: &amp;str
) -&gt; Result&lt;()&gt; {
    let mut attempts = 0;
    let max_attempts = 30; // 30 seconds timeout
    
    while attempts &lt; max_attempts {
        match client.get_transaction_status(signature).await {
            Ok(status) =&gt; {
                match status.as_str() {
                    "confirmed" =&gt; {
                        println!("Transaction confirmed: {}", signature);
                        return Ok(());
                    }
                    "failed" =&gt; {
                        return Err(AxiomError::Api {
                            message: format!("Transaction failed: {}", signature),
                        });
                    }
                    _ =&gt; {
                        println!("Transaction pending... ({})", status);
                    }
                }
            }
            Err(_) =&gt; {
                println!("Could not check transaction status");
            }
        }
        
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        attempts += 1;
    }
    
    Err(AxiomError::Api {
        message: "Transaction timeout".to_string(),
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-portfolio-impact-analysis"><a class="header" href="#5-portfolio-impact-analysis">5. Portfolio Impact Analysis</a></h3>
<p>Assess how trades will affect your portfolio:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn analyze_portfolio_impact(
    client: &amp;TradingClient,
    token_mint: &amp;str,
    amount: f64,
    is_buy: bool
) -&gt; Result&lt;()&gt; {
    let portfolio = client.get_portfolio().await?;
    
    if is_buy {
        // Check if we have sufficient SOL
        if portfolio.sol_balance &lt; amount {
            return Err(AxiomError::Api {
                message: format!("Insufficient SOL balance: {} &lt; {}", 
                    portfolio.sol_balance, amount),
            });
        }
    } else {
        // Check if we have sufficient tokens to sell
        let token_balance = portfolio.get_token_balance(token_mint);
        if token_balance &lt; amount {
            return Err(AxiomError::Api {
                message: format!("Insufficient token balance: {} &lt; {}", 
                    token_balance, amount),
            });
        }
    }
    
    println!("Portfolio impact analysis passed");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-trading-patterns"><a class="header" href="#advanced-trading-patterns">Advanced Trading Patterns</a></h2>
<h3 id="1-dollar-cost-averaging-dca"><a class="header" href="#1-dollar-cost-averaging-dca">1. Dollar Cost Averaging (DCA)</a></h3>
<p>Implement systematic buying over time:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DCAStrategy {
    token_mint: String,
    amount_per_trade: f64,
    interval_hours: u64,
    total_trades: usize,
    completed_trades: usize,
}

impl DCAStrategy {
    pub async fn execute_next_trade(
        &amp;mut self, 
        client: &amp;mut TradingClient
    ) -&gt; Result&lt;()&gt; {
        if self.completed_trades &gt;= self.total_trades {
            return Err(AxiomError::Api {
                message: "DCA strategy completed".to_string(),
            });
        }
        
        println!("Executing DCA trade {}/{}", 
            self.completed_trades + 1, self.total_trades);
            
        // Execute buy with current market conditions
        let result = client.buy_token(
            &amp;self.token_mint,
            self.amount_per_trade,
            Some(1.0) // 1% slippage tolerance
        ).await?;
        
        self.completed_trades += 1;
        
        println!("DCA trade executed: {}", result.signature);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-grid-trading"><a class="header" href="#2-grid-trading">2. Grid Trading</a></h3>
<p>Implement grid trading strategy:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GridStrategy {
    token_mint: String,
    base_price: f64,
    grid_spacing: f64,
    grid_levels: usize,
    amount_per_level: f64,
    buy_orders: Vec&lt;GridOrder&gt;,
    sell_orders: Vec&lt;GridOrder&gt;,
}

#[derive(Debug)]
pub struct GridOrder {
    price: f64,
    amount: f64,
    executed: bool,
}

impl GridStrategy {
    pub fn new(
        token_mint: String,
        base_price: f64,
        grid_spacing: f64,
        grid_levels: usize,
        amount_per_level: f64,
    ) -&gt; Self {
        let mut buy_orders = Vec::new();
        let mut sell_orders = Vec::new();
        
        // Create buy orders below current price
        for i in 1..=grid_levels {
            let price = base_price * (1.0 - (i as f64 * grid_spacing));
            buy_orders.push(GridOrder {
                price,
                amount: amount_per_level,
                executed: false,
            });
        }
        
        // Create sell orders above current price
        for i in 1..=grid_levels {
            let price = base_price * (1.0 + (i as f64 * grid_spacing));
            sell_orders.push(GridOrder {
                price,
                amount: amount_per_level,
                executed: false,
            });
        }
        
        Self {
            token_mint,
            base_price,
            grid_spacing,
            grid_levels,
            amount_per_level,
            buy_orders,
            sell_orders,
        }
    }
    
    pub async fn check_and_execute(
        &amp;mut self, 
        client: &amp;mut TradingClient,
        current_price: f64
    ) -&gt; Result&lt;()&gt; {
        // Check buy orders
        for order in &amp;mut self.buy_orders {
            if !order.executed &amp;&amp; current_price &lt;= order.price {
                println!("Executing grid buy at {}", order.price);
                
                match client.buy_token(&amp;self.token_mint, order.amount, Some(0.5)).await {
                    Ok(_) =&gt; {
                        order.executed = true;
                        println!("Grid buy executed successfully");
                    }
                    Err(e) =&gt; {
                        println!("Grid buy failed: {}", e);
                    }
                }
            }
        }
        
        // Check sell orders
        for order in &amp;mut self.sell_orders {
            if !order.executed &amp;&amp; current_price &gt;= order.price {
                println!("Executing grid sell at {}", order.price);
                
                match client.sell_token(&amp;self.token_mint, order.amount, Some(0.5)).await {
                    Ok(_) =&gt; {
                        order.executed = true;
                        println!("Grid sell executed successfully");
                    }
                    Err(e) =&gt; {
                        println!("Grid sell failed: {}", e);
                    }
                }
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-stop-loss-implementation"><a class="header" href="#3-stop-loss-implementation">3. Stop Loss Implementation</a></h3>
<p>Implement automatic stop loss orders:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StopLossManager {
    positions: Vec&lt;StopLossPosition&gt;,
}

#[derive(Debug)]
pub struct StopLossPosition {
    token_mint: String,
    entry_price: f64,
    amount: f64,
    stop_loss_percent: f64,
    trailing: bool,
    highest_price: f64,
}

impl StopLossManager {
    pub async fn check_positions(
        &amp;mut self,
        client: &amp;mut TradingClient
    ) -&gt; Result&lt;()&gt; {
        for position in &amp;mut self.positions {
            // Get current price
            let current_price = self.get_current_price(client, &amp;position.token_mint).await?;
            
            // Update trailing stop
            if position.trailing &amp;&amp; current_price &gt; position.highest_price {
                position.highest_price = current_price;
            }
            
            // Calculate stop loss price
            let reference_price = if position.trailing {
                position.highest_price
            } else {
                position.entry_price
            };
            
            let stop_price = reference_price * (1.0 - position.stop_loss_percent / 100.0);
            
            // Execute stop loss if triggered
            if current_price &lt;= stop_price {
                println!("Stop loss triggered for {} at price {}", 
                    position.token_mint, current_price);
                    
                match client.sell_token(&amp;position.token_mint, position.amount, Some(2.0)).await {
                    Ok(result) =&gt; {
                        println!("Stop loss executed: {}", result.signature);
                        // Remove position after execution
                    }
                    Err(e) =&gt; {
                        println!("Stop loss execution failed: {}", e);
                    }
                }
            }
        }
        
        Ok(())
    }
    
    async fn get_current_price(
        &amp;self,
        client: &amp;TradingClient,
        token_mint: &amp;str
    ) -&gt; Result&lt;f64&gt; {
        let sol_mint = "So11111111111111111111111111111111111111112";
        let quote = client.get_quote(token_mint, sol_mint, 1.0, Some(0.5)).await?;
        Ok(quote.out_amount)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-arbitrage-detection"><a class="header" href="#4-arbitrage-detection">4. Arbitrage Detection</a></h3>
<p>Detect arbitrage opportunities across different markets:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArbitrageScanner {
    min_profit_percent: f64,
    max_trade_amount: f64,
}

#[derive(Debug)]
pub struct ArbitrageOpportunity {
    token_mint: String,
    buy_market: String,
    sell_market: String,
    buy_price: f64,
    sell_price: f64,
    profit_percent: f64,
    max_amount: f64,
}

impl ArbitrageScanner {
    pub async fn scan_opportunities(
        &amp;self,
        client: &amp;TradingClient,
        tokens: &amp;[String]
    ) -&gt; Result&lt;Vec&lt;ArbitrageOpportunity&gt;&gt; {
        let mut opportunities = Vec::new();
        
        for token in tokens {
            // Get prices from different markets/DEXs
            let prices = self.get_multi_market_prices(client, token).await?;
            
            if prices.len() &lt; 2 {
                continue;
            }
            
            // Find min and max prices
            let min_price_market = prices.iter().min_by(|a, b| 
                a.price.partial_cmp(&amp;b.price).unwrap()).unwrap();
            let max_price_market = prices.iter().max_by(|a, b| 
                a.price.partial_cmp(&amp;b.price).unwrap()).unwrap();
            
            let profit_percent = 
                (max_price_market.price - min_price_market.price) / 
                min_price_market.price * 100.0;
            
            if profit_percent &gt;= self.min_profit_percent {
                opportunities.push(ArbitrageOpportunity {
                    token_mint: token.clone(),
                    buy_market: min_price_market.market.clone(),
                    sell_market: max_price_market.market.clone(),
                    buy_price: min_price_market.price,
                    sell_price: max_price_market.price,
                    profit_percent,
                    max_amount: self.max_trade_amount.min(min_price_market.liquidity),
                });
            }
        }
        
        Ok(opportunities)
    }
    
    async fn get_multi_market_prices(
        &amp;self,
        client: &amp;TradingClient,
        token: &amp;str
    ) -&gt; Result&lt;Vec&lt;MarketPrice&gt;&gt; {
        // Implementation would query multiple DEXs/markets
        // This is a simplified example
        Ok(vec![])
    }
}

#[derive(Debug)]
struct MarketPrice {
    market: String,
    price: f64,
    liquidity: f64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<p>To run the trading examples:</p>
<ol>
<li>
<p><strong>Set up environment variables:</strong></p>
<pre><code class="language-bash">cp .env.example .env
# Edit .env with your credentials
</code></pre>
</li>
<li>
<p><strong>Run the simple trade example:</strong></p>
<pre><code class="language-bash">cargo run --example simple_trade
</code></pre>
</li>
<li>
<p><strong>Run with debug output:</strong></p>
<pre><code class="language-bash">RUST_LOG=debug cargo run --example simple_trade
</code></pre>
</li>
<li>
<p><strong>Run specific trading strategy:</strong></p>
<pre><code class="language-bash">cargo run --example grid_trading
cargo run --example dca_strategy  
cargo run --example stop_loss
</code></pre>
</li>
</ol>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="never-share-sensitive-information"><a class="header" href="#never-share-sensitive-information">Never share sensitive information:</a></h3>
<ul>
<li>Private keys or seed phrases</li>
<li>Access tokens or refresh tokens</li>
<li>API credentials</li>
<li>Trading strategies or positions</li>
</ul>
<h3 id="always-verify-before-execution"><a class="header" href="#always-verify-before-execution">Always verify before execution:</a></h3>
<ul>
<li>Transaction details and amounts</li>
<li>Recipient addresses and token mints</li>
<li>Slippage tolerance and fees</li>
<li>Market conditions and liquidity</li>
</ul>
<h3 id="use-appropriate-security-measures"><a class="header" href="#use-appropriate-security-measures">Use appropriate security measures:</a></h3>
<ul>
<li>Hardware wallets for large amounts</li>
<li>Multi-signature wallets for institutional use</li>
<li>MEV protection services during high volatility</li>
<li>Regular security audits of trading strategies</li>
</ul>
<h3 id="monitor-for-suspicious-activity"><a class="header" href="#monitor-for-suspicious-activity">Monitor for suspicious activity:</a></h3>
<ul>
<li>Unexpected price movements</li>
<li>Failed transactions or errors</li>
<li>Unusual network latency</li>
<li>Account access from unknown locations</li>
</ul>
<p>The trading examples provide a comprehensive foundation for building sophisticated trading applications while maintaining security and reliability standards.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../examples/portfolio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../examples/websocket.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../examples/portfolio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../examples/websocket.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/custom.js"></script>



    </div>
    </body>
</html>
