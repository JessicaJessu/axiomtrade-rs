use std::fs;
use std::io::{self, Write};
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("axiomtrade-rs Environment Setup");
    println!("===============================\n");
    
    println!("This script will help you configure your .env file with proper escaping");
    println!("for special characters in passwords and email addresses.\n");
    
    // Axiom Trade credentials
    println!("Axiom Trade Credentials");
    println!("-----------------------");
    let axiom_email = prompt_required("Email: ")?;
    let axiom_password = prompt_password("Password: ")?;
    
    // Optional OTP setup
    println!("\nOptional: Automatic OTP Setup");
    println!("------------------------------");
    println!("For automatic OTP fetching, you need an inbox.lv account.");
    println!("See setup guide: examples/setup/auto_otp_setup.md\n");
    
    let setup_otp = prompt("Set up automatic OTP? (y/N): ")?;
    let (inbox_email, inbox_password) = if setup_otp.to_lowercase() == "y" {
        println!("\ninbox.lv Credentials");
        println!("--------------------");
        let email = prompt_required("inbox.lv Email: ")?;
        let password = prompt_password("inbox.lv IMAP Password: ")?;
        (Some(email), Some(password))
    } else {
        (None, None)
    };
    
    // Create .env content
    let mut env_content = vec![
        "# axiomtrade-rs Environment Configuration".to_string(),
        "# Generated by setup_env.rs".to_string(),
        "".to_string(),
        "# Axiom Trade Credentials".to_string(),
        format!("AXIOM_EMAIL={}", escape_env_value(&axiom_email)),
        format!("AXIOM_PASSWORD={}", escape_env_value(&axiom_password)),
        "".to_string(),
    ];
    
    // Add OTP configuration
    if let (Some(email), Some(password)) = (inbox_email, inbox_password) {
        env_content.extend(vec![
            "# Automatic OTP via inbox.lv".to_string(),
            "# Enable IMAP at: https://email.inbox.lv/prefs?group=enable_pop3".to_string(),
            format!("INBOX_LV_EMAIL={}", escape_env_value(&email)),
            format!("INBOX_LV_PASSWORD={}", escape_env_value(&password)),
            "".to_string(),
        ]);
    } else {
        env_content.extend(vec![
            "# Optional: Automatic OTP via inbox.lv (not configured)".to_string(),
            "# INBOX_LV_EMAIL=your-email@inbox.lv".to_string(),
            "# INBOX_LV_PASSWORD=your-imap-password".to_string(),
            "".to_string(),
        ]);
    }
    
    // Add additional configuration options
    env_content.extend(vec![
        "# Optional: Additional Configuration".to_string(),
        "# AXIOM_API_BASE_URL=https://api.axiom.trade".to_string(),
        "# AXIOM_WS_URL=wss://api.axiom.trade/ws".to_string(),
        "# RUST_LOG=debug".to_string(),
    ]);
    
    // Handle existing .env file
    let env_path = Path::new(".env");
    if env_path.exists() {
        println!("\nWARNING: .env file already exists!");
        let overwrite = prompt("Overwrite existing .env file? (y/N): ")?;
        if overwrite.to_lowercase() != "y" {
            println!("Setup cancelled");
            return Ok(());
        }
        
        // Create backup
        let backup_path = ".env.backup";
        fs::copy(env_path, backup_path)?;
        println!("Backed up existing .env to {}", backup_path);
    }
    
    // Write .env file
    let final_content = env_content.join("\n");
    fs::write(env_path, final_content)?;
    
    // Set secure permissions on Unix
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(env_path, fs::Permissions::from_mode(0o600))?;
    }
    
    // Success message
    println!("\nSetup Complete!");
    println!("===============\n");
    println!(".env file created successfully");
    println!("Credentials properly escaped");
    println!("File permissions secured\n");
    
    println!("Next steps:");
    println!("1. Run: cargo run --example basic_login");
    println!("2. Check examples/setup/ for more configuration options");
    println!("3. View documentation at: https://docs.rs/axiomtrade-rs\n");
    
    if env_content.iter().any(|line| line.contains("INBOX_LV_EMAIL=")) {
        println!("OTP Setup Reminder:");
        println!("- Make sure IMAP is enabled on your inbox.lv account");
        println!("- Forward Axiom OTP emails to your inbox.lv address");
        println!("- See: examples/setup/auto_otp_setup.md\n");
    }
    
    println!("Security Notes:");
    println!("- .env file contains sensitive credentials");
    println!("- Never commit .env to version control");
    println!("- .env is already in .gitignore");
    
    Ok(())
}

fn prompt(message: &str) -> Result<String, Box<dyn std::error::Error>> {
    print!("{}", message);
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

fn prompt_required(message: &str) -> Result<String, Box<dyn std::error::Error>> {
    loop {
        let input = prompt(message)?;
        if !input.is_empty() {
            return Ok(input);
        }
        println!("This field is required. Please enter a value.");
    }
}

fn prompt_password(message: &str) -> Result<String, Box<dyn std::error::Error>> {
    print!("{}", message);
    io::stdout().flush()?;
    
    // Simple visible input for now
    println!("(Note: password will be visible)");
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    let password = input.trim().to_string();
    
    if password.is_empty() {
        println!("Password cannot be empty");
        return prompt_password(message);
    }
    
    println!("Password entered ({} characters)", password.len());
    Ok(password)
}

fn escape_env_value(value: &str) -> String {
    if value.is_empty() {
        return "\"\"".to_string();
    }
    
    // Check if value needs quoting
    let needs_quotes = value.contains(' ') 
        || value.contains('\t')
        || value.contains('\n') 
        || value.contains('\r')
        || value.contains('"')
        || value.contains('\'')
        || value.contains('\\')
        || value.contains('$')
        || value.contains('`')
        || value.contains('#')
        || value.starts_with(' ')
        || value.ends_with(' ');
    
    if needs_quotes {
        // Escape special characters and wrap in quotes
        let escaped = value
            .replace('\\', "\\\\")  // Escape backslashes first
            .replace('"', "\\\"")   // Escape quotes
            .replace('$', "\\$")    // Escape variable expansion
            .replace('`', "\\`")    // Escape command substitution
            .replace('\n', "\\n")   // Escape newlines
            .replace('\r', "\\r");  // Escape carriage returns
        
        format!("\"{}\"", escaped)
    } else {
        value.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_escape_env_value() {
        assert_eq!(escape_env_value("simple"), "simple");
        assert_eq!(escape_env_value("with space"), "\"with space\"");
        assert_eq!(escape_env_value("with\"quote"), "\"with\\\"quote\"");
        assert_eq!(escape_env_value("with$dollar"), "\"with\\$dollar\"");
        assert_eq!(escape_env_value(""), "\"\"");
        assert_eq!(escape_env_value("complex password!@#$%"), "\"complex password!@#\\$%\"");
    }
}